using System.Collections.Immutable;
using ANcpLua.Roslyn.Utilities.Models;
using ErrorOr.Analyzers;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Diagnostics;

namespace ErrorOr.Generators;

/// <summary>
///     Generator entry point for ErrorOr endpoint mappings.
///     Generates MapErrorOrEndpoints() and AddErrorOrEndpoints() fluent configuration extension methods.
/// </summary>
[Generator(LanguageNames.CSharp)]
public sealed partial class ErrorOrEndpointGenerator : IIncrementalGenerator
{
    /// <inheritdoc />
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(EmitAttributes);

        // Create ErrorOrContext once per compilation (fixes N+1 symbol lookup performance issue)
        var errorOrContextProvider = ErrorOrContext.CreateProvider(context)
            .WithTrackingName(TrackingNames.ErrorOrContext);

        var endpoints = CombineHttpMethodProviders(context, errorOrContextProvider);
        var jsonContexts = JsonContextProvider.Create(context).CollectAsEquatableArray();
        var generateJsonContextOption = context.AnalyzerConfigOptionsProvider
            .Select(ParseGenerateJsonContextOption);
        var publishAotOption = context.AnalyzerConfigOptionsProvider
            .Select(ParsePublishAotOption);
        var referenceArities = context.MetadataReferencesProvider
            .Select(static (reference, _) => ResultsUnionTypeBuilder.GetResultsUnionArity(reference))
            .CollectAsEquatableArray();
        var maxResultsUnionArity = referenceArities
            .Select(static (arities, _) => ResultsUnionTypeBuilder.DetectMaxArity(arities.AsImmutableArray()))
            .WithTrackingName(TrackingNames.ResultsUnionMaxArity);

        var hasValidationResolverSupport = errorOrContextProvider
            .Select(static (ctx, _) => ctx.HasValidationResolverSupport);

        var emitInput = endpoints.Combine(jsonContexts).Combine(generateJsonContextOption).Combine(publishAotOption)
            .Combine(maxResultsUnionArity).Combine(hasValidationResolverSupport)
            .Select(static (data, _) =>
            {
                var (((((ep, jc), gjc), pa), mra), hvrs) = data;
                return new EmitContext(ep, jc, gjc, pa, mra, hvrs);
            });

        context.RegisterSourceOutput(emitInput, static (spc, ctx) => EmitMappingsAndRunAnalysis(spc, in ctx));
    }

    /// <summary>
    ///     Emits the marker attributes that users apply to their endpoint handler methods.
    ///     This must be registered by this generator (not just OpenApiTransformerGenerator)
    ///     because ForAttributeWithMetadataName only sees types from PostInitializationOutput
    ///     within the same generator.
    /// </summary>
    private static void EmitAttributes(IncrementalGeneratorPostInitializationContext context)
    {
        const string source = """
                              // <auto-generated/>
                              #nullable enable

                              namespace ErrorOr
                              {
                                  /// <summary>
                                  /// Marks a static method as an ErrorOr endpoint with explicit HTTP method and route.
                                  /// Prefer using [Get], [Post], [Put], [Delete], or [Patch] for standard HTTP methods.
                                  /// </summary>
                                  [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = false)]
                                  public sealed class ErrorOrEndpointAttribute : global::System.Attribute
                                  {
                                      public ErrorOrEndpointAttribute(string httpMethod, string route)
                                      {
                                          HttpMethod = httpMethod;
                                          Route = route;
                                      }
                                      public string HttpMethod { get; }
                                      public string Route { get; }
                                  }

                                  [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = false)]
                                  public sealed class GetAttribute : global::System.Attribute
                                  {
                                      public GetAttribute(string route) => Route = route;
                                      public string Route { get; }
                                  }

                                  [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = false)]
                                  public sealed class PostAttribute : global::System.Attribute
                                  {
                                      public PostAttribute(string route) => Route = route;
                                      public string Route { get; }
                                  }

                                  [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = false)]
                                  public sealed class PutAttribute : global::System.Attribute
                                  {
                                      public PutAttribute(string route) => Route = route;
                                      public string Route { get; }
                                  }

                                  [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = false)]
                                  public sealed class DeleteAttribute : global::System.Attribute
                                  {
                                      public DeleteAttribute(string route) => Route = route;
                                      public string Route { get; }
                                  }

                                  [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = false)]
                                  public sealed class PatchAttribute : global::System.Attribute
                                  {
                                      public PatchAttribute(string route) => Route = route;
                                      public string Route { get; }
                                  }

                                  [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = true)]
                                  public sealed class ProducesErrorAttribute : global::System.Attribute
                                  {
                                      public ProducesErrorAttribute(int statusCode, string errorType)
                                      {
                                          StatusCode = statusCode;
                                          ErrorType = errorType;
                                      }
                                      public int StatusCode { get; }
                                      public string ErrorType { get; }
                                  }

                                  [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = false)]
                                  public sealed class AcceptedResponseAttribute : global::System.Attribute { }

                                  [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = true)]
                                  public sealed class ReturnsErrorAttribute : global::System.Attribute
                                  {
                                      public ReturnsErrorAttribute(global::ErrorOr.ErrorType errorType, string errorCode)
                                      {
                                          ErrorType = errorType;
                                          ErrorCode = errorCode;
                                      }
                                      public ReturnsErrorAttribute(int statusCode, string errorCode)
                                      {
                                          StatusCode = statusCode;
                                          ErrorCode = errorCode;
                                          ErrorType = null;
                                      }
                                      public global::ErrorOr.ErrorType? ErrorType { get; }
                                      public int? StatusCode { get; }
                                      public string ErrorCode { get; }
                                  }

                                  /// <summary>
                                  /// Marks a class as a route group for versioned API endpoints.
                                  /// All endpoints in the class will be mapped under the specified path prefix
                                  /// using the eShop-style NewVersionedApi() pattern when combined with [ApiVersion].
                                  /// </summary>
                                  [global::System.AttributeUsage(global::System.AttributeTargets.Class, AllowMultiple = false)]
                                  public sealed class RouteGroupAttribute : global::System.Attribute
                                  {
                                      public RouteGroupAttribute(string path) => Path = path;
                                      public string Path { get; }
                                      public string? ApiName { get; set; }
                                  }
                              }
                              """;

        // Use a different file name to avoid conflicts with OpenApiTransformerGenerator
        context.AddSource("ErrorOrEndpointAttributes.Mappings.g.cs", source);
    }

    private static bool ParseGenerateJsonContextOption(AnalyzerConfigOptionsProvider options, CancellationToken _)
    {
        options.GlobalOptions.TryGetValue("build_property.ErrorOrGenerateJsonContext", out var value);
        return !string.Equals(value, "false", StringComparison.OrdinalIgnoreCase);
    }

    private static bool ParsePublishAotOption(AnalyzerConfigOptionsProvider options, CancellationToken _)
    {
        options.GlobalOptions.TryGetValue("build_property.PublishAot", out var value);
        return string.Equals(value, "true", StringComparison.OrdinalIgnoreCase);
    }

    private static IncrementalValueProvider<EquatableArray<EndpointDescriptor>> CombineHttpMethodProviders(
        IncrementalGeneratorInitializationContext context,
        IncrementalValueProvider<ErrorOrContext> errorOrContextProvider)
    {
        var getProvider = CreateEndpointProvider(context, WellKnownTypes.GetAttribute, errorOrContextProvider);
        var postProvider = CreateEndpointProvider(context, WellKnownTypes.PostAttribute, errorOrContextProvider);
        var putProvider = CreateEndpointProvider(context, WellKnownTypes.PutAttribute, errorOrContextProvider);
        var deleteProvider = CreateEndpointProvider(context, WellKnownTypes.DeleteAttribute, errorOrContextProvider);
        var patchProvider = CreateEndpointProvider(context, WellKnownTypes.PatchAttribute, errorOrContextProvider);
        var baseProvider =
            CreateEndpointProvider(context, WellKnownTypes.ErrorOrEndpointAttribute, errorOrContextProvider);

        return IncrementalProviderExtensions.CombineAll(
            getProvider, postProvider, putProvider,
            deleteProvider, patchProvider, baseProvider);
    }

    private static void EmitMappingsAndRunAnalysis(
        SourceProductionContext spc,
        in EmitContext ctx)
    {
        var endpointArray = Helpers.AsArrayOrEmpty(ctx.Endpoints);
        var jsonContextArray = Helpers.AsArrayOrEmpty(ctx.JsonContexts);

        ReportDuplicateRoutes(spc, endpointArray);
        ReportVersioningInconsistencies(spc, endpointArray);

        if (!endpointArray.IsDefaultOrEmpty)
        {
            EmitEndpoints(spc, endpointArray, jsonContextArray, ctx.MaxResultsUnionArity, ctx.GenerateJsonContext,
                ctx.HasValidationResolverSupport);
            AnalyzeJsonContextCoverage(spc, endpointArray, jsonContextArray, ctx.PublishAot);
            AnalyzeUnionTypeArity(spc, endpointArray, ctx.MaxResultsUnionArity);
        }
    }

    private static void ReportDuplicateRoutes(SourceProductionContext spc, ImmutableArray<EndpointDescriptor> endpoints)
    {
        foreach (var diagnostic in RouteValidator.DetectDuplicateRoutes(endpoints))
            spc.ReportDiagnostic(diagnostic);
    }

    private static void ReportVersioningInconsistencies(SourceProductionContext spc,
        ImmutableArray<EndpointDescriptor> endpoints)
    {
        foreach (var diagnostic in ApiVersioningValidator.DetectMissingVersioning(endpoints))
            spc.ReportDiagnostic(diagnostic);
    }

    private static IncrementalValuesProvider<EndpointDescriptor> CreateEndpointProvider(
        IncrementalGeneratorInitializationContext context,
        string attributeName,
        IncrementalValueProvider<ErrorOrContext> errorOrContextProvider)
    {
        return context.SyntaxProvider
            .ForAttributeWithMetadataName(
                attributeName,
                static (node, _) => node is MethodDeclarationSyntax,
                static (ctx, _) => ctx)
            .Combine(errorOrContextProvider)
            .SelectFlow(static (pair, ct) =>
            {
                var (ctx, errorOrContext) = pair;
                return AnalyzeEndpointFlow(ctx, errorOrContext, ct);
            })
            .WithTrackingName(TrackingNames.EndpointBindingFlow(attributeName))
            .ReportAndContinue(context)
            .SelectMany(static (endpoints, _) => endpoints.AsImmutableArray());
    }

    private static DiagnosticFlow<EquatableArray<EndpointDescriptor>> AnalyzeEndpointFlow(
        GeneratorAttributeSyntaxContext ctx,
        ErrorOrContext errorOrContext,
        CancellationToken ct)
    {
        if (ctx.TargetSymbol is not IMethodSymbol method || ctx.Attributes.IsDefaultOrEmpty)
        {
            return Helpers.EmptyEndpointFlow();
        }

        var location = method.Locations.FirstOrDefault() ?? Location.None;

        // 1. Validate shape using SemanticGuard + DiagnosticFlow (The Railway Pattern)
        var methodAnalysisFlow = SemanticGuard.For(method)
            .MustBeStatic(DiagnosticInfo.Create(Descriptors.NonStaticHandler, location, method.Name))
            .ToFlow()
            .Then(m =>
            {
                var returnInfo = ExtractErrorOrReturnType(m.ReturnType, errorOrContext);

                // EOE015: Anonymous return type
                if (returnInfo.IsAnonymousType)
                {
                    return DiagnosticFlow.Fail<(IMethodSymbol, ErrorOrReturnTypeInfo)>(
                        DiagnosticInfo.Create(Descriptors.AnonymousReturnTypeNotSupported, location, m.Name));
                }

                // EOE018: Inaccessible return type
                if (returnInfo.IsInaccessibleType)
                {
                    return DiagnosticFlow.Fail<(IMethodSymbol, ErrorOrReturnTypeInfo)>(
                        DiagnosticInfo.Create(Descriptors.InaccessibleTypeNotSupported, location,
                            returnInfo.InaccessibleTypeName ?? "unknown",
                            m.Name,
                            returnInfo.InaccessibleTypeAccessibility ?? "private"));
                }

                // EOE019: Type parameter in return type
                if (returnInfo.IsTypeParameter)
                {
                    return DiagnosticFlow.Fail<(IMethodSymbol, ErrorOrReturnTypeInfo)>(
                        DiagnosticInfo.Create(Descriptors.TypeParameterNotSupported, location,
                            m.Name,
                            returnInfo.TypeParameterName ?? "T"));
                }

                return returnInfo.SuccessTypeFqn is not null
                    ? DiagnosticFlow.Ok((m, returnInfo))
                    : DiagnosticFlow.Fail<(IMethodSymbol, ErrorOrReturnTypeInfo)>(
                        DiagnosticInfo.Create(Descriptors.InvalidReturnType, location, m.Name));
            })
            .Then(pair =>
            {
                var (m, returnInfo) = pair;
                var builder = ImmutableArray.CreateBuilder<DiagnosticInfo>();

                // EOE033: Validate PascalCase naming convention
                if (NamingValidator.ValidatePascalCase(m.Name, location) is { } namingDiagnostic)
                {
                    builder.Add(namingDiagnostic);
                }

                // Extract method-level attributes first (needed for interface call detection)
                var producesErrors = ExtractProducesErrorAttributes(m, errorOrContext);
                var isAcceptedResponse = HasAcceptedResponseAttribute(m, errorOrContext);
                var hasExplicitProducesError = !producesErrors.IsDefaultOrEmpty;

                // Extract middleware attributes (BCL: Authorize, RateLimiting, OutputCache, CORS)
                var middleware = ExtractMiddlewareAttributes(m, errorOrContext);

                // Infer errors once per method (now with interface call detection)
                var (inferredErrors, customErrors) =
                    InferErrorTypesFromMethod(ctx, m, errorOrContext, builder, hasExplicitProducesError);

                var analysis = new MethodAnalysis(
                    m,
                    returnInfo,
                    inferredErrors,
                    customErrors,
                    producesErrors,
                    isAcceptedResponse,
                    middleware);

                var flow = DiagnosticFlow.Ok(analysis);
                foreach (var diag in builder)
                    flow = flow.Warn(diag);

                return flow;
            });

        // 2. Map method analysis to individual attribute descriptors
        var flows = ImmutableArray.CreateBuilder<DiagnosticFlow<EndpointDescriptor>>(ctx.Attributes.Length);
        foreach (var attr in ctx.Attributes)
        {
            if (attr is null)
            {
                continue;
            }

            var flow = methodAnalysisFlow.Then(analysis =>
                ProcessAttributeFlow(in analysis, attr, errorOrContext, ct));
            flows.Add(flow);
        }

        if (flows.Count is 0)
        {
            return Helpers.EmptyEndpointFlow();
        }

        return DiagnosticFlow.Collect(flows.ToImmutable())
            .Select(static endpoints => new EquatableArray<EndpointDescriptor>(endpoints));
    }

    private static DiagnosticFlow<EndpointDescriptor> ProcessAttributeFlow(
        in MethodAnalysis analysis,
        AttributeData attr,
        ErrorOrContext errorOrContext,
        CancellationToken ct)
    {
        ct.ThrowIfCancellationRequested();

        if (attr.AttributeClass is not { } attrClass)
        {
            return DiagnosticFlow.Fail<EndpointDescriptor>();
        }

        var attrName = attrClass.Name;

        var (verb, pattern, customMethod) = ExtractHttpMethodAndPattern(attr, attrName);
        if (verb is null)
        {
            return DiagnosticFlow.Fail<EndpointDescriptor>();
        }

        // Guard: SuccessTypeFqn validated in upstream .Then() but compiler doesn't know
        if (analysis.ReturnInfo.SuccessTypeFqn is not { } successTypeFqn)
        {
            return DiagnosticFlow.Fail<EndpointDescriptor>();
        }

        var builder = ImmutableArray.CreateBuilder<DiagnosticInfo>();

        // Extract route parameters as HashSet for binding
        var routeParamInfos = RouteValidator.ExtractRouteParameters(pattern);
        var routeParamNames = routeParamInfos
            .Select(static r => r.Name)
            .ToImmutableHashSet(StringComparer.OrdinalIgnoreCase);

        var bindingFlow = RouteBindingHelper.BindRouteParameters(
            analysis.Method,
            routeParamNames,
            errorOrContext,
            verb.Value);
        if (!bindingFlow.IsSuccess)
        {
            return DiagnosticFlow.Fail<EndpointDescriptor>(bindingFlow.Diagnostics);
        }

        builder.AddRange(bindingFlow.Diagnostics.AsImmutableArray());
        var bindingAnalysis = bindingFlow.ValueOrDefault();

        // Validate route pattern
        builder.AddRange(RouteValidator.ValidatePattern(pattern, analysis.Method));

        // Extract method parameter info for route binding validation
        var methodParams = bindingAnalysis.RouteParameters.AsImmutableArray();

        // Validate route parameters are bound
        builder.AddRange(RouteValidator.ValidateParameterBindings(
            pattern, routeParamInfos, methodParams, analysis.Method));

        // Validate route constraint types
        builder.AddRange(RouteValidator.ValidateConstraintTypes(
            routeParamInfos, methodParams, analysis.Method));

        // Extract API versioning attributes
        var versioning = ExtractVersioningAttributes(analysis.Method, errorOrContext);

        // Validate API versioning configuration (EOE027-EOE031)
        var rawClassVersions = ExtractRawClassVersionStrings(analysis.Method, errorOrContext);
        var rawMethodVersions = ExtractRawMethodVersionStrings(analysis.Method, errorOrContext);
        var location = analysis.Method.Locations.FirstOrDefault() ?? Location.None;
        builder.AddRange(ApiVersioningValidator.Validate(
            analysis.Method.Name,
            versioning,
            rawClassVersions,
            rawMethodVersions,
            location,
            errorOrContext.HasApiVersioningSupport,
            analysis.Method));

        // Extract route group configuration for eShop-style grouping
        var routeGroup = ExtractRouteGroupInfo(analysis.Method, errorOrContext);

        // Extract custom endpoint metadata
        var metadata = ExtractMetadata(analysis.Method);

        var descriptor = new EndpointDescriptor(
            verb.Value,
            pattern,
            successTypeFqn,
            analysis.ReturnInfo.Kind,
            analysis.ReturnInfo.IsAsync,
            analysis.Method.ContainingType?.GetFullyQualifiedName() ?? "Unknown",
            analysis.Method.Name,
            bindingAnalysis.Parameters,
            analysis.InferredErrorTypeNames,
            analysis.InferredCustomErrors,
            analysis.ProducesErrors,
            analysis.ReturnInfo.IsSse,
            analysis.ReturnInfo.SseItemTypeFqn,
            analysis.IsAcceptedResponse,
            analysis.ReturnInfo.IdPropertyName,
            analysis.Middleware,
            versioning,
            routeGroup,
            metadata,
            customMethod);

        var flow = DiagnosticFlow.Ok(descriptor);
        foreach (var diag in builder)
            flow = flow.Warn(diag);

        return flow;
    }

    private static (HttpVerb? Verb, string Pattern, string? CustomMethod) ExtractHttpMethodAndPattern(
        AttributeData attr,
        string attrName)
    {
        var verb = HttpVerbExtensions.TryParseFromAttribute(attrName, attr.ConstructorArguments);

        // For ErrorOrEndpointAttribute with unrecognized methods (e.g., "CONNECT", "PROPFIND"),
        // store the raw method string so we can emit MapMethods with it
        string? customMethod = null;
        var isErrorOrEndpoint = attrName.Contains("ErrorOrEndpoint");
        if (verb is null && isErrorOrEndpoint &&
            attr.ConstructorArguments is [{ Value: string rawMethod }, ..])
        {
            customMethod = rawMethod.ToUpperInvariant();
            verb = HttpVerb.Get; // placeholder â€” MapMethods is used when CustomHttpMethod is set
        }

        if (verb is null)
        {
            return (null, "/", null);
        }

        // Extract pattern - index differs for ErrorOrEndpoint (has httpMethod arg first)
        var patternIndex = isErrorOrEndpoint ? 1 : 0;
        var pattern = attr.ConstructorArguments.Length > patternIndex &&
                      attr.ConstructorArguments[patternIndex].Value is string p
            ? p
            : "/";

        return (verb, pattern, customMethod);
    }

    /// <summary>
    ///     Incremental pipeline tracking names for caching diagnostics.
    /// </summary>
    private static class TrackingNames
    {
        public const string ResultsUnionMaxArity = "ResultsUnionMaxArity";
        public const string ErrorOrContext = "ErrorOrContext";

        public static string EndpointBindingFlow(string attributeName)
        {
            return attributeName switch
            {
                WellKnownTypes.GetAttribute => "EndpointBindingFlow.Get",
                WellKnownTypes.PostAttribute => "EndpointBindingFlow.Post",
                WellKnownTypes.PutAttribute => "EndpointBindingFlow.Put",
                WellKnownTypes.DeleteAttribute => "EndpointBindingFlow.Delete",
                WellKnownTypes.PatchAttribute => "EndpointBindingFlow.Patch",
                WellKnownTypes.ErrorOrEndpointAttribute => "EndpointBindingFlow.Custom",
                _ => "EndpointBindingFlow.Unknown"
            };
        }
    }

    /// <summary>
    ///     Flattened context for the combined Roslyn pipeline inputs to <see cref="EmitMappingsAndRunAnalysis" />.
    /// </summary>
    private readonly record struct EmitContext(
        EquatableArray<EndpointDescriptor> Endpoints,
        EquatableArray<JsonContextInfo> JsonContexts,
        bool GenerateJsonContext,
        bool PublishAot,
        int MaxResultsUnionArity,
        bool HasValidationResolverSupport);

    /// <summary>
    ///     Small focused helpers for common pipeline operations.
    /// </summary>
    private static class Helpers
    {
        /// <summary>
        ///     Converts EquatableArray to ImmutableArray, returning Empty if default/empty.
        /// </summary>
        public static ImmutableArray<T> AsArrayOrEmpty<T>(EquatableArray<T> array) where T : IEquatable<T>
        {
            return array.IsDefaultOrEmpty ? ImmutableArray<T>.Empty : array.AsImmutableArray();
        }

        /// <summary>
        ///     Creates an empty endpoint descriptor flow for early-exit scenarios.
        /// </summary>
        public static DiagnosticFlow<EquatableArray<EndpointDescriptor>> EmptyEndpointFlow()
        {
            return DiagnosticFlow.Ok(new EquatableArray<EndpointDescriptor>(ImmutableArray<EndpointDescriptor>.Empty));
        }
    }
}
