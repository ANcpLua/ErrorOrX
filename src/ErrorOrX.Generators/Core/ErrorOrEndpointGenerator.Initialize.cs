using System.Collections.Immutable;
using ANcpLua.Roslyn.Utilities;
using ANcpLua.Roslyn.Utilities.Models;
using ErrorOr.Analyzers;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Diagnostics;

namespace ErrorOr.Generators;

/// <summary>
///     Generator entry point for ErrorOr endpoint mappings.
///     Generates MapErrorOrEndpoints() and AddErrorOrEndpoints() fluent configuration extension methods.
/// </summary>
[Generator(LanguageNames.CSharp)]
public sealed partial class ErrorOrEndpointGenerator : IIncrementalGenerator
{
    /// <summary>
    ///     Incremental pipeline tracking names for caching diagnostics.
    /// </summary>
    private static class TrackingNames
    {
        public const string ResultsUnionMaxArity = "ResultsUnionMaxArity";

        public static string EndpointBindingFlow(string attributeName) => attributeName switch
        {
            WellKnownTypes.GetAttribute => "EndpointBindingFlow.Get",
            WellKnownTypes.PostAttribute => "EndpointBindingFlow.Post",
            WellKnownTypes.PutAttribute => "EndpointBindingFlow.Put",
            WellKnownTypes.DeleteAttribute => "EndpointBindingFlow.Delete",
            WellKnownTypes.PatchAttribute => "EndpointBindingFlow.Patch",
            WellKnownTypes.ErrorOrEndpointAttribute => "EndpointBindingFlow.Custom",
            _ => "EndpointBindingFlow.Unknown"
        };
    }

    /// <summary>
    ///     Small focused helpers for common pipeline operations.
    /// </summary>
    private static class Helpers
    {
        /// <summary>
        ///     Converts EquatableArray to ImmutableArray, returning Empty if default/empty.
        /// </summary>
        public static ImmutableArray<T> AsArrayOrEmpty<T>(EquatableArray<T> array) where T : IEquatable<T> =>
            array.IsDefaultOrEmpty ? ImmutableArray<T>.Empty : array.AsImmutableArray();

        /// <summary>
        ///     Maps attribute name to HTTP method, returning null for unrecognized attributes.
        /// </summary>
        public static string? TryGetHttpMethod(string attrName, ImmutableArray<TypedConstant> args) => attrName switch
        {
            "GetAttribute" or "Get" => WellKnownTypes.HttpMethod.Get,
            "PostAttribute" or "Post" => WellKnownTypes.HttpMethod.Post,
            "PutAttribute" or "Put" => WellKnownTypes.HttpMethod.Put,
            "DeleteAttribute" or "Delete" => WellKnownTypes.HttpMethod.Delete,
            "PatchAttribute" or "Patch" => WellKnownTypes.HttpMethod.Patch,
            "ErrorOrEndpointAttribute" or "ErrorOrEndpoint" when args is [{ Value: string m }, ..] => m.ToUpperInvariant(),
            _ => null
        };

        /// <summary>
        ///     Creates an empty endpoint descriptor flow for early-exit scenarios.
        /// </summary>
        public static DiagnosticFlow<EquatableArray<EndpointDescriptor>> EmptyEndpointFlow() =>
            DiagnosticFlow.Ok(new EquatableArray<EndpointDescriptor>(ImmutableArray<EndpointDescriptor>.Empty));
    }

    /// <summary>
    ///     Emits the marker attributes that users apply to their endpoint handler methods.
    ///     This must be registered by this generator (not just OpenApiTransformerGenerator)
    ///     because ForAttributeWithMetadataName only sees types from PostInitializationOutput
    ///     within the same generator.
    /// </summary>
    private static void EmitAttributes(IncrementalGeneratorPostInitializationContext context)
    {
        const string source = """
                              // <auto-generated/>
                              #nullable enable

                              namespace ErrorOr
                              {
                                  /// <summary>
                                  /// Marks a static method as an ErrorOr endpoint with explicit HTTP method and route.
                                  /// Prefer using [Get], [Post], [Put], [Delete], or [Patch] for standard HTTP methods.
                                  /// </summary>
                                  [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = false)]
                                  public sealed class ErrorOrEndpointAttribute : global::System.Attribute
                                  {
                                      public ErrorOrEndpointAttribute(string httpMethod, string route)
                                      {
                                          HttpMethod = httpMethod;
                                          Route = route;
                                      }
                                      public string HttpMethod { get; }
                                      public string Route { get; }
                                  }

                                  [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = false)]
                                  public sealed class GetAttribute : global::System.Attribute
                                  {
                                      public GetAttribute(string route) => Route = route;
                                      public string Route { get; }
                                  }

                                  [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = false)]
                                  public sealed class PostAttribute : global::System.Attribute
                                  {
                                      public PostAttribute(string route) => Route = route;
                                      public string Route { get; }
                                  }

                                  [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = false)]
                                  public sealed class PutAttribute : global::System.Attribute
                                  {
                                      public PutAttribute(string route) => Route = route;
                                      public string Route { get; }
                                  }

                                  [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = false)]
                                  public sealed class DeleteAttribute : global::System.Attribute
                                  {
                                      public DeleteAttribute(string route) => Route = route;
                                      public string Route { get; }
                                  }

                                  [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = false)]
                                  public sealed class PatchAttribute : global::System.Attribute
                                  {
                                      public PatchAttribute(string route) => Route = route;
                                      public string Route { get; }
                                  }

                                  [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = true)]
                                  public sealed class ProducesErrorAttribute : global::System.Attribute
                                  {
                                      public ProducesErrorAttribute(int statusCode, string errorType)
                                      {
                                          StatusCode = statusCode;
                                          ErrorType = errorType;
                                      }
                                      public int StatusCode { get; }
                                      public string ErrorType { get; }
                                  }

                                  [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = false)]
                                  public sealed class AcceptedResponseAttribute : global::System.Attribute { }

                                  [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = true)]
                                  public sealed class ReturnsErrorAttribute : global::System.Attribute
                                  {
                                      public ReturnsErrorAttribute(global::ErrorOr.ErrorType errorType, string errorCode)
                                      {
                                          ErrorType = errorType;
                                          ErrorCode = errorCode;
                                      }
                                      public ReturnsErrorAttribute(int statusCode, string errorCode)
                                      {
                                          StatusCode = statusCode;
                                          ErrorCode = errorCode;
                                          ErrorType = null;
                                      }
                                      public global::ErrorOr.ErrorType? ErrorType { get; }
                                      public int? StatusCode { get; }
                                      public string ErrorCode { get; }
                                  }
                              }
                              """;

        // Use a different file name to avoid conflicts with OpenApiTransformerGenerator
        context.AddSource("ErrorOrEndpointAttributes.Mappings.g.cs", source);
    }
    // EPS06: Roslyn's readonly struct API causes unavoidable defensive copies.
#pragma warning disable EPS06

    /// <inheritdoc />
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(EmitAttributes);

        var endpoints = CombineHttpMethodProviders(context);
        var jsonContexts = JsonContextProvider.Create(context).CollectAsEquatableArray();
        var generateJsonContextOption = context.AnalyzerConfigOptionsProvider
            .Select(ParseGenerateJsonContextOption);
        var referenceArities = context.MetadataReferencesProvider
            .Select(static (reference, _) => ResultsUnionTypeBuilder.GetResultsUnionArity(reference))
            .CollectAsEquatableArray();
        var maxResultsUnionArity = referenceArities
            .Select(static (arities, _) => ResultsUnionTypeBuilder.DetectMaxArity(arities.AsImmutableArray()))
            .WithTrackingName(TrackingNames.ResultsUnionMaxArity);

        context.RegisterSourceOutput(
            endpoints.Combine(jsonContexts).Combine(generateJsonContextOption).Combine(maxResultsUnionArity),
            EmitMappingsAndRunAnalysis);
    }

    private static bool ParseGenerateJsonContextOption(AnalyzerConfigOptionsProvider options, CancellationToken _)
    {
        options.GlobalOptions.TryGetValue("build_property.ErrorOrGenerateJsonContext", out var value);
        return !string.Equals(value, "false", StringComparison.OrdinalIgnoreCase);
    }

    private static IncrementalValueProvider<EquatableArray<EndpointDescriptor>> CombineHttpMethodProviders(
        IncrementalGeneratorInitializationContext context)
    {
        var getProvider = CreateEndpointProvider(context, WellKnownTypes.GetAttribute);
        var postProvider = CreateEndpointProvider(context, WellKnownTypes.PostAttribute);
        var putProvider = CreateEndpointProvider(context, WellKnownTypes.PutAttribute);
        var deleteProvider = CreateEndpointProvider(context, WellKnownTypes.DeleteAttribute);
        var patchProvider = CreateEndpointProvider(context, WellKnownTypes.PatchAttribute);
        var baseProvider = CreateEndpointProvider(context, WellKnownTypes.ErrorOrEndpointAttribute);

        return IncrementalProviderExtensions.CombineSix(
            getProvider, postProvider, putProvider,
            deleteProvider, patchProvider, baseProvider);
    }


    private static void EmitMappingsAndRunAnalysis(
        SourceProductionContext spc,
        (((EquatableArray<EndpointDescriptor> Endpoints, EquatableArray<JsonContextInfo> JsonContexts),
            bool GenerateJsonContext),
            int MaxResultsUnionArity) data)
    {
        var (((endpoints, jsonContexts), generateJsonContext), maxResultsUnionArity) = data;
        var endpointArray = Helpers.AsArrayOrEmpty(endpoints);
        var jsonContextArray = Helpers.AsArrayOrEmpty(jsonContexts);

        ReportDuplicateRoutes(spc, endpointArray);

        if (!endpointArray.IsDefaultOrEmpty)
        {
            EmitEndpoints(spc, endpointArray, jsonContextArray, maxResultsUnionArity, generateJsonContext);
            AnalyzeJsonContextCoverage(spc, endpointArray, jsonContextArray);
            AnalyzeUnionTypeArity(spc, endpointArray, maxResultsUnionArity);
        }
    }

    private static void ReportDuplicateRoutes(SourceProductionContext spc, ImmutableArray<EndpointDescriptor> endpoints)
    {
        foreach (var diagnostic in RouteValidator.DetectDuplicateRoutes(endpoints))
            spc.ReportDiagnostic(diagnostic);
    }

    private static IncrementalValuesProvider<EndpointDescriptor> CreateEndpointProvider(
        IncrementalGeneratorInitializationContext context,
        string attributeName)
    {
        return context.SyntaxProvider
            .ForAttributeWithMetadataName(
                attributeName,
                static (node, _) => node is MethodDeclarationSyntax,
                static (ctx, _) => ctx)
            .SelectFlow(static (ctx, ct) =>
            {
                // Lazy creation avoids caching ITypeSymbol (breaks incremental)
                var errorOrContext = new ErrorOrContext(ctx.SemanticModel.Compilation);
                return AnalyzeEndpointFlow(ctx, errorOrContext, ct);
            })
            .WithTrackingName(TrackingNames.EndpointBindingFlow(attributeName))
            .ReportAndContinue(context)
            .SelectMany(static (endpoints, _) => endpoints.AsImmutableArray());
    }

    private static DiagnosticFlow<EquatableArray<EndpointDescriptor>> AnalyzeEndpointFlow(
        GeneratorAttributeSyntaxContext ctx,
        ErrorOrContext errorOrContext,
        CancellationToken ct)
    {
        if (ctx.TargetSymbol is not IMethodSymbol method || ctx.Attributes.IsDefaultOrEmpty)
            return Helpers.EmptyEndpointFlow();

        var location = method.Locations.FirstOrDefault() ?? Location.None;

        // 1. Validate shape using SemanticGuard + DiagnosticFlow (The Railway Pattern)
        var methodAnalysisFlow = SemanticGuard.For(method)
            .MustBeStatic(DiagnosticInfo.Create(Descriptors.NonStaticHandler, location, method.Name))
            .ToFlow()
            .Then(m =>
            {
                var returnInfo = ExtractErrorOrReturnType(m.ReturnType, errorOrContext);
                return returnInfo.SuccessTypeFqn is not null
                    ? DiagnosticFlow.Ok((m, returnInfo))
                    : DiagnosticFlow.Fail<(IMethodSymbol, ErrorOrReturnTypeInfo)>(
                        DiagnosticInfo.Create(Descriptors.InvalidReturnType, location, m.Name));
            })
            .Then(pair =>
            {
                var (m, returnInfo) = pair;
                var builder = ImmutableArray.CreateBuilder<DiagnosticInfo>();

                // Extract method-level attributes first (needed for interface call detection)
                var producesErrors = ExtractProducesErrorAttributes(m, errorOrContext);
                var isAcceptedResponse = HasAcceptedResponseAttribute(m, errorOrContext);
                var hasExplicitProducesError = !producesErrors.IsDefaultOrEmpty;

                // Extract middleware attributes (BCL: Authorize, RateLimiting, OutputCache, CORS)
                var middleware = ExtractMiddlewareAttributes(m, errorOrContext);

                // Infer errors once per method (now with interface call detection)
                var (inferredErrors, customErrors) =
                    InferErrorTypesFromMethod(ctx, m, errorOrContext, builder, hasExplicitProducesError);

                var analysis = new MethodAnalysis(
                    m,
                    returnInfo,
                    inferredErrors,
                    customErrors,
                    producesErrors,
                    isAcceptedResponse,
                    middleware);

                var flow = DiagnosticFlow.Ok(analysis);
                foreach (var diag in builder)
                    flow = flow.Warn(diag);

                return flow;
            });

        // 2. Map method analysis to individual attribute descriptors
        var flows = ImmutableArray.CreateBuilder<DiagnosticFlow<EndpointDescriptor>>(ctx.Attributes.Length);
        foreach (var attr in ctx.Attributes)
        {
            if (attr is null) continue;
            var flow = methodAnalysisFlow.Then(analysis =>
                ProcessAttributeFlow(analysis, attr, errorOrContext, ct));
            flows.Add(flow);
        }

        if (flows.Count is 0)
            return Helpers.EmptyEndpointFlow();

        return DiagnosticFlow.Collect(flows.ToImmutable())
            .Select(static endpoints => new EquatableArray<EndpointDescriptor>(endpoints));
    }

    private static DiagnosticFlow<EndpointDescriptor> ProcessAttributeFlow(
        MethodAnalysis analysis,
        AttributeData attr,
        ErrorOrContext errorOrContext,
        CancellationToken ct)
    {
        ct.ThrowIfCancellationRequested();

        if (attr.AttributeClass is not { } attrClass) return DiagnosticFlow.Fail<EndpointDescriptor>();
        var attrName = attrClass.Name;

        var (httpMethod, pattern) = ExtractHttpMethodAndPattern(attr, attrName);
        if (httpMethod is null) return DiagnosticFlow.Fail<EndpointDescriptor>();

        // Guard: SuccessTypeFqn validated in upstream .Then() but compiler doesn't know
        if (analysis.ReturnInfo.SuccessTypeFqn is not { } successTypeFqn)
            return DiagnosticFlow.Fail<EndpointDescriptor>();

        var builder = ImmutableArray.CreateBuilder<DiagnosticInfo>();

        // Extract route parameters as HashSet for binding
        var routeParamInfos = RouteValidator.ExtractRouteParameters(pattern);
        var routeParamNames = routeParamInfos
            .Select(static r => r.Name)
            .ToImmutableHashSet(StringComparer.OrdinalIgnoreCase);

        var bindingFlow = RouteBindingHelper.BindRouteParameters(
            analysis.Method,
            routeParamNames,
            errorOrContext,
            httpMethod);
        if (!bindingFlow.IsSuccess)
            return DiagnosticFlow.Fail<EndpointDescriptor>(bindingFlow.Diagnostics);

        builder.AddRange(bindingFlow.Diagnostics.AsImmutableArray());
        var bindingAnalysis = bindingFlow.ValueOrDefault();

        // Validate route pattern
        builder.AddRange(RouteValidator.ValidatePattern(pattern, analysis.Method));

        // Extract method parameter info for route binding validation
        var methodParams = bindingAnalysis.RouteParameters.AsImmutableArray();

        // Validate route parameters are bound
        builder.AddRange(RouteValidator.ValidateParameterBindings(
            pattern, routeParamInfos, methodParams, analysis.Method));

        // Validate route constraint types
        builder.AddRange(RouteValidator.ValidateConstraintTypes(
            routeParamInfos, methodParams, analysis.Method));

        var descriptor = new EndpointDescriptor(
            httpMethod,
            pattern,
            successTypeFqn,
            analysis.ReturnInfo.Kind,
            analysis.ReturnInfo.IsAsync,
            analysis.Method.ContainingType?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ?? "Unknown",
            analysis.Method.Name,
            bindingAnalysis.Parameters,
            analysis.InferredErrorTypeNames,
            analysis.InferredCustomErrors,
            analysis.ProducesErrors,
            analysis.ReturnInfo.IsSse,
            analysis.ReturnInfo.SseItemTypeFqn,
            analysis.IsAcceptedResponse,
            analysis.ReturnInfo.IdPropertyName,
            analysis.Middleware);

        var flow = DiagnosticFlow.Ok(descriptor);
        foreach (var diag in builder)
            flow = flow.Warn(diag);

        return flow;
    }

    private static (string? HttpMethod, string Pattern) ExtractHttpMethodAndPattern(
        AttributeData attr,
        string attrName)
    {
        var httpMethod = Helpers.TryGetHttpMethod(attrName, attr.ConstructorArguments);
        if (httpMethod is null)
            return (null, "/");

        // Extract pattern - index differs for ErrorOrEndpoint (has httpMethod arg first)
        var patternIndex = attrName.Contains("ErrorOrEndpoint") ? 1 : 0;
        var pattern = attr.ConstructorArguments.Length > patternIndex &&
                      attr.ConstructorArguments[patternIndex].Value is string p
            ? p
            : "/";

        return (httpMethod, pattern);
    }

#pragma warning restore EPS06
}
