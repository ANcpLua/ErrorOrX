using System.Collections.Immutable;
using ANcpLua.Roslyn.Utilities;
using ANcpLua.Roslyn.Utilities.Models;
using ErrorOr.Analyzers;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Diagnostics;

namespace ErrorOr.Generators;

/// <summary>
///     Generator entry point for ErrorOr endpoint mappings.
///     Generates MapErrorOrEndpoints() and AddErrorOrEndpointJson() extension methods.
/// </summary>
[Generator(LanguageNames.CSharp)]
public sealed partial class ErrorOrEndpointGenerator : IIncrementalGenerator
{
    /// <summary>
    ///     Emits the marker attributes that users apply to their endpoint handler methods.
    ///     This must be registered by this generator (not just OpenApiTransformerGenerator)
    ///     because ForAttributeWithMetadataName only sees types from PostInitializationOutput
    ///     within the same generator.
    /// </summary>
    private static void EmitAttributes(IncrementalGeneratorPostInitializationContext context)
    {
        const string source = """
                              // <auto-generated/>
                              #nullable enable

                              namespace ErrorOr
                              {
                                  /// <summary>
                                  /// Marks a static method as an ErrorOr endpoint with explicit HTTP method and route.
                                  /// Prefer using [Get], [Post], [Put], [Delete], or [Patch] for standard HTTP methods.
                                  /// </summary>
                                  [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = false)]
                                  public sealed class ErrorOrEndpointAttribute : global::System.Attribute
                                  {
                                      public ErrorOrEndpointAttribute(string httpMethod, string route)
                                      {
                                          HttpMethod = httpMethod;
                                          Route = route;
                                      }
                                      public string HttpMethod { get; }
                                      public string Route { get; }
                                  }

                                  [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = false)]
                                  public sealed class GetAttribute : global::System.Attribute
                                  {
                                      public GetAttribute(string route) => Route = route;
                                      public string Route { get; }
                                  }

                                  [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = false)]
                                  public sealed class PostAttribute : global::System.Attribute
                                  {
                                      public PostAttribute(string route) => Route = route;
                                      public string Route { get; }
                                  }

                                  [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = false)]
                                  public sealed class PutAttribute : global::System.Attribute
                                  {
                                      public PutAttribute(string route) => Route = route;
                                      public string Route { get; }
                                  }

                                  [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = false)]
                                  public sealed class DeleteAttribute : global::System.Attribute
                                  {
                                      public DeleteAttribute(string route) => Route = route;
                                      public string Route { get; }
                                  }

                                  [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = false)]
                                  public sealed class PatchAttribute : global::System.Attribute
                                  {
                                      public PatchAttribute(string route) => Route = route;
                                      public string Route { get; }
                                  }

                                  [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = true)]
                                  public sealed class ProducesErrorAttribute : global::System.Attribute
                                  {
                                      public ProducesErrorAttribute(int statusCode, string errorType)
                                      {
                                          StatusCode = statusCode;
                                          ErrorType = errorType;
                                      }
                                      public int StatusCode { get; }
                                      public string ErrorType { get; }
                                  }

                                  [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = false)]
                                  public sealed class AcceptedResponseAttribute : global::System.Attribute { }

                                  [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = true)]
                                  public sealed class ReturnsErrorAttribute : global::System.Attribute
                                  {
                                      public ReturnsErrorAttribute(global::ErrorOr.ErrorType errorType, string errorCode)
                                      {
                                          ErrorType = errorType;
                                          ErrorCode = errorCode;
                                      }
                                      public ReturnsErrorAttribute(int statusCode, string errorCode)
                                      {
                                          StatusCode = statusCode;
                                          ErrorCode = errorCode;
                                          ErrorType = null;
                                      }
                                      public global::ErrorOr.ErrorType? ErrorType { get; }
                                      public int? StatusCode { get; }
                                      public string ErrorCode { get; }
                                  }
                              }
                              """;

        // Use a different file name to avoid conflicts with OpenApiTransformerGenerator
        context.AddSource("ErrorOrEndpointAttributes.Mappings.g.cs", source);
    }
    // EPS06: Roslyn's readonly struct API causes unavoidable defensive copies.
#pragma warning disable EPS06

    /// <inheritdoc />
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(EmitAttributes);

        var legacyBindingOption = context.AnalyzerConfigOptionsProvider
            .Select(ParseLegacyBindingOption);

        var endpoints = CombineHttpMethodProviders(context, legacyBindingOption);
        var jsonContexts = JsonContextProvider.Create(context).CollectAsEquatableArray();
        var generateJsonContextOption = context.AnalyzerConfigOptionsProvider
            .Select(ParseGenerateJsonContextOption);

        context.RegisterSourceOutput(
            endpoints.Combine(jsonContexts).Combine(generateJsonContextOption),
            EmitMappingsAndRunAnalysis);
    }

    private static bool ParseLegacyBindingOption(AnalyzerConfigOptionsProvider options, CancellationToken _)
    {
        options.GlobalOptions.TryGetValue("build_property.ErrorOrLegacyParameterBinding", out var value);
        return string.Equals(value, "true", StringComparison.OrdinalIgnoreCase);
    }

    private static bool ParseGenerateJsonContextOption(AnalyzerConfigOptionsProvider options, CancellationToken _)
    {
        options.GlobalOptions.TryGetValue("build_property.ErrorOrGenerateJsonContext", out var value);
        return !string.Equals(value, "false", StringComparison.OrdinalIgnoreCase);
    }

    private static IncrementalValueProvider<EquatableArray<EndpointDescriptor>> CombineHttpMethodProviders(
        IncrementalGeneratorInitializationContext context,
        IncrementalValueProvider<bool> legacyBindingOption)
    {
        var getProvider = CreateEndpointProvider(context, legacyBindingOption, WellKnownTypes.GetAttribute);
        var postProvider = CreateEndpointProvider(context, legacyBindingOption, WellKnownTypes.PostAttribute);
        var putProvider = CreateEndpointProvider(context, legacyBindingOption, WellKnownTypes.PutAttribute);
        var deleteProvider = CreateEndpointProvider(context, legacyBindingOption, WellKnownTypes.DeleteAttribute);
        var patchProvider = CreateEndpointProvider(context, legacyBindingOption, WellKnownTypes.PatchAttribute);
        var baseProvider = CreateEndpointProvider(context, legacyBindingOption, WellKnownTypes.ErrorOrEndpointAttribute);

        return IncrementalProviderExtensions.CombineSix(
            getProvider, postProvider, putProvider,
            deleteProvider, patchProvider, baseProvider);
    }

    private static void EmitMappingsAndRunAnalysis(
        SourceProductionContext spc,
        ((EquatableArray<EndpointDescriptor> Endpoints, EquatableArray<JsonContextInfo> JsonContexts), bool GenerateJsonContext) data)
    {
        var ((endpoints, jsonContexts), generateJsonContext) = data;
        const int maxResultsUnionArity = 6;

        var endpointArray = endpoints.IsDefaultOrEmpty
            ? ImmutableArray<EndpointDescriptor>.Empty
            : endpoints.AsImmutableArray();
        var jsonContextArray = jsonContexts.IsDefaultOrEmpty
            ? ImmutableArray<JsonContextInfo>.Empty
            : jsonContexts.AsImmutableArray();

        ReportDuplicateRoutes(spc, endpointArray);

        if (!endpointArray.IsDefaultOrEmpty)
        {
            EmitEndpoints(spc, endpointArray, jsonContextArray, maxResultsUnionArity, generateJsonContext);
            AnalyzeJsonContextCoverage(spc, endpointArray, jsonContextArray);
            AnalyzeUnionTypeArity(spc, endpointArray, maxResultsUnionArity);
        }
    }

    private static void ReportDuplicateRoutes(SourceProductionContext spc, ImmutableArray<EndpointDescriptor> endpoints)
    {
        foreach (var diagnostic in RouteValidator.DetectDuplicateRoutes(endpoints))
            spc.ReportDiagnostic(diagnostic);
    }

    private static IncrementalValuesProvider<EndpointDescriptor> CreateEndpointProvider(
        IncrementalGeneratorInitializationContext context,
        IncrementalValueProvider<bool> legacyBindingProvider,
        string attributeName)
    {
        return context.SyntaxProvider
            .ForAttributeWithMetadataName(
                attributeName,
                static (node, _) => node is MethodDeclarationSyntax,
                static (ctx, _) => ctx)
            .Combine(legacyBindingProvider)
            .SelectMany(static (pair, ct) =>
            {
                // Lazy creation avoids caching ITypeSymbol (breaks incremental)
                var errorOrContext = new ErrorOrContext(pair.Left.SemanticModel.Compilation);
                return AnalyzeEndpointFlows(pair.Left, errorOrContext, pair.Right, ct);
            })
            .ReportAndContinue(context);
    }

    private static ImmutableArray<DiagnosticFlow<EndpointDescriptor>> AnalyzeEndpointFlows(
        GeneratorAttributeSyntaxContext ctx,
        ErrorOrContext errorOrContext,
        bool useLegacyBinding,
        CancellationToken ct)
    {
        if (ctx.TargetSymbol is not IMethodSymbol method || ctx.Attributes.IsDefaultOrEmpty)
            return ImmutableArray<DiagnosticFlow<EndpointDescriptor>>.Empty;

        var location = method.Locations.FirstOrDefault() ?? Location.None;

        // 1. Validate shape using SemanticGuard + DiagnosticFlow (The Railway Pattern)
        var methodAnalysisFlow = SemanticGuard.For(method)
            .MustBeStatic(DiagnosticInfo.Create(Descriptors.NonStaticHandler, location, method.Name))
            .ToFlow()
            .Then(m =>
            {
                var returnInfo = ExtractErrorOrReturnType(m.ReturnType, errorOrContext);
                return returnInfo.SuccessTypeFqn is not null
                    ? DiagnosticFlow.Ok((m, returnInfo))
                    : DiagnosticFlow.Fail<(IMethodSymbol, ErrorOrReturnTypeInfo)>(
                        DiagnosticInfo.Create(Descriptors.InvalidReturnType, location, m.Name));
            })
            .Then(pair =>
            {
                var (m, returnInfo) = pair;
                var builder = ImmutableArray.CreateBuilder<DiagnosticInfo>();

                // Extract method-level attributes first (needed for interface call detection)
                var producesErrors = ExtractProducesErrorAttributes(m, errorOrContext);
                var isAcceptedResponse = HasAcceptedResponseAttribute(m, errorOrContext);
                var hasExplicitProducesError = !producesErrors.IsDefaultOrEmpty;

                // Extract middleware attributes (BCL: Authorize, RateLimiting, OutputCache, CORS)
                var middleware = ExtractMiddlewareAttributes(m, errorOrContext);

                // Infer errors once per method (now with interface call detection)
                var (inferredErrors, customErrors) =
                    InferErrorTypesFromMethod(ctx, m, errorOrContext, builder, hasExplicitProducesError);

                var analysis = new MethodAnalysis(
                    m,
                    returnInfo,
                    inferredErrors,
                    customErrors,
                    producesErrors,
                    isAcceptedResponse,
                    middleware);

                var flow = DiagnosticFlow.Ok(analysis);
                foreach (var diag in builder)
                    flow = flow.Warn(diag);

                return flow;
            });

        // 2. Map method analysis to individual attribute descriptors
        var flows = ImmutableArray.CreateBuilder<DiagnosticFlow<EndpointDescriptor>>(ctx.Attributes.Length);
        foreach (var attr in ctx.Attributes)
        {
            if (attr is null) continue;
            var flow = methodAnalysisFlow.Then(analysis =>
                ProcessAttributeFlow(analysis, attr, errorOrContext, useLegacyBinding, ct));
            flows.Add(flow);
        }

        return flows.ToImmutable();
    }

    private static DiagnosticFlow<EndpointDescriptor> ProcessAttributeFlow(
        MethodAnalysis analysis,
        AttributeData attr,
        ErrorOrContext errorOrContext,
        bool useLegacyBinding,
        CancellationToken ct)
    {
        ct.ThrowIfCancellationRequested();

        var attrClass = attr.AttributeClass;
        if (attrClass is null) return DiagnosticFlow.Fail<EndpointDescriptor>();
        var attrName = attrClass.Name;

        var (httpMethod, pattern) = ExtractHttpMethodAndPattern(attr, attrName);
        if (httpMethod is null) return DiagnosticFlow.Fail<EndpointDescriptor>();

        // Guard: SuccessTypeFqn validated in upstream .Then() but compiler doesn't know
        if (analysis.ReturnInfo.SuccessTypeFqn is not { } successTypeFqn)
            return DiagnosticFlow.Fail<EndpointDescriptor>();

        var builder = ImmutableArray.CreateBuilder<DiagnosticInfo>();

        // Extract route parameters as HashSet for binding
        var routeParamInfos = RouteValidator.ExtractRouteParameters(pattern);
        var routeParamNames = routeParamInfos
            .Select(static r => r.Name)
            .ToImmutableHashSet(StringComparer.OrdinalIgnoreCase);

        // Bind parameters
        var bindingDiagnostics = ImmutableArray.CreateBuilder<DiagnosticInfo>();
        var bindingResult = BindParameters(analysis.Method, routeParamNames, bindingDiagnostics, errorOrContext,
            httpMethod, useLegacyBinding);
        if (!bindingResult.IsValid)
            return DiagnosticFlow.Fail<EndpointDescriptor>(bindingDiagnostics.ToImmutable().AsEquatableArray());

        builder.AddRange(bindingDiagnostics);

        // Validate route pattern
        builder.AddRange(RouteValidator.ValidatePattern(pattern, analysis.Method));

        // Extract method parameter info for route binding validation
        var methodParams = bindingResult.Parameters
            .Where(static p => p.Source == EndpointParameterSource.Route)
            .Select(static p => new RouteMethodParameterInfo(p.Name, p.KeyName ?? p.Name, p.TypeFqn, p.IsNullable))
            .ToImmutableArray();

        // Validate route parameters are bound
        builder.AddRange(RouteValidator.ValidateParameterBindings(
            pattern, routeParamInfos, methodParams, analysis.Method));

        // Validate route constraint types
        builder.AddRange(RouteValidator.ValidateConstraintTypes(
            routeParamInfos, methodParams, analysis.Method));

        var descriptor = new EndpointDescriptor(
            httpMethod,
            pattern,
            successTypeFqn,
            analysis.ReturnInfo.Kind,
            analysis.ReturnInfo.IsAsync,
            analysis.Method.ContainingType?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ?? "Unknown",
            analysis.Method.Name,
            new EquatableArray<EndpointParameter>(bindingResult.Parameters),
            analysis.InferredErrorTypeNames,
            analysis.InferredCustomErrors,
            analysis.ProducesErrors,
            analysis.ReturnInfo.IsSse,
            analysis.ReturnInfo.SseItemTypeFqn,
            analysis.IsAcceptedResponse,
            analysis.ReturnInfo.IdPropertyName,
            analysis.Middleware);

        var flow = DiagnosticFlow.Ok(descriptor);
        foreach (var diag in builder)
            flow = flow.Warn(diag);

        return flow;
    }

    private static (string? HttpMethod, string Pattern) ExtractHttpMethodAndPattern(
        AttributeData attr,
        string attrName)
    {
        var httpMethod = attrName switch
        {
            "GetAttribute" or "Get" => WellKnownTypes.HttpMethod.Get,
            "PostAttribute" or "Post" => WellKnownTypes.HttpMethod.Post,
            "PutAttribute" or "Put" => WellKnownTypes.HttpMethod.Put,
            "DeleteAttribute" or "Delete" => WellKnownTypes.HttpMethod.Delete,
            "PatchAttribute" or "Patch" => WellKnownTypes.HttpMethod.Patch,
            "ErrorOrEndpointAttribute" or "ErrorOrEndpoint" when
                attr.ConstructorArguments is [{ Value: string m }, ..]
                => m.ToUpperInvariant(),
            _ => null
        };

        if (httpMethod is null)
            return (null, "/");

        // Extract pattern
        var patternIndex = attrName.Contains("ErrorOrEndpoint") ? 1 : 0;
        var pattern = "/";
        if (attr.ConstructorArguments.Length > patternIndex &&
            attr.ConstructorArguments[patternIndex].Value is string p)
            pattern = p;

        return (httpMethod, pattern);
    }

#pragma warning restore EPS06
}