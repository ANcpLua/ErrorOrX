using System.Collections.Immutable;
using System.Text;
using ANcpLua.Roslyn.Utilities;
using ErrorOr.Analyzers;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace ErrorOr.Generators;

/// <summary>
///     Code emission logic for endpoint mappings.
/// </summary>
public sealed partial class ErrorOrEndpointGenerator
{
    internal static void EmitEndpoints(SourceProductionContext spc, ImmutableArray<EndpointDescriptor> endpoints,
        ImmutableArray<JsonContextInfo> userContexts, int maxArity = 6, bool generateJsonContext = true)
    {
        var sorted = SortEndpoints(endpoints);
        var jsonTypes = CollectJsonTypes(sorted);

        EmitGlobalUsings(spc);
        EmitOptionsClass(spc);
        EmitMappings(spc, sorted, jsonTypes.Count > 0, maxArity);

        if (jsonTypes.Count > 0 && generateJsonContext)
            EmitJsonContext(spc, jsonTypes, userContexts);
    }

    private static void EmitGlobalUsings(SourceProductionContext spc)
    {
        const string source = """
                              // <auto-generated/>
                              global using ErrorOr.Generated;
                              """;
        spc.AddSource("ErrorOrEndpoints.GlobalUsings.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private static void EmitMappings(SourceProductionContext spc, ImmutableArray<EndpointDescriptor> endpoints,
        bool hasJsonTypes, int maxArity)
    {
        var code = new StringBuilder();
        code.AppendLine("// <auto-generated>");
        code.AppendLine("// This file was generated by ErrorOr.Generators source generator.");
        code.AppendLine("// Any modifications will be overwritten on next build.");
        code.AppendLine("// </auto-generated>");
        code.AppendLine();
        code.AppendLine("#nullable enable");
        code.AppendLine("using System;");
        code.AppendLine("using System.Linq;");
        code.AppendLine("using System.Threading.Tasks;");
        code.AppendLine("using Microsoft.AspNetCore.Builder;");
        code.AppendLine("using Microsoft.AspNetCore.Http;");
        code.AppendLine("using Microsoft.AspNetCore.Routing;");
        code.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        code.AppendLine();
        code.AppendLine("namespace ErrorOr.Generated");
        code.AppendLine("{");
        code.AppendLine("    /// <summary>");
        code.AppendLine("    /// Generated endpoint mappings for all [ErrorOrEndpoint] handlers in this assembly.");
        code.AppendLine("    /// </summary>");
        code.AppendLine("    public static class ErrorOrEndpointMappings");
        code.AppendLine("    {");
        code.AppendLine("        /// <summary>");
        code.AppendLine("        /// Maps all ErrorOr endpoints to the application's routing table.");
        code.AppendLine("        /// </summary>");
        code.AppendLine("        /// <param name=\"app\">The endpoint route builder to add mappings to.</param>");
        code.AppendLine("        public static void MapErrorOrEndpoints(this IEndpointRouteBuilder app)");
        code.AppendLine("        {");

        for (var i = 0; i < endpoints.Length; i++)
            EmitMapCall(code, endpoints[i], i, maxArity);

        code.AppendLine("        }");
        code.AppendLine();

        if (hasJsonTypes)
            EmitJsonConfigExtension(code);

        for (var i = 0; i < endpoints.Length; i++)
            EmitInvoker(code, endpoints[i], i, maxArity);

        EmitSupportMethods(code);
        code.AppendLine("    }");
        code.AppendLine("}");

        spc.AddSource("ErrorOrEndpointMappings.cs", SourceText.From(code.ToString(), Encoding.UTF8));
    }

    private static void EmitMapCall(StringBuilder code, in EndpointDescriptor ep, int index, int maxArity)
    {
        var successInfo = ResultsUnionTypeBuilder.GetSuccessResponseInfo(
            ep.SuccessTypeFqn,
            ep.SuccessKind,
            ep.HttpMethod,
            ep.IsAcceptedResponse);

        var unionResult = ResultsUnionTypeBuilder.ComputeReturnType(
            ep.SuccessTypeFqn,
            ep.SuccessKind,
            ep.HttpMethod,
            ep.InferredErrorTypeNames,
            ep.InferredCustomErrors,
            ep.DeclaredProducesErrors,
            maxArity,
            ep.IsAcceptedResponse,
            ep.Middleware);

        code.AppendLine(
            $"            // {ep.HttpMethod} {ep.Pattern} -> {ep.HandlerContainingTypeFqn}.{ep.HandlerMethodName}");
        var mapMethod = ep.HttpMethod switch
        {
            "GET" => "MapGet",
            "POST" => "MapPost",
            "PUT" => "MapPut",
            "DELETE" => "MapDelete",
            "PATCH" => "MapPatch",
            _ => "MapMethods"
        };
        // Use typed Map* methods without Delegate cast for AOT compatibility
        // The handler takes HttpContext and returns Task<Results<...>>
        code.AppendLine(mapMethod == "MapMethods"
            ? $"            app.MapMethods(@\"{ep.Pattern}\", new[] {{ \"{ep.HttpMethod}\" }}, Invoke_Ep{index})"
            : $"            app.{mapMethod}(@\"{ep.Pattern}\", Invoke_Ep{index})");

        var className = TypeNameHelper.ExtractShortName(ep.HandlerContainingTypeFqn);
        var (tagName, operationId) = TypeNameHelper.GetEndpointIdentity(className, ep.HandlerMethodName);

        code.AppendLine($"            .WithName(\"{operationId}\")");
        code.AppendLine($"            .WithTags(\"{tagName}\")");

        // Add body content type metadata using WithMetadata (works on IEndpointConventionBuilder)
        // This replaces .Accepts() which requires RouteHandlerBuilder
        // AcceptsMetadata constructor: (string[] contentTypes, Type? requestType = null)
        var bodyParam = ep.HandlerParameters.AsImmutableArray()
            .FirstOrDefault(static p => p.Source == EndpointParameterSource.Body);
        if (bodyParam.Name is not null)
            code.AppendLine(
                $"            .WithMetadata(new global::Microsoft.AspNetCore.Http.Metadata.AcceptsMetadata(new[] {{ \"{WellKnownTypes.Constants.ContentTypeJson}\" }}, typeof({bodyParam.TypeFqn})))");
        else if (HasFormParams(ep))
            code.AppendLine(
                $"            .WithMetadata(new global::Microsoft.AspNetCore.Http.Metadata.AcceptsMetadata(new[] {{ \"{WellKnownTypes.Constants.ContentTypeFormData}\" }}, typeof(object)))");

        if (ep.IsSse)
        {
            code.AppendLine(
                $"            .WithMetadata(new {WellKnownTypes.Fqn.ProducesResponseTypeMetadata}(200, null, new[] {{ \"text/event-stream\" }}))");
        }
        else if (!unionResult.CanUseUnion)
        {
            // Use WithMetadata(ProducesResponseTypeMetadata) instead of .Produces() for AOT compatibility
            // .Produces() requires RouteHandlerBuilder, but without (Delegate) cast we get IEndpointConventionBuilder
            code.AppendLine(successInfo.HasBody
                ? $"            .WithMetadata(new {WellKnownTypes.Fqn.ProducesResponseTypeMetadata}({successInfo.StatusCode}, typeof({ep.SuccessTypeFqn}), new[] {{ \"{WellKnownTypes.Constants.ContentTypeJson}\" }}))"
                : $"            .WithMetadata(new {WellKnownTypes.Fqn.ProducesResponseTypeMetadata}({successInfo.StatusCode}))");

            foreach (var statusCode in unionResult.ExplicitProduceCodes.AsImmutableArray().Distinct()
                         .OrderBy(static x => x))
                code.AppendLine(statusCode == 400
                    ? $"            .WithMetadata(new {WellKnownTypes.Fqn.ProducesResponseTypeMetadata}(400, typeof({WellKnownTypes.Fqn.HttpValidationProblemDetails}), new[] {{ \"{WellKnownTypes.Constants.ContentTypeProblemJson}\" }}))"
                    : $"            .WithMetadata(new {WellKnownTypes.Fqn.ProducesResponseTypeMetadata}({statusCode}, typeof({WellKnownTypes.Fqn.ProblemDetails}), new[] {{ \"{WellKnownTypes.Constants.ContentTypeProblemJson}\" }}))");
        }

        // Emit middleware fluent calls based on BCL attributes
        EmitMiddlewareCalls(code, ep.Middleware);

        code.AppendLine("            ;");
        code.AppendLine();
    }

    /// <summary>
    ///     Emits middleware fluent calls based on BCL attributes detected on the endpoint.
    /// </summary>
    private static void EmitMiddlewareCalls(StringBuilder code, in MiddlewareInfo middleware)
    {
        if (!middleware.HasAny)
            return;

        // Authorization: [Authorize] / [Authorize("Policy")] / [AllowAnonymous]
        if (middleware.AllowAnonymous)
            code.AppendLine("            .AllowAnonymous()");
        else if (middleware.RequiresAuthorization)
            code.AppendLine(middleware.AuthorizationPolicy is not null
                ? $"            .RequireAuthorization(\"{middleware.AuthorizationPolicy}\")"
                : "            .RequireAuthorization()");

        // Rate Limiting: [EnableRateLimiting("policy")] / [DisableRateLimiting]
        if (middleware.DisableRateLimiting)
            code.AppendLine("            .DisableRateLimiting()");
        else if (middleware is { EnableRateLimiting: true, RateLimitingPolicy: not null })
            code.AppendLine($"            .RequireRateLimiting(\"{middleware.RateLimitingPolicy}\")");

        // Output Caching: [OutputCache] / [OutputCache(Duration = 60)] / [OutputCache(PolicyName = "x")]
        if (middleware.EnableOutputCache)
        {
            if (middleware.OutputCachePolicy is not null)
                code.AppendLine($"            .CacheOutput(\"{middleware.OutputCachePolicy}\")");
            else if (middleware.OutputCacheDuration is { } duration)
                code.AppendLine(
                    $"            .CacheOutput(p => p.Expire(global::System.TimeSpan.FromSeconds({duration})))");
            else
                code.AppendLine("            .CacheOutput()");
        }

        // CORS: [EnableCors("policy")] / [DisableCors]
        if (middleware.DisableCors)
            code.AppendLine("            .DisableCors()");
        else if (middleware is { EnableCors: true, CorsPolicy: not null })
            code.AppendLine($"            .RequireCors(\"{middleware.CorsPolicy}\")");
    }

    private static void EmitInvoker(StringBuilder code, in EndpointDescriptor ep, int index, int maxArity)
    {
        var successInfo = ResultsUnionTypeBuilder.GetSuccessResponseInfo(
            ep.SuccessTypeFqn,
            ep.SuccessKind,
            ep.HttpMethod,
            ep.IsAcceptedResponse);

        var unionResult = ResultsUnionTypeBuilder.ComputeReturnType(
            ep.SuccessTypeFqn,
            ep.SuccessKind,
            ep.HttpMethod,
            ep.InferredErrorTypeNames,
            ep.InferredCustomErrors,
            ep.DeclaredProducesErrors,
            maxArity,
            ep.IsAcceptedResponse,
            ep.Middleware);

        var needsAwait = ep.IsAsync || HasFormParams(ep) || HasBodyParam(ep) || HasBindAsyncParam(ep);

        var bodyCode = new StringBuilder();
        var usedBindFail = HasFormParams(ep);

        if (usedBindFail)
            EmitFormContentTypeGuard(bodyCode);

        var args = new StringBuilder();
        var validationParams = new List<(int Index, string ParamName)>();
        for (var i = 0; i < ep.HandlerParameters.Length; i++)
        {
            var param = ep.HandlerParameters[i];
            usedBindFail |= EmitParameterBinding(bodyCode, in param, $"p{i}", "BindFail");
            if (i > 0) args.Append(", ");
            args.Append(BuildArgumentExpression(in param, $"p{i}"));

            // Track parameters that require BCL validation
            if (param.RequiresValidation)
                validationParams.Add((i, $"p{i}"));
        }

        // Emit BCL validation calls for parameters that require it
        if (validationParams.Count > 0)
            EmitBclValidation(bodyCode, validationParams, unionResult.ReturnTypeFqn, needsAwait);

        var awaitKeyword = ep.IsAsync ? "await " : "";
        bodyCode.AppendLine(
            $"            var result = {awaitKeyword}{ep.HandlerContainingTypeFqn}.{ep.HandlerMethodName}({args});");

        if (ep.IsSse)
        {
            bodyCode.AppendLine($"            if (result.IsError) return {WrapReturn("ToProblem(result.Errors)")};");
            bodyCode.AppendLine(
                $"            return {WrapReturn($"{WellKnownTypes.Fqn.TypedResults.ServerSentEvents}(result.Value)")};");
        }
        else if (unionResult.CanUseUnion)
        {
            EmitUnionTypeErrorHandling(bodyCode, ep, unionResult.ReturnTypeFqn, successInfo, needsAwait);
        }
        else
        {
            var matchFactory = GetMatchFactoryWithLocation(ep, successInfo);
            bodyCode.AppendLine(
                $"            return {WrapReturn($"result.Match<{WellKnownTypes.Fqn.Result}>({matchFactory}, errors => ToProblem(errors))")};");
        }

        // Emit wrapper method that calls ExecuteAsync on the IResult
        // This ensures the handler matches RequestDelegate (Task, not Task<T>) and properly writes the response
        code.AppendLine($"        private static async Task Invoke_Ep{index}(HttpContext ctx)");
        code.AppendLine("        {");
        code.AppendLine($"            var __result = await Invoke_Ep{index}_Core(ctx);");
        code.AppendLine("            await __result.ExecuteAsync(ctx);");
        code.AppendLine("        }");
        code.AppendLine();

        // Emit core method that returns the typed Results union (for logic)
        code.AppendLine(
            needsAwait
                ? $"        private static async Task<{unionResult.ReturnTypeFqn}> Invoke_Ep{index}_Core(HttpContext ctx)"
                : $"        private static Task<{unionResult.ReturnTypeFqn}> Invoke_Ep{index}_Core(HttpContext ctx)");

        code.AppendLine("        {");

        if (usedBindFail)
            EmitBindFailHelper(code, unionResult.ReturnTypeFqn, needsAwait);

        code.Append(bodyCode);
        code.AppendLine("        }");
        code.AppendLine();
        return;

        string WrapReturn(string expr)
        {
            return needsAwait ? expr : $"Task.FromResult<{unionResult.ReturnTypeFqn}>({expr})";
        }
    }

    private static bool HasBodyParam(in EndpointDescriptor ep)
    {
        return ep.HandlerParameters.AsImmutableArray().Any(static p => p.Source == EndpointParameterSource.Body);
    }

    private static bool HasBindAsyncParam(in EndpointDescriptor ep)
    {
        return ep.HandlerParameters.AsImmutableArray().Any(static p =>
            p.CustomBinding is CustomBindingMethod.BindAsync or CustomBindingMethod.BindAsyncWithParam);
    }

    /// <summary>
    ///     Emits BCL validation calls for parameters that have ValidationAttribute or implement IValidatableObject.
    ///     Uses System.ComponentModel.DataAnnotations.Validator.TryValidateObject for validation.
    /// </summary>
    private static void EmitBclValidation(StringBuilder code, List<(int Index, string ParamName)> validationParams,
        string returnTypeFqn, bool isAsync)
    {
        code.AppendLine();
        code.AppendLine("            // BCL Validation");

        foreach (var (_, paramName) in validationParams)
        {
            code.AppendLine(
                $"            var {paramName}ValidationResults = new {WellKnownTypes.Fqn.List}<{WellKnownTypes.Fqn.ValidationResult}>();");
            code.AppendLine(
                $"            if (!{WellKnownTypes.Fqn.Validator}.TryValidateObject({paramName}!, new {WellKnownTypes.Fqn.ValidationContext}({paramName}!), {paramName}ValidationResults, validateAllProperties: true))");
            code.AppendLine("            {");
            code.AppendLine(
                $"                var validationDict = new {WellKnownTypes.Fqn.Dictionary}<string, string[]>();");
            code.AppendLine($"                foreach (var vr in {paramName}ValidationResults)");
            code.AppendLine("                {");
            code.AppendLine("                    var key = vr.MemberNames.FirstOrDefault() ?? \"\";");
            code.AppendLine("                    if (!validationDict.TryGetValue(key, out var existing))");
            code.AppendLine("                        validationDict[key] = new[] { vr.ErrorMessage ?? \"\" };");
            code.AppendLine("                    else");
            code.AppendLine("                    {");
            code.AppendLine("                        var arr = new string[existing.Length + 1];");
            code.AppendLine("                        existing.CopyTo(arr, 0);");
            code.AppendLine("                        arr[existing.Length] = vr.ErrorMessage ?? \"\";");
            code.AppendLine("                        validationDict[key] = arr;");
            code.AppendLine("                    }");
            code.AppendLine("                }");

            var returnExpr = isAsync
                ? $"{WellKnownTypes.Fqn.TypedResults.ValidationProblem}(validationDict)"
                : $"Task.FromResult<{returnTypeFqn}>({WellKnownTypes.Fqn.TypedResults.ValidationProblem}(validationDict))";
            code.AppendLine($"                return {returnExpr};");
            code.AppendLine("            }");
        }

        code.AppendLine();
    }

    private static void EmitBindFailHelper(StringBuilder code, string returnTypeFqn, bool isAsync)
    {
        code.AppendLine(
            $"            static {WellKnownTypes.Fqn.ProblemDetails} CreateBindProblem(string param, string reason) => new()");
        code.AppendLine("            {");
        code.AppendLine("                Title = \"Bad Request\",");
        code.AppendLine("                Detail = $\"Parameter '{param}' {reason}.\",");
        code.AppendLine("                Status = 400,");
        code.AppendLine($"                Type = \"{WellKnownTypes.Constants.HttpStatusesBaseUrl}400\",");
        code.AppendLine("            };");
        code.AppendLine();

        var badRequestExpr = $"{WellKnownTypes.Fqn.TypedResults.BadRequest}(CreateBindProblem(param, reason))";
        var returnExpr = isAsync ? badRequestExpr : $"Task.FromResult<{returnTypeFqn}>({badRequestExpr})";
        var returnType = isAsync ? returnTypeFqn : $"Task<{returnTypeFqn}>";

        code.AppendLine($"            static {returnType} BindFail(string param, string reason)");
        code.AppendLine($"                => {returnExpr};");
        code.AppendLine();
    }

    private static void EmitUnionTypeErrorHandling(
        StringBuilder code,
        in EndpointDescriptor ep,
        string returnType,
        SuccessResponseInfo successInfo,
        bool needsAwait)
    {
        string WrapReturn(string expr)
        {
            return needsAwait ? expr : $"Task.FromResult<{returnType}>({expr})";
        }

        code.AppendLine("            if (result.IsError)");
        code.AppendLine("            {");
        code.AppendLine("                var first = result.FirstError;");

        EmitValidationHandling(code, ep, WrapReturn);
        EmitProblemDetailsBuilding(code);
        EmitErrorTypeSwitch(code, ep, WrapReturn);

        code.AppendLine("            }");
        code.AppendLine();

        // Generate Location header for POST endpoints with Created response and Id property
        var successFactory = GetSuccessFactoryWithLocation(ep, successInfo);
        code.AppendLine($"            return {WrapReturn(successFactory)};");
    }

    /// <summary>
    ///     Returns the appropriate success factory, with Location header support for Created responses.
    /// </summary>
    private static string GetSuccessFactoryWithLocation(in EndpointDescriptor ep, SuccessResponseInfo successInfo)
    {
        // Only apply Location header for POST endpoints returning Created with an Id property
        if (ep.HttpMethod != WellKnownTypes.HttpMethod.Post)
            return successInfo.Factory;

        if (successInfo.StatusCode != 201)
            return successInfo.Factory;

        // Location header requires both a body (with the Id value) and a detected Id property
        if (!successInfo.HasBody)
            return successInfo.Factory;

        if (ep.LocationIdPropertyName is not { Length: > 0 } idProp)
            return successInfo.Factory;

        // Generate Location URL: request path + "/" + id value
        // For POST /api/users with response { Id: 123 }, Location becomes /api/users/123
        return
            $"{WellKnownTypes.Fqn.TypedResults.Created}($\"{{ctx.Request.Path}}/{{result.Value.{idProp}}}\", result.Value)";
    }

    /// <summary>
    ///     Returns the appropriate match factory lambda, with Location header support for Created responses.
    /// </summary>
    private static string GetMatchFactoryWithLocation(in EndpointDescriptor ep, SuccessResponseInfo successInfo)
    {
        // Only apply Location header for POST endpoints returning Created with an Id property
        if (ep.HttpMethod != WellKnownTypes.HttpMethod.Post)
            return successInfo.MatchFactory;

        if (successInfo.StatusCode != 201)
            return successInfo.MatchFactory;

        // Location header requires both a body (with the Id value) and a detected Id property
        if (!successInfo.HasBody)
            return successInfo.MatchFactory;

        if (ep.LocationIdPropertyName is not { Length: > 0 } idProp)
            return successInfo.MatchFactory;

        // Generate Location URL using lambda parameter 'value'
        // For POST /api/users with response { Id: 123 }, Location becomes /api/users/123
        return
            $"value => {WellKnownTypes.Fqn.TypedResults.Created}($\"{{ctx.Request.Path}}/{{value.{idProp}}}\", value)";
    }

    private static void EmitValidationHandling(StringBuilder code, in EndpointDescriptor ep,
        Func<string, string> wrapReturn)
    {
        var hasValidation = !ep.InferredErrorTypeNames.IsDefaultOrEmpty &&
                            ep.InferredErrorTypeNames.AsImmutableArray().Contains(ErrorMapping.Validation);

        if (!hasValidation) return;

        code.AppendLine($"                if (first.Type == {WellKnownTypes.Fqn.ErrorType}.Validation)");
        code.AppendLine("                {");
        code.AppendLine(
            $"                    var validationDict = new {WellKnownTypes.Fqn.Dictionary}<string, string[]>();");
        code.AppendLine("                    foreach (var e in result.Errors)");
        code.AppendLine("                    {");
        code.AppendLine(
            $"                        if (e.Type != {WellKnownTypes.Fqn.ErrorType}.Validation) continue;");
        code.AppendLine("                        if (!validationDict.TryGetValue(e.Code, out var existing))");
        code.AppendLine("                            validationDict[e.Code] = new[] { e.Description };");
        code.AppendLine("                        else");
        code.AppendLine("                        {");
        code.AppendLine("                            var arr = new string[existing.Length + 1];");
        code.AppendLine("                            existing.CopyTo(arr, 0);");
        code.AppendLine("                            arr[existing.Length] = e.Description;");
        code.AppendLine("                            validationDict[e.Code] = arr;");
        code.AppendLine("                        }");
        code.AppendLine("                    }");
        code.AppendLine(
            $"                    return {wrapReturn($"{WellKnownTypes.Fqn.TypedResults.ValidationProblem}(validationDict)")};");
        code.AppendLine("                }");
    }

    private static void EmitProblemDetailsBuilding(StringBuilder code)
    {
        code.AppendLine($"                var problem = new {WellKnownTypes.Fqn.ProblemDetails}");
        code.AppendLine("                {");
        code.AppendLine("                    Title = first.Code,");
        code.AppendLine("                    Detail = first.Description,");
        code.AppendLine(
            $"                    Status = first.Type switch {{ {ErrorMapping.GenerateStatusSwitch(WellKnownTypes.Fqn.ErrorType)} }}");
        code.AppendLine("                };");
        code.AppendLine("                problem.Type = $\"https://httpstatuses.io/{problem.Status}\";");
        code.AppendLine();
    }

    private static void EmitErrorTypeSwitch(StringBuilder code, in EndpointDescriptor ep,
        Func<string, string> wrapReturn)
    {
        code.AppendLine("                switch (first.Type)");
        code.AppendLine("                {");

        if (!ep.InferredErrorTypeNames.IsDefaultOrEmpty)
            foreach (var errorTypeName in ep.InferredErrorTypeNames.AsImmutableArray()
                         .Where(static e => e != ErrorMapping.Validation)
                         .Distinct()
                         .OrderBy(static x => x, StringComparer.Ordinal))
            {
                var factory = ErrorMapping.GetFactory(errorTypeName);

                code.AppendLine($"                    case {WellKnownTypes.Fqn.ErrorType}.{errorTypeName}:");
                code.AppendLine($"                        return {wrapReturn(factory)};");
            }

        code.AppendLine("                    default:");
        code.AppendLine($"                        return {wrapReturn(ErrorMapping.GetFactory(ErrorMapping.Failure))};");
        code.AppendLine("                }");
    }

    /// <summary>
    ///     Emits parameter binding code and returns whether BindFail helper is used.
    /// </summary>
    private static bool EmitParameterBinding(StringBuilder code, in EndpointParameter param, string paramName,
        string bindFailFn)
    {
        return param.Source switch
        {
            EndpointParameterSource.Route => EmitRouteBinding(code, in param, paramName, bindFailFn),
            EndpointParameterSource.Query => EmitQueryBinding(code, in param, paramName, bindFailFn),
            EndpointParameterSource.Header => EmitHeaderBinding(code, in param, paramName, bindFailFn),
            EndpointParameterSource.Body => EmitBodyBinding(code, in param, paramName, bindFailFn),
            EndpointParameterSource.Service => EmitServiceBinding(code, in param, paramName),
            EndpointParameterSource.KeyedService => EmitKeyedServiceBinding(code, in param, paramName),
            EndpointParameterSource.HttpContext => EmitHttpContextBinding(code, paramName),
            EndpointParameterSource.CancellationToken => EmitCancellationTokenBinding(code, paramName),
            EndpointParameterSource.Stream => EmitStreamBinding(code, paramName),
            EndpointParameterSource.PipeReader => EmitPipeReaderBinding(code, paramName),
            EndpointParameterSource.FormFile => EmitFormFileBinding(code, in param, paramName, bindFailFn),
            EndpointParameterSource.FormFiles => EmitFormFilesBinding(code, paramName),
            EndpointParameterSource.FormCollection => EmitFormCollectionBinding(code, paramName),
            EndpointParameterSource.Form => EmitFormBinding(code, in param, paramName, bindFailFn),
            EndpointParameterSource.AsParameters => EmitAsParametersBinding(code, in param, paramName, bindFailFn),
            _ => false
        };
    }

    private static bool EmitServiceBinding(StringBuilder code, in EndpointParameter param, string paramName)
    {
        code.AppendLine($"            var {paramName} = ctx.RequestServices.GetRequiredService<{param.TypeFqn}>();");
        return false;
    }

    private static bool EmitKeyedServiceBinding(StringBuilder code, in EndpointParameter param, string paramName)
    {
        code.AppendLine(
            $"            var {paramName} = ctx.RequestServices.GetRequiredKeyedService<{param.TypeFqn}>({param.KeyName});");
        return false;
    }

    private static bool EmitHttpContextBinding(StringBuilder code, string paramName)
    {
        code.AppendLine($"            var {paramName} = ctx;");
        return false;
    }

    private static bool EmitCancellationTokenBinding(StringBuilder code, string paramName)
    {
        code.AppendLine($"            var {paramName} = ctx.RequestAborted;");
        return false;
    }

    private static bool EmitStreamBinding(StringBuilder code, string paramName)
    {
        code.AppendLine($"            var {paramName} = ctx.Request.Body;");
        return false;
    }

    private static bool EmitPipeReaderBinding(StringBuilder code, string paramName)
    {
        code.AppendLine($"            var {paramName} = ctx.Request.BodyReader;");
        return false;
    }

    private static bool EmitFormFilesBinding(StringBuilder code, string paramName)
    {
        code.AppendLine($"            var {paramName} = form.Files;");
        return false;
    }

    private static bool EmitFormCollectionBinding(StringBuilder code, string paramName)
    {
        code.AppendLine($"            var {paramName} = form;");
        return false;
    }

    private static bool EmitFormFileBinding(StringBuilder code, in EndpointParameter param, string paramName,
        string bindFailFn)
    {
        code.AppendLine($"            var {paramName} = form.Files.GetFile(\"{param.KeyName ?? param.Name}\");");
        if (param.IsNullable) return false;

        code.AppendLine(
            $"            if ({paramName} is null) return {bindFailFn}(\"{param.Name}\", \"is required\");");
        return true;
    }

    private static bool EmitRouteBinding(StringBuilder code, in EndpointParameter param, string paramName,
        string bindFailFn)
    {
        var routeName = param.KeyName ?? param.Name;
        code.AppendLine(
            TypeNameHelper.IsStringType(param.TypeFqn)
                ? $"            if (!TryGetRouteValue(ctx, \"{routeName}\", out var {paramName})) return {bindFailFn}(\"{param.Name}\", \"is missing from route\");"
                : $"            if (!TryGetRouteValue(ctx, \"{routeName}\", out var {paramName}Raw) || !{GetTryParseExpression(param.TypeFqn, paramName + "Raw", paramName, param.CustomBinding)}) return {bindFailFn}(\"{param.Name}\", \"has invalid format\");");
        return true;
    }

    private static bool EmitQueryBinding(StringBuilder code, in EndpointParameter param, string paramName,
        string bindFailFn)
    {
        if (param.CustomBinding is CustomBindingMethod.BindAsync or CustomBindingMethod.BindAsyncWithParam)
            return EmitBindAsyncBinding(code, in param, paramName, bindFailFn);

        var queryKey = param.KeyName ?? param.Name;
        return param is { IsCollection: true, CollectionItemTypeFqn: { } itemType }
            ? EmitCollectionQueryBinding(code, in param, paramName, queryKey, itemType, bindFailFn)
            : EmitScalarQueryBinding(code, in param, paramName, queryKey, bindFailFn);
    }

    private static bool EmitBindAsyncBinding(StringBuilder code, in EndpointParameter param, string paramName,
        string bindFailFn)
    {
        var baseType = param.TypeFqn.TrimEnd('?');
        code.AppendLine($"            var {paramName} = await {baseType}.BindAsync(ctx);");
        if (param.IsNullable) return false;

        code.AppendLine(
            $"            if ({paramName} is null) return {bindFailFn}(\"{param.Name}\", \"binding failed\");");
        return true;
    }

    private static bool EmitCollectionQueryBinding(StringBuilder code, in EndpointParameter param, string paramName,
        string queryKey, string itemType, string bindFailFn)
    {
        code.AppendLine($"            var {paramName}Raw = ctx.Request.Query[\"{queryKey}\"];");
        code.AppendLine($"            var {paramName}List = new {WellKnownTypes.Fqn.List}<{itemType}>();");
        code.AppendLine($"            foreach (var item in {paramName}Raw)");
        code.AppendLine("            {");

        var usesBindFail = false;
        if (TypeNameHelper.IsStringType(itemType))
        {
            code.AppendLine(
                $"                if (item is {{ Length: > 0 }} validItem) {paramName}List.Add(validItem);");
        }
        else
        {
            usesBindFail = true;
            code.AppendLine(
                $"                if ({GetTryParseExpression(itemType, "item", "parsedItem")}) {paramName}List.Add(parsedItem);");
            code.AppendLine(
                $"                else if (!string.IsNullOrEmpty(item)) return {bindFailFn}(\"{param.Name}\", \"has invalid item format\");");
        }

        code.AppendLine("            }");
        var isArray = param.TypeFqn.EndsWith("[]");
        var assignment = isArray ? $"{paramName}List.ToArray()" : $"{paramName}List";
        code.AppendLine($"            var {paramName} = {assignment};");
        return usesBindFail;
    }

    private static bool EmitScalarQueryBinding(StringBuilder code, in EndpointParameter param, string paramName,
        string queryKey, string bindFailFn)
    {
        var usesBindFail = false;
        var declType = param.TypeFqn.EndsWith("?") ? param.TypeFqn : param.TypeFqn + "?";
        code.AppendLine($"            {declType} {paramName};");
        code.AppendLine($"            if (!TryGetQueryValue(ctx, \"{queryKey}\", out var {paramName}Raw))");
        code.AppendLine("            {");
        if (param.IsNullable)
        {
            code.AppendLine($"                {paramName} = default;");
        }
        else
        {
            usesBindFail = true;
            code.AppendLine($"                return {bindFailFn}(\"{param.Name}\", \"is required\");");
        }

        code.AppendLine("            }");
        code.AppendLine("            else");
        code.AppendLine("            {");
        if (TypeNameHelper.IsStringType(param.TypeFqn))
        {
            code.AppendLine($"                {paramName} = {paramName}Raw;");
        }
        else
        {
            usesBindFail = true;
            code.AppendLine(
                $"                if (!{GetTryParseExpression(param.TypeFqn, paramName + "Raw", paramName + "Temp", param.CustomBinding)}) return {bindFailFn}(\"{param.Name}\", \"has invalid format\");");
            code.AppendLine($"                {paramName} = {paramName}Temp;");
        }

        code.AppendLine("            }");
        return usesBindFail;
    }

    private static bool EmitHeaderBinding(StringBuilder code, in EndpointParameter param, string paramName,
        string bindFailFn)
    {
        var key = param.KeyName ?? param.Name;
        var usesBindFail = false;

        if (param is { IsCollection: true, CollectionItemTypeFqn: { } itemType })
        {
            code.AppendLine($"            {param.TypeFqn} {paramName};");
            code.AppendLine(
                $"            if (!ctx.Request.Headers.TryGetValue(\"{key}\", out var {paramName}Raw) || {paramName}Raw.Count is 0)");
            code.AppendLine("            {");
            if (param.IsNullable)
            {
                code.AppendLine($"                {paramName} = default!;");
            }
            else
            {
                usesBindFail = true;
                code.AppendLine($"                return {bindFailFn}(\"{param.Name}\", \"is required\");");
            }

            code.AppendLine("            }");
            code.AppendLine("            else");
            code.AppendLine("            {");
            code.AppendLine($"                var {paramName}List = new {WellKnownTypes.Fqn.List}<{itemType}>();");
            code.AppendLine($"                foreach (var item in {paramName}Raw)");
            code.AppendLine("                {");
            code.AppendLine(
                TypeNameHelper.IsStringType(itemType)
                    ? $"                    if (item is {{ Length: > 0 }} validItem) {paramName}List.Add(validItem);"
                    : $"                    if ({GetTryParseExpression(itemType, "item", "parsedItem")}) {paramName}List.Add(parsedItem);");
            code.AppendLine("                }");
            var isArray = param.TypeFqn.EndsWith("[]");
            var assignment = isArray ? $"{paramName}List.ToArray()" : $"{paramName}List";
            code.AppendLine($"                {paramName} = {assignment};");
            code.AppendLine("            }");
        }
        else
        {
            var declType = param.TypeFqn.EndsWith("?") ? param.TypeFqn : param.TypeFqn + "?";
            code.AppendLine($"            {declType} {paramName};");
            code.AppendLine(
                $"            if (!ctx.Request.Headers.TryGetValue(\"{key}\", out var {paramName}Raw) || {paramName}Raw.Count is 0)");
            code.AppendLine("            {");
            if (param.IsNullable)
            {
                code.AppendLine($"                {paramName} = default;");
            }
            else
            {
                usesBindFail = true;
                code.AppendLine($"                return {bindFailFn}(\"{param.Name}\", \"is required\");");
            }

            code.AppendLine("            }");
            code.AppendLine("            else");
            code.AppendLine("            {");
            if (TypeNameHelper.IsStringType(param.TypeFqn))
            {
                code.AppendLine($"                {paramName} = {paramName}Raw.ToString();");
            }
            else
            {
                usesBindFail = true;
                code.AppendLine(
                    $"                if (!{GetTryParseExpression(param.TypeFqn, paramName + "Raw.ToString()", paramName + "Temp")}) return {bindFailFn}(\"{param.Name}\", \"has invalid format\"); {paramName} = {paramName}Temp;");
            }

            code.AppendLine("            }");
        }

        return usesBindFail;
    }

    private static bool EmitBodyBinding(StringBuilder code, in EndpointParameter param, string paramName,
        string bindFailFn)
    {
        code.AppendLine($"            {param.TypeFqn}? {paramName};");
        code.AppendLine("            try");
        code.AppendLine("            {");
        code.AppendLine(
            $"                {paramName} = await ctx.Request.ReadFromJsonAsync<{param.TypeFqn}>(cancellationToken: ctx.RequestAborted);");
        code.AppendLine("            }");
        code.AppendLine($"            catch ({WellKnownTypes.Fqn.JsonException})");
        code.AppendLine("            {");
        code.AppendLine($"                return {bindFailFn}(\"{param.Name}\", \"has invalid JSON format\");");
        code.AppendLine("            }");
        code.AppendLine(
            $"            if ({paramName} is null) return {bindFailFn}(\"{param.Name}\", \"is required\");");
        return true;
    }

    private static bool EmitFormBinding(StringBuilder code, in EndpointParameter param, string paramName,
        string bindFailFn)
    {
        if (!param.Children.IsDefaultOrEmpty)
        {
            var usesBindFail = false;
            for (var i = 0; i < param.Children.Length; i++)
            {
                var child = param.Children[i];
                usesBindFail |= EmitParameterBinding(code, in child, $"{paramName}_f{i}", bindFailFn);
            }

            var args = string.Join(", ", param.Children.AsImmutableArray().Select((_, i) => $"{paramName}_f{i}"));
            code.AppendLine($"            var {paramName} = new {param.TypeFqn}({args});");
            return usesBindFail;
        }

        var usesBindFailScalar = false;
        var fieldName = param.KeyName ?? param.Name;
        var declType = param.IsNullable && !param.TypeFqn.EndsWith("?") ? param.TypeFqn + "?" : param.TypeFqn;
        code.AppendLine($"            {declType} {paramName};");
        code.AppendLine(
            $"            if (!form.TryGetValue(\"{fieldName}\", out var {paramName}Raw) || {paramName}Raw.Count is 0)");
        code.AppendLine("            {");
        if (param.IsNullable)
        {
            code.AppendLine($"                {paramName} = default;");
        }
        else
        {
            usesBindFailScalar = true;
            code.AppendLine($"                return {bindFailFn}(\"{param.Name}\", \"is required\");");
        }

        code.AppendLine("            }");
        code.AppendLine("            else");
        code.AppendLine("            {");
        if (TypeNameHelper.IsStringType(param.TypeFqn))
        {
            code.AppendLine($"                {paramName} = {paramName}Raw.ToString();");
        }
        else
        {
            usesBindFailScalar = true;
            code.AppendLine(
                $"                if (!{GetTryParseExpression(param.TypeFqn, paramName + "Raw.ToString()", paramName + "Temp")}) return {bindFailFn}(\"{param.Name}\", \"has invalid format\");");
            code.AppendLine($"                {paramName} = {paramName}Temp;");
        }

        code.AppendLine("            }");
        return usesBindFailScalar;
    }

    private static bool EmitAsParametersBinding(StringBuilder code, in EndpointParameter param, string paramName,
        string bindFailFn)
    {
        var usesBindFail = false;
        var childVars = new List<string>();
        for (var i = 0; i < param.Children.Length; i++)
        {
            var child = param.Children[i];
            var childVarName = $"{paramName}_c{i}";
            usesBindFail |= EmitParameterBinding(code, in child, childVarName, bindFailFn);
            childVars.Add(BuildArgumentExpression(in child, childVarName));
        }

        code.AppendLine($"            var {paramName} = new {param.TypeFqn}({string.Join(", ", childVars)});");
        return usesBindFail;
    }

    private static void EmitFormContentTypeGuard(StringBuilder code)
    {
        code.AppendLine(
            $"            if (!ctx.Request.HasFormContentType) return BindFail(\"form\", \"content-type must be {WellKnownTypes.Constants.ContentTypeFormData}\");");
        code.AppendLine("            var form = await ctx.Request.ReadFormAsync(ctx.RequestAborted);");
        code.AppendLine();
    }

    private static void EmitJsonConfigExtension(StringBuilder code)
    {
        // Emit fluent builder: AddErrorOrEndpoints(Action<ErrorOrEndpointOptions>?)
        code.AppendLine("        /// <summary>");
        code.AppendLine("        /// Configures ErrorOr endpoints with fluent options.");
        code.AppendLine("        /// </summary>");
        code.AppendLine("        /// <param name=\"services\">The service collection to configure.</param>");
        code.AppendLine("        /// <param name=\"configure\">Optional configuration action.</param>");
        code.AppendLine("        /// <returns>The service collection for chaining.</returns>");
        code.AppendLine("        /// <example>");
        code.AppendLine("        /// <code>");
        code.AppendLine("        /// services.AddErrorOrEndpoints(options => options");
        code.AppendLine("        ///     .UseJsonContext&lt;AppJsonSerializerContext&gt;()");
        code.AppendLine("        ///     .WithCamelCase()");
        code.AppendLine("        ///     .WithIgnoreNulls());");
        code.AppendLine("        /// </code>");
        code.AppendLine("        /// </example>");
        code.AppendLine(
            "        public static IServiceCollection AddErrorOrEndpoints(this IServiceCollection services, System.Action<ErrorOrEndpointOptions>? configure = null)");
        code.AppendLine("        {");
        code.AppendLine("            var options = new ErrorOrEndpointOptions();");
        code.AppendLine("            configure?.Invoke(options);");
        code.AppendLine("            options.Apply(services);");
        code.AppendLine("            return services;");
        code.AppendLine("        }");
        code.AppendLine();
    }

    private static void EmitOptionsClass(SourceProductionContext spc)
    {
        const string source = """
            // <auto-generated>
            // This file was generated by ErrorOr.Generators source generator.
            // </auto-generated>

            #nullable enable

            namespace ErrorOr.Generated
            {
                /// <summary>
                /// Options for configuring ErrorOr endpoints.
                /// </summary>
                public sealed class ErrorOrEndpointOptions
                {
                    private global::System.Func<global::System.Text.Json.Serialization.JsonSerializerContext>? _jsonContextFactory;
                    private bool _useCamelCase = true;
                    private bool _ignoreNullValues = true;

                    /// <summary>
                    /// Registers a JsonSerializerContext for AOT-compatible JSON serialization.
                    /// </summary>
                    /// <typeparam name="TContext">The JsonSerializerContext type.</typeparam>
                    /// <returns>The options instance for chaining.</returns>
                    public ErrorOrEndpointOptions UseJsonContext<TContext>()
                        where TContext : global::System.Text.Json.Serialization.JsonSerializerContext, new()
                    {
                        _jsonContextFactory = static () => new TContext();
                        return this;
                    }

                    /// <summary>
                    /// Uses camelCase for JSON property names.
                    /// </summary>
                    /// <param name="enabled">Whether to enable camelCase (default: true).</param>
                    /// <returns>The options instance for chaining.</returns>
                    public ErrorOrEndpointOptions WithCamelCase(bool enabled = true)
                    {
                        _useCamelCase = enabled;
                        return this;
                    }

                    /// <summary>
                    /// Ignores null values when serializing JSON.
                    /// </summary>
                    /// <param name="enabled">Whether to ignore nulls (default: true).</param>
                    /// <returns>The options instance for chaining.</returns>
                    public ErrorOrEndpointOptions WithIgnoreNulls(bool enabled = true)
                    {
                        _ignoreNullValues = enabled;
                        return this;
                    }

                    /// <summary>
                    /// Applies the configured options to the service collection.
                    /// </summary>
                    internal void Apply(global::Microsoft.Extensions.DependencyInjection.IServiceCollection services)
                    {
                        services.ConfigureHttpJsonOptions(options =>
                        {
                            if (_jsonContextFactory is not null)
                                options.SerializerOptions.TypeInfoResolverChain.Insert(0, _jsonContextFactory());

                            if (_useCamelCase)
                                options.SerializerOptions.PropertyNamingPolicy = global::System.Text.Json.JsonNamingPolicy.CamelCase;

                            if (_ignoreNullValues)
                                options.SerializerOptions.DefaultIgnoreCondition = global::System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull;
                        });
                    }
                }
            }
            """;
        spc.AddSource("ErrorOrEndpointOptions.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private static void EmitJsonContext(SourceProductionContext spc, List<string> jsonTypes,
        ImmutableArray<JsonContextInfo> userContexts)
    {
        // If user has their own JsonSerializerContext, emit a helper file instead
        if (userContexts is { IsDefaultOrEmpty: false, Length: > 0 })
        {
            // If user context has [AotJson], AotJsonGenerator handles everything - no helper needed
            if (userContexts.Any(static ctx => ctx.HasAotJsonAttribute))
                return;

            EmitJsonContextHelper(spc, jsonTypes, userContexts);
            return;
        }

        // No user context - emit full ErrorOrJsonContext using IndentedStringBuilder
        var sb = new IndentedStringBuilder();
        sb.AppendLine(GeneratedCodeHelpers.AutoGeneratedHeader("ErrorOr.Generators"));
        sb.AppendLine("// JSON serialization context for Native AOT support.");
        sb.AppendLine(GeneratedCodeHelpers.NullableEnable);
        sb.AppendLine();
        sb.AppendLine(
            "[System.Text.Json.Serialization.JsonSourceGenerationOptions(DefaultIgnoreCondition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull)]");
        foreach (var type in jsonTypes)
            sb.AppendLine($"[System.Text.Json.Serialization.JsonSerializable(typeof({type}))]");
        sb.AppendLine(
            $"[System.Text.Json.Serialization.JsonSerializable(typeof({WellKnownTypes.Fqn.ProblemDetails}))]");
        sb.AppendLine(
            $"[System.Text.Json.Serialization.JsonSerializable(typeof({WellKnownTypes.Fqn.HttpValidationProblemDetails}))]");
        sb.AppendLine(
            "internal partial class ErrorOrJsonContext : System.Text.Json.Serialization.JsonSerializerContext { }");
        spc.AddSource("ErrorOrJsonContext.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private static void EmitJsonContextHelper(SourceProductionContext spc, List<string> jsonTypes,
        ImmutableArray<JsonContextInfo> userContexts)
    {
        var userContext = userContexts[0]; // Use first context found
        var fullClassName = userContext.Namespace is not null
            ? $"{userContext.Namespace}.{userContext.ClassName}"
            : userContext.ClassName;

        // Collect registered types from user context
        var registeredTypes = new HashSet<string>();
        foreach (var ctx in userContexts)
        foreach (var typeFqn in ctx.SerializableTypes)
            registeredTypes.Add(typeFqn);

        // Find missing types
        var missingTypes = new List<string>();

        // Check endpoint types
        foreach (var type in jsonTypes)
            if (!registeredTypes.Any(rt => TypeNameHelper.TypeNamesMatch(type, rt)))
                missingTypes.Add(type);

        // Always check for ProblemDetails and HttpValidationProblemDetails
        if (!registeredTypes.Any(static rt => TypeNameHelper.TypeNamesMatch(WellKnownTypes.Fqn.ProblemDetails, rt)))
            missingTypes.Add(WellKnownTypes.Fqn.ProblemDetails);
        if (!registeredTypes.Any(static rt =>
                TypeNameHelper.TypeNamesMatch(WellKnownTypes.Fqn.HttpValidationProblemDetails, rt)))
            missingTypes.Add(WellKnownTypes.Fqn.HttpValidationProblemDetails);

        // Report EOE040 if user context lacks CamelCase policy
        if (!userContext.HasCamelCasePolicy)
            spc.ReportDiagnostic(Diagnostic.Create(
                Descriptors.MissingCamelCasePolicy,
                Location.None,
                fullClassName));

        // Emit helper file with missing types as comments using IndentedStringBuilder
        var sb = new IndentedStringBuilder();
        sb.AppendLine(GeneratedCodeHelpers.AutoGeneratedHeader("ErrorOr.Generators"));
        sb.AppendLine("// ErrorOrX JSON Context Helper");
        sb.AppendLine();
        sb.AppendLine($"// Detected user JsonSerializerContext: {fullClassName}");
        sb.AppendLine();

        if (missingTypes.Count > 0)
        {
            sb.AppendLine("// ============================================================================");
            sb.AppendLine("// MISSING TYPES - Add these [JsonSerializable] attributes to your context:");
            sb.AppendLine("// ============================================================================");
            sb.AppendLine("//");
            foreach (var type in missingTypes.Distinct())
            {
                var displayType = TypeNameHelper.StripGlobalPrefix(type);
                sb.AppendLine($"// [JsonSerializable(typeof({displayType}))]");
            }

            sb.AppendLine("//");
        }
        else
        {
            sb.AppendLine("// All required types are registered in your JsonSerializerContext.");
        }

        if (!userContext.HasCamelCasePolicy)
        {
            sb.AppendLine();
            sb.AppendLine("// ============================================================================");
            sb.AppendLine("// RECOMMENDED - Add CamelCase policy for web API compatibility:");
            sb.AppendLine("// ============================================================================");
            sb.AppendLine("//");
            sb.AppendLine("// [JsonSourceGenerationOptions(");
            sb.AppendLine("//     PropertyNamingPolicy = JsonKnownNamingPolicy.CamelCase,");
            sb.AppendLine("//     DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull)]");
            sb.AppendLine("//");
        }

        // Use same filename as full context to ensure replacement (no stale file issues)
        spc.AddSource("ErrorOrJsonContext.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private static void EmitSupportMethods(StringBuilder code)
    {
        code.AppendLine(
            "        private static bool TryGetRouteValue(HttpContext ctx, string name, out string? value)");
        code.AppendLine("        {");
        code.AppendLine(
            "            if (!ctx.Request.RouteValues.TryGetValue(name, out var raw) || raw is null) { value = null; return false; }");
        code.AppendLine("            value = raw.ToString(); return value is not null;");
        code.AppendLine("        }");
        code.AppendLine();
        code.AppendLine(
            "        private static bool TryGetQueryValue(HttpContext ctx, string name, out string? value)");
        code.AppendLine("        {");
        code.AppendLine(
            "            if (!ctx.Request.Query.TryGetValue(name, out var raw) || raw.Count is 0) { value = null; return false; }");
        code.AppendLine("            value = raw.ToString(); return value is not null;");
        code.AppendLine("        }");
        code.AppendLine();
        code.AppendLine(
            $"        private static {WellKnownTypes.Fqn.Result} ToProblem({WellKnownTypes.Fqn.ReadOnlyList}<{WellKnownTypes.Fqn.Error}> errors)");
        code.AppendLine("        {");
        code.AppendLine($"            if (errors.Count is 0) return {WellKnownTypes.Fqn.TypedResults.Problem}();");
        code.AppendLine("            var hasValidation = false;");
        code.AppendLine(
            $"            for (var i = 0; i < errors.Count; i++) if (errors[i].Type == {WellKnownTypes.Fqn.ErrorType}.Validation) {{ hasValidation = true; break; }}");
        code.AppendLine("            if (hasValidation)");
        code.AppendLine("            {");
        code.AppendLine($"                var dict = new {WellKnownTypes.Fqn.Dictionary}<string, string[]>();");
        code.AppendLine("                for (var i = 0; i < errors.Count; i++)");
        code.AppendLine("                {");
        code.AppendLine(
            $"                    var e = errors[i]; if (e.Type != {WellKnownTypes.Fqn.ErrorType}.Validation) continue;");
        code.AppendLine(
            "                    if (!dict.TryGetValue(e.Code, out var existing)) dict[e.Code] = new[] { e.Description };");
        code.AppendLine(
            "                    else { var n = new string[existing.Length + 1]; existing.CopyTo(n, 0); n[existing.Length] = e.Description; dict[e.Code] = n; }");
        code.AppendLine("                }");
        code.AppendLine($"                return {WellKnownTypes.Fqn.TypedResults.ValidationProblem}(dict);");
        code.AppendLine("            }");
        code.AppendLine("            var first = errors[0];");
        code.AppendLine($"            var problem = new {WellKnownTypes.Fqn.ProblemDetails}");
        code.AppendLine("            {");
        code.AppendLine("                Title = first.Code,");
        code.AppendLine("                Detail = first.Description,");
        code.AppendLine(
            $"                Status = first.Type switch {{ {ErrorMapping.GenerateStatusSwitch(WellKnownTypes.Fqn.ErrorType)} }}");
        code.AppendLine("            };");
        code.AppendLine("            problem.Type = $\"https://httpstatuses.io/{problem.Status}\";");
        code.AppendLine("            return problem.Status switch");
        code.AppendLine("            {");
        foreach (var caseExpr in ErrorMapping.GenerateStatusToFactoryCases())
            code.AppendLine($"                {caseExpr},");
        code.AppendLine($"                _ => {ErrorMapping.GetDefaultProblemFactory()}");
        code.AppendLine("            };");
        code.AppendLine("        }");
    }

    private static string BuildArgumentExpression(in EndpointParameter param, string paramName)
    {
        return param.Source switch
        {
            EndpointParameterSource.Body when !param.IsNullable => paramName + "!",
            EndpointParameterSource.Route when param is { IsNullable: false, IsNonNullableValueType: false } =>
                paramName + "!",
            EndpointParameterSource.Query when param is { IsNullable: false, IsNonNullableValueType: true } =>
                paramName + ".Value",
            EndpointParameterSource.Header when param is { IsNullable: false, IsNonNullableValueType: true } =>
                paramName + ".Value",
            EndpointParameterSource.Query when param is { IsNullable: false, IsNonNullableValueType: false } =>
                paramName + "!",
            EndpointParameterSource.Header when param is { IsNullable: false, IsNonNullableValueType: false } =>
                paramName + "!",
            _ => paramName
        };
    }

    private static string GetTryParseExpression(string typeFqn, string rawName, string outputName,
        CustomBindingMethod customBinding = CustomBindingMethod.None)
    {
        if (customBinding is CustomBindingMethod.TryParse or CustomBindingMethod.TryParseWithFormat)
        {
            var baseType = typeFqn.TrimEnd('?');
            return $"{baseType}.TryParse({rawName}, out var {outputName})";
        }

        var normalized = typeFqn.Replace("global::", "").TrimEnd('?');
        return normalized switch
        {
            "System.Int32" or "int" => $"int.TryParse({rawName}, out var {outputName})",
            "System.Int64" or "long" => $"long.TryParse({rawName}, out var {outputName})",
            "System.Int16" or "short" => $"short.TryParse({rawName}, out var {outputName})",
            "System.Byte" or "byte" => $"byte.TryParse({rawName}, out var {outputName})",
            "System.SByte" or "sbyte" => $"sbyte.TryParse({rawName}, out var {outputName})",
            "System.UInt16" or "ushort" => $"ushort.TryParse({rawName}, out var {outputName})",
            "System.UInt32" or "uint" => $"uint.TryParse({rawName}, out var {outputName})",
            "System.UInt64" or "ulong" => $"ulong.TryParse({rawName}, out var {outputName})",
            "System.Boolean" or "bool" => $"bool.TryParse({rawName}, out var {outputName})",
            "System.Guid" => $"global::System.Guid.TryParse({rawName}, out var {outputName})",
            "System.DateTime" => $"global::System.DateTime.TryParse({rawName}, out var {outputName})",
            "System.DateTimeOffset" => $"global::System.DateTimeOffset.TryParse({rawName}, out var {outputName})",
            "System.TimeSpan" => $"global::System.TimeSpan.TryParse({rawName}, out var {outputName})",
            "System.DateOnly" => $"global::System.DateOnly.TryParse({rawName}, out var {outputName})",
            "System.TimeOnly" => $"global::System.TimeOnly.TryParse({rawName}, out var {outputName})",
            "System.Double" or "double" => $"double.TryParse({rawName}, out var {outputName})",
            "System.Single" or "float" => $"float.TryParse({rawName}, out var {outputName})",
            "System.Decimal" or "decimal" => $"decimal.TryParse({rawName}, out var {outputName})",
            _ => "false"
        };
    }

    private static bool HasFormParams(in EndpointDescriptor ep)
    {
        return ep.HandlerParameters.AsImmutableArray().Any(static p =>
            p.Source is EndpointParameterSource.Form or EndpointParameterSource.FormFile
                or EndpointParameterSource.FormFiles or EndpointParameterSource.FormCollection);
    }

    private static ImmutableArray<EndpointDescriptor> SortEndpoints(ImmutableArray<EndpointDescriptor> endpoints)
    {
        var list = new EndpointDescriptor[endpoints.Length];
        endpoints.CopyTo(list);
        Array.Sort(list, static (a, b) =>
        {
            var c = string.CompareOrdinal(a.HttpMethod, b.HttpMethod);
            if (c is not 0) return c;
            c = string.CompareOrdinal(a.Pattern, b.Pattern);
            return c is not 0 ? c : string.CompareOrdinal(a.HandlerMethodName, b.HandlerMethodName);
        });
        return [.. list];
    }

    private static List<string> CollectJsonTypes(ImmutableArray<EndpointDescriptor> endpoints)
    {
        var types = new HashSet<string>(StringComparer.Ordinal);
        foreach (var ep in endpoints)
        {
            foreach (var p in ep.HandlerParameters)
                if (p.Source == EndpointParameterSource.Body)
                    types.Add(p.TypeFqn);

            if (ep is { IsSse: true, SseItemTypeFqn: not null })
            {
                types.Add(ep.SseItemTypeFqn);
            }
            else
            {
                var successInfo = ResultsUnionTypeBuilder.GetSuccessResponseInfo(
                    ep.SuccessTypeFqn,
                    ep.SuccessKind,
                    ep.HttpMethod,
                    ep.IsAcceptedResponse);
                if (successInfo.HasBody)
                    types.Add(ep.SuccessTypeFqn);
            }
        }

        var sorted = types.ToList();
        sorted.Sort(StringComparer.Ordinal);
        return sorted;
    }
}