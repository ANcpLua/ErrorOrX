using System.Collections.Immutable;
using System.Text;
using ErrorOr.Analyzers;
using ErrorOr.Generators.Emitters;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace ErrorOr.Generators;

/// <summary>
///     Code emission logic for endpoint mappings.
/// </summary>
public sealed partial class ErrorOrEndpointGenerator
{
    internal static void EmitEndpoints(SourceProductionContext spc, ImmutableArray<EndpointDescriptor> endpoints,
        ImmutableArray<JsonContextInfo> userContexts, int maxArity = 6, bool generateJsonContext = true)
    {
        var sorted = SortEndpoints(endpoints);
        var jsonTypes = CollectJsonTypes(sorted);

        EmitGlobalUsings(spc);
        EmitOptionsClass(spc);
        EmitMappings(spc, sorted, jsonTypes.Count > 0, maxArity);

        if (jsonTypes.Count > 0 && generateJsonContext)
            EmitJsonContext(spc, jsonTypes, userContexts);
    }

    private static void EmitGlobalUsings(SourceProductionContext spc)
    {
        const string source = """
                              // <auto-generated/>
                              global using ErrorOr.Generated;
                              """;
        spc.AddSource("ErrorOrEndpoints.GlobalUsings.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private static void EmitMappings(SourceProductionContext spc, ImmutableArray<EndpointDescriptor> endpoints,
        bool hasJsonTypes, int maxArity)
    {
        var code = new StringBuilder();
        code.AppendLine(GeneratedCodeHelpers.AutoGeneratedHeader("ErrorOr.Generators"));
        code.AppendLine(GeneratedCodeHelpers.NullableEnable);
        code.AppendLine("using System;");
        code.AppendLine("using System.Linq;");
        code.AppendLine("using System.Threading.Tasks;");
        code.AppendLine("using Microsoft.AspNetCore.Builder;");
        code.AppendLine("using Microsoft.AspNetCore.Http;");
        code.AppendLine("using Microsoft.AspNetCore.Routing;");
        code.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        code.AppendLine();
        code.AppendLine("namespace ErrorOr.Generated");
        code.AppendLine("{");
        code.AppendLine("    /// <summary>");
        code.AppendLine("    /// Generated endpoint mappings for all [ErrorOrEndpoint] handlers in this assembly.");
        code.AppendLine("    /// </summary>");
        code.AppendLine("    public static class ErrorOrEndpointMappings");
        code.AppendLine("    {");
        code.AppendLine("        /// <summary>");
        code.AppendLine("        /// Maps all ErrorOr endpoints to the application's routing table.");
        code.AppendLine("        /// </summary>");
        code.AppendLine("        /// <param name=\"app\">The endpoint route builder to add mappings to.</param>");
        code.AppendLine(
            "        /// <returns>A convention builder for applying global conventions to all endpoints.</returns>");
        code.AppendLine("        /// <exception cref=\"InvalidOperationException\">");
        code.AppendLine("        /// Thrown when AddErrorOrEndpoints() was not called during service registration.");
        code.AppendLine("        /// </exception>");
        code.AppendLine("        /// <remarks>");
        code.AppendLine("        /// This follows ASP.NET Core's convention builder pattern, enabling global");
        code.AppendLine("        /// endpoint configuration like RequireAuthorization() or RequireRateLimiting().");
        code.AppendLine("        /// </remarks>");
        code.AppendLine("        /// <example>");
        code.AppendLine("        /// <code>");
        code.AppendLine("        /// app.MapErrorOrEndpoints()");
        code.AppendLine("        ///    .RequireAuthorization()");
        code.AppendLine("        ///    .RequireRateLimiting(\"api\");");
        code.AppendLine("        /// </code>");
        code.AppendLine("        /// </example>");
        code.AppendLine(
            "        public static IEndpointConventionBuilder MapErrorOrEndpoints(this IEndpointRouteBuilder app)");
        code.AppendLine("        {");
        code.AppendLine(
            "            // The (Delegate) cast forces the Delegate overload of MapGet/MapPost/etc.,");
        code.AppendLine(
            "            // which uses reflection internally. This is safe because the generator controls");
        code.AppendLine(
            "            // all delegate signatures and parameter binding at compile time.");
        code.AppendLine("#pragma warning disable IL2026, IL3050");
        code.AppendLine("            // Validate that AddErrorOrEndpoints() was called");
        code.AppendLine("            var marker = app.ServiceProvider.GetService<ErrorOrEndpointsMarkerService>();");
        code.AppendLine("            if (marker is null)");
        code.AppendLine("            {");
        code.AppendLine("                throw new InvalidOperationException(");
        code.AppendLine("                    \"Unable to find the required services. \" +");
        code.AppendLine(
            "                    \"Please add all the required services by calling 'IServiceCollection.AddErrorOrEndpoints()' \" +");
        code.AppendLine("                    \"in the application startup code.\");");
        code.AppendLine("            }");
        code.AppendLine();
        code.AppendLine(
            "            var __endpointBuilders = new System.Collections.Generic.List<IEndpointConventionBuilder>();");
        code.AppendLine();

        // Group endpoints by [RouteGroup] attribute
        var grouping = GroupAggregator.GroupEndpoints(endpoints);

        // Compute global version set for ungrouped endpoints (grouped endpoints use their own version sets)
        var ungroupedEndpoints = grouping.UngroupedEndpoints
            .Select(static ie => ie.Endpoint)
            .ToImmutableArray();
        var ungroupedVersionSet = ComputeGlobalVersionSet(ungroupedEndpoints);
        if (ungroupedVersionSet.HasVersioning && !ungroupedEndpoints.IsDefaultOrEmpty)
            EmitVersionSet(code, ungroupedVersionSet);

        // Emit route group declarations (eShop-style NewVersionedApi + MapGroup)
        var groupContexts = GroupEmitter.EmitGroupDeclarations(code, grouping.Groups);

        // Emit grouped endpoint mappings
        foreach (var ctx in groupContexts)
        {
            foreach (var indexed in ctx.Group.Endpoints)
                GroupEmitter.EmitGroupedMapCall(code, in indexed, ctx.GroupVariableName, maxArity);
        }

        // Emit ungrouped endpoint mappings (legacy pattern)
        foreach (var indexed in grouping.UngroupedEndpoints)
            EmitMapCall(code, indexed.Endpoint, indexed.OriginalIndex, maxArity, ungroupedVersionSet.HasVersioning);

        code.AppendLine("#pragma warning restore IL2026, IL3050");
        code.AppendLine();
        code.AppendLine("            return new CompositeEndpointConventionBuilder(__endpointBuilders);");
        code.AppendLine("        }");
        code.AppendLine();

        if (hasJsonTypes)
            EmitJsonConfigExtension(code);

        // Emit invokers for ALL endpoints (grouped and ungrouped)
        for (var i = 0; i < endpoints.Length; i++)
            EmitInvoker(code, endpoints[i], i, maxArity);

        EmitSupportMethods(code);
        code.AppendLine("    }");
        code.AppendLine("}");

        spc.AddSource("ErrorOrEndpointMappings.cs", SourceText.From(code.ToString(), Encoding.UTF8));
    }

    private static void EmitMapCall(StringBuilder code, in EndpointDescriptor ep, int index, int maxArity,
        bool hasGlobalVersionSet = false)
    {
        code.AppendLine(
            $"            // {ep.HttpMethod} {ep.Pattern} -> {ep.HandlerContainingTypeFqn}.{ep.HandlerMethodName}");
        var mapMethod = Emit.MapMethod(ep.HttpMethod);

        // Cast to Delegate to force the Delegate overload of MapGet/MapPost/etc.
        // Without this cast, the compiler selects the RequestDelegate overload
        // (since Func<HttpContext, Task<T>> is also Func<HttpContext, Task>),
        // which bypasses RequestDelegateFactory and makes endpoints invisible to OpenAPI.
        code.AppendLine(mapMethod == "MapMethods"
            ? $"            var __ep{index} = app.MapMethods(@\"{ep.Pattern}\", new[] {{ \"{ep.HttpMethod}\" }}, (Delegate)Invoke_Ep{index})"
            : $"            var __ep{index} = app.{mapMethod}(@\"{ep.Pattern}\", (Delegate)Invoke_Ep{index})");

        var (_, operationId) =
            EndpointNameHelper.GetEndpointIdentity(ep.HandlerContainingTypeFqn, ep.HandlerMethodName);

        code.AppendLine($"                .WithName(\"{operationId}\")");

        // Emit API versioning fluent calls
        EmitVersioningCalls(code, ep.Versioning, hasGlobalVersionSet);

        // Use shared metadata emitter for consistent output (tags, accepts, produces, middleware)
        EndpointMetadataEmitter.EmitEndpointMetadata(code, in ep, "                ", maxArity);

        code.AppendLine("                ;");
        code.AppendLine($"            __endpointBuilders.Add(__ep{index});");
        code.AppendLine();
    }

    /// <summary>
    ///     Computes the global version set from all endpoints.
    /// </summary>
    private static VersionSetContext ComputeGlobalVersionSet(ImmutableArray<EndpointDescriptor> endpoints)
    {
        var hasVersionNeutral = endpoints.Any(static ep => ep.Versioning.IsVersionNeutral);

        var sortedVersions = endpoints
            .SelectMany(static ep => ep.Versioning.SupportedVersions.AsImmutableArray())
            .Distinct()
            .OrderBy(static v => v.MajorVersion)
            .ThenBy(static v => v.MinorVersion ?? 0)
            .ToImmutableArray();

        return new VersionSetContext(sortedVersions, hasVersionNeutral);
    }

    /// <summary>
    ///     Emits the version set builder before endpoint mappings.
    /// </summary>
    private static void EmitVersionSet(StringBuilder code, VersionSetContext versionSet)
    {
        code.AppendLine("            // API Versioning: Build version set for all endpoints");
        code.AppendLine("            var versionSet = app.NewApiVersionSet()");

        foreach (var v in versionSet.AllVersions)
        {
            var versionExpr = v.MinorVersion.HasValue
                ? $"new {WellKnownTypes.Fqn.ApiVersion}({v.MajorVersion}, {v.MinorVersion.Value})"
                : $"new {WellKnownTypes.Fqn.ApiVersion}({v.MajorVersion})";

            code.AppendLine(v.IsDeprecated
                ? $"                .HasDeprecatedApiVersion({versionExpr})"
                : $"                .HasApiVersion({versionExpr})");
        }

        code.AppendLine("                .ReportApiVersions()");
        code.AppendLine("                .Build();");
        code.AppendLine();
    }

    /// <summary>
    ///     Emits API versioning fluent calls for an endpoint.
    /// </summary>
    private static void EmitVersioningCalls(StringBuilder code, in VersioningInfo versioning, bool hasGlobalVersionSet)
    {
        // If no global version set exists, don't emit anything
        if (!hasGlobalVersionSet)
            return;

        // Version-neutral endpoints don't map to any specific version
        if (versioning.IsVersionNeutral)
        {
            code.AppendLine("                .IsApiVersionNeutral()");
            return;
        }

        // Apply the version set to the endpoint
        code.AppendLine("                .WithApiVersionSet(versionSet)");

        // If endpoint has specific versions to map to, emit MapToApiVersion calls
        var effectiveVersions = versioning.EffectiveVersions;
        if (!effectiveVersions.IsDefaultOrEmpty)
        {
            foreach (var v in effectiveVersions.AsImmutableArray())
            {
                var versionExpr = v.MinorVersion.HasValue
                    ? $"new {WellKnownTypes.Fqn.ApiVersion}({v.MajorVersion}, {v.MinorVersion.Value})"
                    : $"new {WellKnownTypes.Fqn.ApiVersion}({v.MajorVersion})";
                code.AppendLine($"                .MapToApiVersion({versionExpr})");
            }
        }
    }

    private static InvokerContext ComputeInvokerContext(
        in EndpointDescriptor ep,
        int index,
        int maxArity)
    {
        var successInfo = ResultsUnionTypeBuilder.GetSuccessResponseInfo(
            ep.SuccessTypeFqn, ep.SuccessKind, ep.IsAcceptedResponse);

        var hasFormBinding = ep.HasFormParams;
        var hasBodyBinding = ep.HasBodyOrFormBinding;

        var unionResult = ResultsUnionTypeBuilder.ComputeReturnType(
            ep.SuccessTypeFqn, ep.SuccessKind,
            ep.InferredErrorTypeNames, ep.InferredCustomErrors,
            ep.DeclaredProducesErrors, hasBodyBinding, maxArity,
            ep.IsAcceptedResponse, ep.Middleware, ep.HasParameterValidation);

        var needsAwait = ep.IsAsync || hasBodyBinding || ep.HasBindAsyncParam;

        return new InvokerContext(successInfo, unionResult, hasFormBinding, hasBodyBinding, needsAwait, index);
    }

    private static (StringBuilder Code, bool UsesBindFail) EmitBodyCode(
        in EndpointDescriptor ep,
        in InvokerContext ctx)
    {
        var bodyCode = new StringBuilder();
        var usesBindFail = ctx.HasFormBinding;

        if (ctx.HasFormBinding)
            EmitFormContentTypeGuard(bodyCode);

        var args = new StringBuilder();
        var validationParams = new List<(int Index, string ParamName)>();
        for (var i = 0; i < ep.HandlerParameters.Length; i++)
        {
            var param = ep.HandlerParameters[i];
            usesBindFail |= EmitParameterBinding(bodyCode, in param, $"p{i}", "BindFail");
            if (i > 0) args.Append(", ");
            args.Append(BuildArgumentExpression(in param, $"p{i}"));

            if (param.RequiresValidation)
                validationParams.Add((i, $"p{i}"));
        }

        if (validationParams.Count > 0)
            EmitBclValidation(bodyCode, validationParams, ctx.UnionResult.ReturnTypeFqn, ctx.NeedsAwait);

        var awaitKeyword = ep.IsAsync ? "await " : "";
        bodyCode.AppendLine(
            $"            var result = {awaitKeyword}{ep.HandlerContainingTypeFqn}.{ep.HandlerMethodName}({args});");

        EmitErrorHandling(bodyCode, in ep, in ctx);

        return (bodyCode, usesBindFail);
    }

    private static void EmitErrorHandling(
        StringBuilder bodyCode,
        in EndpointDescriptor ep,
        in InvokerContext ctx)
    {
        if (ep.IsSse)
        {
            bodyCode.AppendLine(
                $"            if (result.IsError) return {ctx.WrapReturn("ToProblem(result.Errors)")};");
            bodyCode.AppendLine(
                $"            return {ctx.WrapReturn($"{WellKnownTypes.Fqn.TypedResults.ServerSentEvents}(result.Value)")};");
        }
        else if (ctx.UnionResult.CanUseUnion)
        {
            EmitUnionTypeErrorHandling(bodyCode, in ep, ctx.UnionResult.ReturnTypeFqn, ctx.SuccessInfo, ctx.NeedsAwait);
        }
        else
        {
            // Use minimal interface (IsError/Errors/Value) instead of convenience Match API
            var successFactory = GetSuccessFactoryWithLocation(in ep, ctx.SuccessInfo);
            bodyCode.AppendLine(
                $"            if (result.IsError) return {ctx.WrapReturn("ToProblem(result.Errors)")};");
            bodyCode.AppendLine($"            return {ctx.WrapReturn(successFactory)};");
        }
    }

    private static void EmitWrapperMethod(StringBuilder code, in InvokerContext ctx)
    {
        var returnType = ctx.UnionResult.ReturnTypeFqn;
        code.AppendLine($"        private static async Task<{returnType}> {ctx.WrapperName}(HttpContext ctx)");
        code.AppendLine("        {");
        code.AppendLine($"            return await {ctx.CoreName}(ctx);");
        code.AppendLine("        }");
        code.AppendLine();
    }

    private static void EmitCoreMethod(
        StringBuilder code,
        StringBuilder bodyCode,
        in InvokerContext ctx,
        bool usesBindFail)
    {
        var returnType = ctx.UnionResult.ReturnTypeFqn;
        code.AppendLine(
            ctx.NeedsAwait
                ? $"        private static async Task<{returnType}> {ctx.CoreName}(HttpContext ctx)"
                : $"        private static Task<{returnType}> {ctx.CoreName}(HttpContext ctx)");

        code.AppendLine("        {");

        if (usesBindFail)
            EmitBindFailHelper(code, returnType, ctx.NeedsAwait, ctx.UnionResult.UsesValidationProblemFor400);

        if (ctx.HasBodyBinding)
            EmitBindFail415Helper(code, returnType, ctx.NeedsAwait);

        code.Append(bodyCode);
        code.AppendLine("        }");
        code.AppendLine();
    }

    private static void EmitInvoker(StringBuilder code, in EndpointDescriptor ep, int index, int maxArity)
    {
        var ctx = ComputeInvokerContext(in ep, index, maxArity);
        var (bodyCode, usesBindFail) = EmitBodyCode(in ep, in ctx);

        EmitWrapperMethod(code, in ctx);
        EmitCoreMethod(code, bodyCode, in ctx, usesBindFail);
    }

    /// <summary>
    ///     Emits BCL validation calls for parameters that have ValidationAttribute or implement IValidatableObject.
    ///     Uses System.ComponentModel.DataAnnotations.Validator.TryValidateObject for validation.
    /// </summary>
    private static void EmitBclValidation(StringBuilder code, List<(int Index, string ParamName)> validationParams,
        string returnTypeFqn, bool isAsync)
    {
        code.AppendLine();
        code.AppendLine("            // BCL Validation");

        foreach (var (_, paramName) in validationParams)
        {
            code.AppendLine(
                $"            var {paramName}ValidationResults = new {WellKnownTypes.Fqn.List}<{WellKnownTypes.Fqn.ValidationResult}>();");
            code.AppendLine(
                $"            if (!{WellKnownTypes.Fqn.Validator}.TryValidateObject({paramName}!, new {WellKnownTypes.Fqn.ValidationContext}({paramName}!), {paramName}ValidationResults, validateAllProperties: true))");
            code.AppendLine("            {");
            BindingCodeEmitter.EmitValidationDictBuilder(
                code, 16, "validationDict", $"{paramName}ValidationResults", "vr",
                "key", "vr.ErrorMessage ?? \"\"",
                keyVarDecl: "var key = vr.MemberNames.FirstOrDefault() ?? \"\";");

            var returnExpr = isAsync
                ? $"{WellKnownTypes.Fqn.TypedResults.ValidationProblem}(validationDict)"
                : $"Task.FromResult<{returnTypeFqn}>({WellKnownTypes.Fqn.TypedResults.ValidationProblem}(validationDict))";
            code.AppendLine($"                return {returnExpr};");
            code.AppendLine("            }");
        }

        code.AppendLine();
    }

    private static void EmitBindFailHelper(StringBuilder code, string returnTypeFqn, bool isAsync,
        bool useValidationProblem)
    {
        var returnType = isAsync ? returnTypeFqn : $"Task<{returnTypeFqn}>";

        if (useValidationProblem)
        {
            // Use ValidationProblem to match the Results<..., ValidationProblem, ...> union type
            const string validationProblemExpr =
                $"{WellKnownTypes.Fqn.TypedResults.ValidationProblem}(new {WellKnownTypes.Fqn.Dictionary}<string, string[]> {{ [param] = [reason] }})";
            var returnExpr =
                isAsync ? validationProblemExpr : $"Task.FromResult<{returnTypeFqn}>({validationProblemExpr})";

            code.AppendLine($"            static {returnType} BindFail(string param, string reason)");
            code.AppendLine($"                => {returnExpr};");
            code.AppendLine();
        }
        else
        {
            // Use BadRequest<ProblemDetails> to match the Results<..., BadRequest<ProblemDetails>, ...> union type
            code.AppendLine(
                $"            static {WellKnownTypes.Fqn.ProblemDetails} CreateBindProblem(string param, string reason) => new()");
            code.AppendLine("            {");
            code.AppendLine("                Title = \"Bad Request\",");
            code.AppendLine("                Detail = $\"Parameter '{param}' {reason}.\",");
            code.AppendLine("                Status = 400,");
            code.AppendLine($"                Type = \"{WellKnownTypes.Constants.HttpStatusesBaseUrl}400\",");
            code.AppendLine("            };");
            code.AppendLine();

            const string badRequestExpr =
                $"{WellKnownTypes.Fqn.TypedResults.BadRequest}(CreateBindProblem(param, reason))";
            var returnExpr = isAsync ? badRequestExpr : $"Task.FromResult<{returnTypeFqn}>({badRequestExpr})";

            code.AppendLine($"            static {returnType} BindFail(string param, string reason)");
            code.AppendLine($"                => {returnExpr};");
            code.AppendLine();
        }
    }

    private static void EmitBindFail415Helper(StringBuilder code, string returnTypeFqn, bool isAsync)
    {
        const string expr = $"{WellKnownTypes.Fqn.TypedResults.StatusCode}(415)";
        var returnExpr = isAsync ? expr : $"Task.FromResult<{returnTypeFqn}>({expr})";
        var returnType = isAsync ? returnTypeFqn : $"Task<{returnTypeFqn}>";

        code.AppendLine($"            static {returnType} BindFail415()");
        code.AppendLine($"                => {returnExpr};");
        code.AppendLine();
    }

    private static void EmitUnionTypeErrorHandling(
        StringBuilder code,
        in EndpointDescriptor ep,
        string returnType,
        SuccessResponseInfo successInfo,
        bool needsAwait)
    {
        code.AppendLine("            if (result.IsError)");
        code.AppendLine("            {");
        // Guard against empty errors list (defensive - shouldn't happen but prevents IndexOutOfRange)
        // Use InternalServerError<ProblemDetails> to match the Results<...> union type
        code.AppendLine(
            $"                if (result.Errors.Count is 0) return {WrapReturn($"{WellKnownTypes.Fqn.TypedResults.InternalServerError}(new {WellKnownTypes.Fqn.ProblemDetails} {{ Title = \"Error\", Detail = \"An error occurred but no details were provided.\", Status = 500 }})")};");
        code.AppendLine("                var first = result.Errors[0];");

        EmitValidationHandling(code, in ep, WrapReturn);
        EmitProblemDetailsBuilding(code);
        EmitErrorTypeSwitch(code, in ep, WrapReturn);

        code.AppendLine("            }");
        code.AppendLine();

        // Generate Location header for POST endpoints with Created response and Id property
        var successFactory = GetSuccessFactoryWithLocation(in ep, successInfo);
        code.AppendLine($"            return {WrapReturn(successFactory)};");
        return;

        string WrapReturn(string expr)
        {
            return needsAwait ? expr : $"Task.FromResult<{returnType}>({expr})";
        }
    }

    /// <summary>
    ///     Returns the appropriate success factory, with Location header support for Created responses.
    /// </summary>
    private static string GetSuccessFactoryWithLocation(in EndpointDescriptor ep, SuccessResponseInfo successInfo)
    {
        // Only apply Location header for POST endpoints returning Created with an Id property
        if (ep.HttpMethod != WellKnownTypes.HttpMethod.Post)
            return successInfo.Factory;

        if (successInfo.StatusCode != 201)
            return successInfo.Factory;

        // Location header requires both a body (with the Id value) and a detected Id property
        if (!successInfo.HasBody)
            return successInfo.Factory;

        return ep.LocationIdPropertyName is not { Length: > 0 } idProp
            ? successInfo.Factory
            :
            // Generate Location URL: request path + "/" + id value
            // For POST /api/users with response { Id: 123 }, Location becomes /api/users/123
            $"{WellKnownTypes.Fqn.TypedResults.Created}($\"{{ctx.Request.Path}}/{{result.Value.{idProp}}}\", result.Value)";
    }

    private static void EmitValidationHandling(StringBuilder code, in EndpointDescriptor ep,
        Func<string, string> wrapReturn)
    {
        var hasValidation = !ep.InferredErrorTypeNames.IsDefaultOrEmpty &&
                            ep.InferredErrorTypeNames.AsImmutableArray().Contains(ErrorMapping.Validation);

        if (!hasValidation) return;

        code.AppendLine($"                if (first.Type == {WellKnownTypes.Fqn.ErrorType}.Validation)");
        code.AppendLine("                {");
        BindingCodeEmitter.EmitValidationDictBuilder(
            code, 20, "validationDict", "result.Errors", "e",
            "e.Code", "e.Description",
            $"e.Type != {WellKnownTypes.Fqn.ErrorType}.Validation");
        code.AppendLine(
            $"                    return {wrapReturn($"{WellKnownTypes.Fqn.TypedResults.ValidationProblem}(validationDict)")};");
        code.AppendLine("                }");
    }

    private static void EmitProblemDetailsBuilding(StringBuilder code)
    {
        code.AppendLine($"                var problem = new {WellKnownTypes.Fqn.ProblemDetails}");
        code.AppendLine("                {");
        code.AppendLine("                    Title = first.Code,");
        code.AppendLine("                    Detail = first.Description,");
        code.AppendLine(
            $"                    Status = first.Type switch {{ {ErrorMapping.GenerateStatusSwitch(WellKnownTypes.Fqn.ErrorType)} }}");
        code.AppendLine("                };");
        code.AppendLine("                problem.Type = $\"https://httpstatuses.io/{problem.Status}\";");
        code.AppendLine();
    }

    private static void EmitErrorTypeSwitch(StringBuilder code, in EndpointDescriptor ep,
        Func<string, string> wrapReturn)
    {
        code.AppendLine("                switch (first.Type)");
        code.AppendLine("                {");

        if (!ep.InferredErrorTypeNames.IsDefaultOrEmpty)
        {
            foreach (var errorTypeName in ep.InferredErrorTypeNames.AsImmutableArray()
                         .Where(static e => e != ErrorMapping.Validation)
                         .Distinct()
                         .OrderBy(static x => x, StringComparer.Ordinal))
            {
                var factory = ErrorMapping.GetFactory(errorTypeName);

                code.AppendLine($"                    case {WellKnownTypes.Fqn.ErrorType}.{errorTypeName}:");
                code.AppendLine($"                        return {wrapReturn(factory)};");
            }
        }

        code.AppendLine("                    default:");
        code.AppendLine($"                        return {wrapReturn(ErrorMapping.GetFactory(ErrorMapping.Failure))};");
        code.AppendLine("                }");
    }

    /// <summary>
    ///     Delegates to <see cref="BindingCodeEmitter.EmitParameterBinding" /> for parameter binding code emission.
    /// </summary>
    private static bool EmitParameterBinding(StringBuilder code, in EndpointParameter param, string paramName,
        string bindFailFn)
    {
        return BindingCodeEmitter.EmitParameterBinding(code, in param, paramName, bindFailFn);
    }

    private static void EmitFormContentTypeGuard(StringBuilder code)
    {
        code.AppendLine(
            "            if (!ctx.Request.HasFormContentType) return BindFail415();");
        code.AppendLine("            var form = await ctx.Request.ReadFormAsync(ctx.RequestAborted);");
        code.AppendLine();
    }

    private static void EmitJsonConfigExtension(StringBuilder code)
    {
        // Emit fluent builder: AddErrorOrEndpoints() returns IErrorOrEndpointsBuilder
        code.AppendLine("        /// <summary>");
        code.AppendLine("        /// Registers ErrorOr endpoint services and returns a builder for configuration.");
        code.AppendLine("        /// </summary>");
        code.AppendLine("        /// <param name=\"services\">The service collection to configure.</param>");
        code.AppendLine("        /// <returns>A builder for further configuration.</returns>");
        code.AppendLine("        /// <remarks>");
        code.AppendLine("        /// This follows ASP.NET Core's builder pattern (like AddRazorComponents())");
        code.AppendLine("        /// enabling fluent extension method chaining without callback nesting.");
        code.AppendLine("        /// </remarks>");
        code.AppendLine("        /// <example>");
        code.AppendLine("        /// <code>");
        code.AppendLine("        /// builder.Services.AddErrorOrEndpoints()");
        code.AppendLine("        ///     .UseJsonContext&lt;AppJsonSerializerContext&gt;()");
        code.AppendLine("        ///     .WithCamelCase()");
        code.AppendLine("        ///     .WithIgnoreNulls();");
        code.AppendLine("        /// </code>");
        code.AppendLine("        /// </example>");
        code.AppendLine(
            "        public static IErrorOrEndpointsBuilder AddErrorOrEndpoints(this IServiceCollection services)");
        code.AppendLine("        {");
        code.AppendLine("            // Register marker service for validation in MapErrorOrEndpoints()");
        code.AppendLine("            services.AddSingleton<ErrorOrEndpointsMarkerService>();");
        code.AppendLine("            return new ErrorOrEndpointsBuilder(services);");
        code.AppendLine("        }");
        code.AppendLine();
    }

    private static void EmitOptionsClass(SourceProductionContext spc)
    {
        const string source = """
                              // <auto-generated>
                              // This file was generated by ErrorOr.Generators source generator.
                              // </auto-generated>

                              #nullable enable

                              namespace ErrorOr.Generated
                              {
                                  /// <summary>
                                  /// Marker service to verify that AddErrorOrEndpoints() was called.
                                  /// </summary>
                                  /// <remarks>
                                  /// This follows the ASP.NET Core pattern used by RazorComponentsMarkerService
                                  /// to provide clear error messages when the service registration is missing.
                                  /// </remarks>
                                  internal sealed class ErrorOrEndpointsMarkerService { }

                                  /// <summary>
                                  /// Builder interface for configuring ErrorOr endpoints.
                                  /// </summary>
                                  /// <remarks>
                                  /// This pattern follows ASP.NET Core's IRazorComponentsBuilder design,
                                  /// enabling fluent extension method chaining without callback nesting.
                                  /// </remarks>
                                  public interface IErrorOrEndpointsBuilder
                                  {
                                      /// <summary>
                                      /// Gets the service collection being configured.
                                      /// </summary>
                                      global::Microsoft.Extensions.DependencyInjection.IServiceCollection Services { get; }
                                  }

                                  /// <summary>
                                  /// Default implementation of <see cref="IErrorOrEndpointsBuilder"/>.
                                  /// </summary>
                                  internal sealed class ErrorOrEndpointsBuilder : IErrorOrEndpointsBuilder
                                  {
                                      public ErrorOrEndpointsBuilder(global::Microsoft.Extensions.DependencyInjection.IServiceCollection services)
                                      {
                                          Services = services;
                                      }

                                      public global::Microsoft.Extensions.DependencyInjection.IServiceCollection Services { get; }
                                  }

                                  /// <summary>
                                  /// Extension methods for <see cref="IErrorOrEndpointsBuilder"/>.
                                  /// </summary>
                                  public static class ErrorOrEndpointsBuilderExtensions
                                  {
                                      /// <summary>
                                      /// Registers a JsonSerializerContext for AOT-compatible JSON serialization.
                                      /// </summary>
                                      /// <typeparam name="TContext">The JsonSerializerContext type.</typeparam>
                                      /// <param name="builder">The builder instance.</param>
                                      /// <returns>The builder instance for chaining.</returns>
                                      public static IErrorOrEndpointsBuilder UseJsonContext<TContext>(this IErrorOrEndpointsBuilder builder)
                                          where TContext : global::System.Text.Json.Serialization.JsonSerializerContext, new()
                                      {
                                          builder.Services.ConfigureHttpJsonOptions(options =>
                                          {
                                              options.SerializerOptions.TypeInfoResolverChain.Insert(0, new TContext());
                                          });
                                          return builder;
                                      }

                                      /// <summary>
                                      /// Uses camelCase for JSON property names.
                                      /// </summary>
                                      /// <param name="builder">The builder instance.</param>
                                      /// <param name="enabled">Whether to enable camelCase (default: true).</param>
                                      /// <returns>The builder instance for chaining.</returns>
                                      public static IErrorOrEndpointsBuilder WithCamelCase(this IErrorOrEndpointsBuilder builder, bool enabled = true)
                                      {
                                          if (enabled)
                                          {
                                              builder.Services.ConfigureHttpJsonOptions(options =>
                                              {
                                                  options.SerializerOptions.PropertyNamingPolicy = global::System.Text.Json.JsonNamingPolicy.CamelCase;
                                              });
                                          }
                                          return builder;
                                      }

                                      /// <summary>
                                      /// Ignores null values when serializing JSON.
                                      /// </summary>
                                      /// <param name="builder">The builder instance.</param>
                                      /// <param name="enabled">Whether to ignore nulls (default: true).</param>
                                      /// <returns>The builder instance for chaining.</returns>
                                      public static IErrorOrEndpointsBuilder WithIgnoreNulls(this IErrorOrEndpointsBuilder builder, bool enabled = true)
                                      {
                                          if (enabled)
                                          {
                                              builder.Services.ConfigureHttpJsonOptions(options =>
                                              {
                                                  options.SerializerOptions.DefaultIgnoreCondition = global::System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull;
                                              });
                                          }
                                          return builder;
                                      }
                                  }

                                  /// <summary>
                                  /// Composite convention builder that applies conventions to multiple endpoints.
                                  /// </summary>
                                  /// <remarks>
                                  /// This follows the ASP.NET Core pattern for applying global conventions
                                  /// to all endpoints registered by MapErrorOrEndpoints().
                                  /// </remarks>
                                  internal sealed class CompositeEndpointConventionBuilder : global::Microsoft.AspNetCore.Builder.IEndpointConventionBuilder
                                  {
                                      private readonly global::System.Collections.Generic.List<global::Microsoft.AspNetCore.Builder.IEndpointConventionBuilder> _builders;

                                      public CompositeEndpointConventionBuilder(global::System.Collections.Generic.List<global::Microsoft.AspNetCore.Builder.IEndpointConventionBuilder> builders)
                                      {
                                          _builders = builders;
                                      }

                                      public void Add(global::System.Action<global::Microsoft.AspNetCore.Builder.EndpointBuilder> convention)
                                      {
                                          foreach (var builder in _builders)
                                          {
                                              builder.Add(convention);
                                          }
                                      }

                                      public void Finally(global::System.Action<global::Microsoft.AspNetCore.Builder.EndpointBuilder> finallyConvention)
                                      {
                                          foreach (var builder in _builders)
                                          {
                                              builder.Finally(finallyConvention);
                                          }
                                      }
                                  }
                              }
                              """;
        spc.AddSource("ErrorOrEndpointOptions.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private static void EmitJsonContext(SourceProductionContext spc, List<string> jsonTypes,
        ImmutableArray<JsonContextInfo> userContexts)
    {
        // If user has their own JsonSerializerContext, emit a helper file instead
        if (userContexts is { IsDefaultOrEmpty: false, Length: > 0 })
        {
            EmitJsonContextHelper(spc, jsonTypes, userContexts);
            return;
        }

        // No user context - emit full ErrorOrJsonContext using IndentedStringBuilder
        var sb = new IndentedStringBuilder();
        sb.AppendLine(GeneratedCodeHelpers.AutoGeneratedHeader("ErrorOr.Generators"));
        sb.AppendLine("// JSON serialization context for Native AOT support.");
        sb.AppendLine(GeneratedCodeHelpers.NullableEnable);
        sb.AppendLine();
        sb.AppendLine(
            "[System.Text.Json.Serialization.JsonSourceGenerationOptions(DefaultIgnoreCondition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull)]");
        foreach (var type in jsonTypes)
            sb.AppendLine($"[System.Text.Json.Serialization.JsonSerializable(typeof({type}))]");
        sb.AppendLine(
            $"[System.Text.Json.Serialization.JsonSerializable(typeof({WellKnownTypes.Fqn.ProblemDetails}))]");
        sb.AppendLine(
            $"[System.Text.Json.Serialization.JsonSerializable(typeof({WellKnownTypes.Fqn.HttpValidationProblemDetails}))]");
        sb.AppendLine(
            "internal partial class ErrorOrJsonContext : System.Text.Json.Serialization.JsonSerializerContext { }");
        spc.AddSource("ErrorOrJsonContext.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private static void EmitJsonContextHelper(SourceProductionContext spc, List<string> jsonTypes,
        ImmutableArray<JsonContextInfo> userContexts)
    {
        var userContext = userContexts[0]; // Use first context found
        var fullClassName = userContext.Namespace is not null
            ? $"{userContext.Namespace}.{userContext.ClassName}"
            : userContext.ClassName;

        // Collect registered types from user context
        var registeredTypes = new HashSet<string>();
        foreach (var ctx in userContexts)
        {
            foreach (var typeFqn in ctx.SerializableTypes)
                registeredTypes.Add(typeFqn);
        }

        // Find missing types
        var missingTypes = new List<string>();

        // Check endpoint types
        foreach (var type in jsonTypes)
        {
            if (!registeredTypes.Any(rt => type.TypeNamesEqual(rt)))
                missingTypes.Add(type);
        }

        // Always check for ProblemDetails and HttpValidationProblemDetails
        var missingProblemDetails = !registeredTypes.Any(static rt =>
            WellKnownTypes.Fqn.ProblemDetails.TypeNamesEqual(rt));
        var missingValidationProblemDetails = !registeredTypes.Any(static rt =>
            WellKnownTypes.Fqn.HttpValidationProblemDetails.TypeNamesEqual(rt));

        if (missingProblemDetails)
            missingTypes.Add(WellKnownTypes.Fqn.ProblemDetails);
        if (missingValidationProblemDetails)
            missingTypes.Add(WellKnownTypes.Fqn.HttpValidationProblemDetails);

        // Report EOE025 if user context lacks CamelCase policy
        if (!userContext.HasCamelCasePolicy)
        {
            spc.ReportDiagnostic(Diagnostic.Create(
                Descriptors.MissingCamelCasePolicy,
                Location.None,
                fullClassName));
        }

        // Report EOE041 if user context is missing ProblemDetails types
        if (missingProblemDetails || missingValidationProblemDetails)
        {
            spc.ReportDiagnostic(Diagnostic.Create(
                Descriptors.JsonContextMissingProblemDetails,
                Location.None,
                fullClassName));
        }

        // Emit helper file with missing types as comments using IndentedStringBuilder
        var sb = new IndentedStringBuilder();
        sb.AppendLine(GeneratedCodeHelpers.AutoGeneratedHeader("ErrorOr.Generators"));
        sb.AppendLine("// ErrorOrX JSON Context Helper");
        sb.AppendLine();
        sb.AppendLine($"// Detected user JsonSerializerContext: {fullClassName}");
        sb.AppendLine();

        if (missingTypes.Count > 0)
        {
            sb.AppendLine("// ============================================================================");
            sb.AppendLine("// MISSING TYPES - Add these [JsonSerializable] attributes to your context:");
            sb.AppendLine("// ============================================================================");
            sb.AppendLine("//");
            foreach (var type in missingTypes.Distinct())
            {
                var displayType = type.StripGlobalPrefix();
                sb.AppendLine($"// [JsonSerializable(typeof({displayType}))]");
            }

            sb.AppendLine("//");
        }
        else
        {
            sb.AppendLine("// All required types are registered in your JsonSerializerContext.");
        }

        if (!userContext.HasCamelCasePolicy)
        {
            sb.AppendLine();
            sb.AppendLine("// ============================================================================");
            sb.AppendLine("// RECOMMENDED - Add CamelCase policy for web API compatibility:");
            sb.AppendLine("// ============================================================================");
            sb.AppendLine("//");
            sb.AppendLine("// [JsonSourceGenerationOptions(");
            sb.AppendLine("//     PropertyNamingPolicy = JsonKnownNamingPolicy.CamelCase,");
            sb.AppendLine("//     DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull)]");
            sb.AppendLine("//");
        }

        // Use same filename as full context to ensure replacement (no stale file issues)
        spc.AddSource("ErrorOrJsonContext.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private static void EmitSupportMethods(StringBuilder code)
    {
        code.AppendLine(
            "        private static bool TryGetRouteValue(HttpContext ctx, string name, out string? value)");
        code.AppendLine("        {");
        code.AppendLine(
            "            if (!ctx.Request.RouteValues.TryGetValue(name, out var raw) || raw is null) { value = null; return false; }");
        code.AppendLine("            value = raw.ToString(); return value is not null;");
        code.AppendLine("        }");
        code.AppendLine();
        code.AppendLine(
            "        private static bool TryGetQueryValue(HttpContext ctx, string name, out string? value)");
        code.AppendLine("        {");
        code.AppendLine(
            "            if (!ctx.Request.Query.TryGetValue(name, out var raw) || raw.Count is 0) { value = null; return false; }");
        code.AppendLine("            value = raw.ToString(); return value is not null;");
        code.AppendLine("        }");
        code.AppendLine();
        code.AppendLine(
            $"        private static {WellKnownTypes.Fqn.Result} ToProblem({WellKnownTypes.Fqn.ReadOnlyList}<{WellKnownTypes.Fqn.Error}> errors)");
        code.AppendLine("        {");
        code.AppendLine($"            if (errors.Count is 0) return {WellKnownTypes.Fqn.TypedResults.Problem}();");
        code.AppendLine("            var hasValidation = false;");
        code.AppendLine(
            $"            for (var i = 0; i < errors.Count; i++) if (errors[i].Type == {WellKnownTypes.Fqn.ErrorType}.Validation) {{ hasValidation = true; break; }}");
        code.AppendLine("            if (hasValidation)");
        code.AppendLine("            {");
        BindingCodeEmitter.EmitValidationDictBuilder(
            code, 16, "dict", "errors", "e",
            "e.Code", "e.Description",
            $"e.Type != {WellKnownTypes.Fqn.ErrorType}.Validation");
        code.AppendLine($"                return {WellKnownTypes.Fqn.TypedResults.ValidationProblem}(dict);");
        code.AppendLine("            }");
        code.AppendLine("            var first = errors[0];");
        code.AppendLine($"            var problem = new {WellKnownTypes.Fqn.ProblemDetails}");
        code.AppendLine("            {");
        code.AppendLine("                Title = first.Code,");
        code.AppendLine("                Detail = first.Description,");
        code.AppendLine(
            $"                Status = first.Type switch {{ {ErrorMapping.GenerateStatusSwitch(WellKnownTypes.Fqn.ErrorType)} }}");
        code.AppendLine("            };");
        code.AppendLine("            problem.Type = $\"https://httpstatuses.io/{problem.Status}\";");
        code.AppendLine("            return problem.Status switch");
        code.AppendLine("            {");
        foreach (var caseExpr in ErrorMapping.GenerateStatusToFactoryCases())
            code.AppendLine($"                {caseExpr},");
        code.AppendLine($"                _ => {ErrorMapping.GetDefaultProblemFactory()}");
        code.AppendLine("            };");
        code.AppendLine("        }");
    }

    /// <summary>
    ///     Delegates to <see cref="BindingCodeEmitter.BuildArgumentExpression" /> for argument expression building.
    /// </summary>
    private static string BuildArgumentExpression(in EndpointParameter param, string paramName)
    {
        return BindingCodeEmitter.BuildArgumentExpression(in param, paramName);
    }

    private static ImmutableArray<EndpointDescriptor> SortEndpoints(ImmutableArray<EndpointDescriptor> endpoints)
    {
        var list = new EndpointDescriptor[endpoints.Length];
        endpoints.CopyTo(list);
        Array.Sort(list, static (a, b) =>
        {
            var c = string.CompareOrdinal(a.HttpMethod, b.HttpMethod);
            if (c is not 0) return c;
            c = string.CompareOrdinal(a.Pattern, b.Pattern);
            return c is not 0 ? c : string.CompareOrdinal(a.HandlerMethodName, b.HandlerMethodName);
        });
        return [.. list];
    }

    private static List<string> CollectJsonTypes(ImmutableArray<EndpointDescriptor> endpoints)
    {
        var types = new HashSet<string>(StringComparer.Ordinal);
        foreach (var ep in endpoints)
        {
            foreach (var p in ep.HandlerParameters)
            {
                if (p.Source == ParameterSource.Body)
                    types.Add(p.TypeFqn);
            }

            if (ep is { IsSse: true, SseItemTypeFqn: not null })
            {
                types.Add(ep.SseItemTypeFqn);
            }
            else
            {
                var successInfo = ResultsUnionTypeBuilder.GetSuccessResponseInfo(
                    ep.SuccessTypeFqn,
                    ep.SuccessKind,
                    ep.IsAcceptedResponse);
                if (successInfo.HasBody)
                    types.Add(ep.SuccessTypeFqn);
            }
        }

        var sorted = types.ToList();
        sorted.Sort(StringComparer.Ordinal);
        return sorted;
    }

    /// <summary>
    ///     Small helpers for code emission patterns.
    /// </summary>
    private static class Emit
    {
        /// <summary>
        ///     Maps HTTP verb to ASP.NET Core's Map* method name.
        /// </summary>
        public static string MapMethod(string httpMethod)
        {
            return httpMethod switch
            {
                "GET" => "MapGet",
                "POST" => "MapPost",
                "PUT" => "MapPut",
                "DELETE" => "MapDelete",
                "PATCH" => "MapPatch",
                _ => "MapMethods"
            };
        }
    }

    /// <summary>
    ///     Aggregated version set information with hasVersioning flag.
    /// </summary>
    private readonly record struct VersionSetContext(
        ImmutableArray<ApiVersionInfo> AllVersions,
        bool HasVersionNeutralEndpoints)
    {
        public bool HasVersioning => !AllVersions.IsDefaultOrEmpty || HasVersionNeutralEndpoints;
    }

    /// <summary>
    ///     Context for invoker emission, holding precomputed values and providing helper methods.
    /// </summary>
    private readonly record struct InvokerContext(
        SuccessResponseInfo SuccessInfo,
        UnionTypeResult UnionResult,
        bool HasFormBinding,
        bool HasBodyBinding,
        bool NeedsAwait,
        int Index)
    {
        public string WrapperName => $"Invoke_Ep{Index}";
        public string CoreName => $"Invoke_Ep{Index}_Core";

        public string WrapReturn(string expr)
        {
            return NeedsAwait ? expr : $"Task.FromResult<{UnionResult.ReturnTypeFqn}>({expr})";
        }
    }
}
