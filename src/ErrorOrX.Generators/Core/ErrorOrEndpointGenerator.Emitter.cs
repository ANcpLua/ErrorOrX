using System.Collections.Immutable;
using System.Text;
using ANcpLua.Roslyn.Utilities;
using ErrorOr.Analyzers;
using ErrorOr.Generators.Emitters;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace ErrorOr.Generators;

/// <summary>
///     Code emission logic for endpoint mappings.
/// </summary>
public sealed partial class ErrorOrEndpointGenerator
{
    internal static void EmitEndpoints(SourceProductionContext spc, ImmutableArray<EndpointDescriptor> endpoints,
        ImmutableArray<JsonContextInfo> userContexts, int maxArity = 6, bool generateJsonContext = true)
    {
        var sorted = SortEndpoints(endpoints);
        var jsonTypes = CollectJsonTypes(sorted);

        EmitGlobalUsings(spc);
        EmitOptionsClass(spc);
        EmitMappings(spc, sorted, jsonTypes.Count > 0, maxArity);

        if (jsonTypes.Count > 0 && generateJsonContext)
            EmitJsonContext(spc, jsonTypes, userContexts);
    }

    private static void EmitGlobalUsings(SourceProductionContext spc)
    {
        const string source = """
                              // <auto-generated/>
                              global using ErrorOr.Generated;
                              """;
        spc.AddSource("ErrorOrEndpoints.GlobalUsings.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private static void EmitMappings(SourceProductionContext spc, ImmutableArray<EndpointDescriptor> endpoints,
        bool hasJsonTypes, int maxArity)
    {
        var code = new StringBuilder();
        code.AppendLine(GeneratedCodeHelpers.AutoGeneratedHeader("ErrorOr.Generators"));
        code.AppendLine(GeneratedCodeHelpers.NullableEnable);
        code.AppendLine("using System;");
        code.AppendLine("using System.Linq;");
        code.AppendLine("using System.Threading.Tasks;");
        code.AppendLine("using Microsoft.AspNetCore.Builder;");
        code.AppendLine("using Microsoft.AspNetCore.Http;");
        code.AppendLine("using Microsoft.AspNetCore.Routing;");
        code.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        code.AppendLine();
        code.AppendLine("namespace ErrorOr.Generated");
        code.AppendLine("{");
        code.AppendLine("    /// <summary>");
        code.AppendLine("    /// Generated endpoint mappings for all [ErrorOrEndpoint] handlers in this assembly.");
        code.AppendLine("    /// </summary>");
        code.AppendLine("    public static class ErrorOrEndpointMappings");
        code.AppendLine("    {");
        code.AppendLine("        /// <summary>");
        code.AppendLine("        /// Maps all ErrorOr endpoints to the application's routing table.");
        code.AppendLine("        /// </summary>");
        code.AppendLine("        /// <param name=\"app\">The endpoint route builder to add mappings to.</param>");
        code.AppendLine("        /// <returns>A convention builder for applying global conventions to all endpoints.</returns>");
        code.AppendLine("        /// <exception cref=\"InvalidOperationException\">");
        code.AppendLine("        /// Thrown when AddErrorOrEndpoints() was not called during service registration.");
        code.AppendLine("        /// </exception>");
        code.AppendLine("        /// <remarks>");
        code.AppendLine("        /// This follows ASP.NET Core's convention builder pattern, enabling global");
        code.AppendLine("        /// endpoint configuration like RequireAuthorization() or RequireRateLimiting().");
        code.AppendLine("        /// </remarks>");
        code.AppendLine("        /// <example>");
        code.AppendLine("        /// <code>");
        code.AppendLine("        /// app.MapErrorOrEndpoints()");
        code.AppendLine("        ///    .RequireAuthorization()");
        code.AppendLine("        ///    .RequireRateLimiting(\"api\");");
        code.AppendLine("        /// </code>");
        code.AppendLine("        /// </example>");
        code.AppendLine("        public static IEndpointConventionBuilder MapErrorOrEndpoints(this IEndpointRouteBuilder app)");
        code.AppendLine("        {");
        code.AppendLine("            // Validate that AddErrorOrEndpoints() was called");
        code.AppendLine("            var marker = app.ServiceProvider.GetService<ErrorOrEndpointsMarkerService>();");
        code.AppendLine("            if (marker is null)");
        code.AppendLine("            {");
        code.AppendLine("                throw new InvalidOperationException(");
        code.AppendLine("                    \"Unable to find the required services. \" +");
        code.AppendLine("                    \"Please add all the required services by calling 'IServiceCollection.AddErrorOrEndpoints()' \" +");
        code.AppendLine("                    \"in the application startup code.\");");
        code.AppendLine("            }");
        code.AppendLine();
        code.AppendLine("            var __endpointBuilders = new System.Collections.Generic.List<IEndpointConventionBuilder>();");
        code.AppendLine();

        // Group endpoints by [RouteGroup] attribute
        var grouping = GroupAggregator.GroupEndpoints(endpoints);

        // Compute global version set for ungrouped endpoints (grouped endpoints use their own version sets)
        var ungroupedEndpoints = grouping.UngroupedEndpoints
            .Select(static ie => ie.Endpoint)
            .ToImmutableArray();
        var ungroupedVersionSet = ComputeGlobalVersionSet(ungroupedEndpoints);
        if (ungroupedVersionSet.HasVersioning && !ungroupedEndpoints.IsDefaultOrEmpty)
            EmitVersionSet(code, ungroupedVersionSet);

        // Emit route group declarations (eShop-style NewVersionedApi + MapGroup)
        var groupContexts = GroupEmitter.EmitGroupDeclarations(code, grouping.Groups);

        // Emit grouped endpoint mappings
        foreach (var ctx in groupContexts)
        foreach (var indexed in ctx.Group.Endpoints)
            GroupEmitter.EmitGroupedMapCall(code, in indexed, ctx.GroupVariableName, maxArity);

        // Emit ungrouped endpoint mappings (legacy pattern)
        foreach (var indexed in grouping.UngroupedEndpoints)
            EmitMapCall(code, indexed.Endpoint, indexed.OriginalIndex, maxArity, ungroupedVersionSet.HasVersioning);

        code.AppendLine();
        code.AppendLine("            return new CompositeEndpointConventionBuilder(__endpointBuilders);");
        code.AppendLine("        }");
        code.AppendLine();

        if (hasJsonTypes)
            EmitJsonConfigExtension(code);

        // Emit invokers for ALL endpoints (grouped and ungrouped)
        for (var i = 0; i < endpoints.Length; i++)
            EmitInvoker(code, endpoints[i], i, maxArity);

        EmitSupportMethods(code);
        code.AppendLine("    }");
        code.AppendLine("}");

        spc.AddSource("ErrorOrEndpointMappings.cs", SourceText.From(code.ToString(), Encoding.UTF8));
    }

    private static void EmitMapCall(StringBuilder code, in EndpointDescriptor ep, int index, int maxArity, bool hasGlobalVersionSet = false)
    {
        code.AppendLine(
            $"            // {ep.HttpMethod} {ep.Pattern} -> {ep.HandlerContainingTypeFqn}.{ep.HandlerMethodName}");
        var mapMethod = Emit.MapMethod(ep.HttpMethod);

        // Use typed Map* methods without Delegate cast for AOT compatibility
        // Store builder for CompositeEndpointConventionBuilder
        code.AppendLine(mapMethod == "MapMethods"
            ? $"            var __ep{index} = app.MapMethods(@\"{ep.Pattern}\", new[] {{ \"{ep.HttpMethod}\" }}, Invoke_Ep{index})"
            : $"            var __ep{index} = app.{mapMethod}(@\"{ep.Pattern}\", Invoke_Ep{index})");

        var (_, operationId) =
            EndpointNameHelper.GetEndpointIdentity(ep.HandlerContainingTypeFqn, ep.HandlerMethodName);

        code.AppendLine($"                .WithName(\"{operationId}\")");

        // Emit API versioning fluent calls
        EmitVersioningCalls(code, ep.Versioning, hasGlobalVersionSet);

        // Use shared metadata emitter for consistent output (tags, accepts, produces, middleware)
        EndpointMetadataEmitter.EmitEndpointMetadata(code, in ep, "                ", maxArity);

        code.AppendLine("                ;");
        code.AppendLine($"            __endpointBuilders.Add(__ep{index});");
        code.AppendLine();
    }

    /// <summary>
    ///     Computes the global version set from all endpoints.
    /// </summary>
    private static VersionSetContext ComputeGlobalVersionSet(ImmutableArray<EndpointDescriptor> endpoints)
    {
        var hasVersionNeutral = endpoints.Any(static ep => ep.Versioning.IsVersionNeutral);

        var sortedVersions = endpoints
            .SelectMany(static ep => ep.Versioning.SupportedVersions.AsImmutableArray())
            .Distinct()
            .OrderBy(static v => v.MajorVersion)
            .ThenBy(static v => v.MinorVersion ?? 0)
            .ToImmutableArray();

        return new VersionSetContext(sortedVersions, hasVersionNeutral);
    }

    /// <summary>
    ///     Emits the version set builder before endpoint mappings.
    /// </summary>
    private static void EmitVersionSet(StringBuilder code, VersionSetContext versionSet)
    {
        code.AppendLine("            // API Versioning: Build version set for all endpoints");
        code.AppendLine("            var versionSet = app.NewApiVersionSet()");

        foreach (var v in versionSet.AllVersions)
        {
            var versionExpr = v.MinorVersion.HasValue
                ? $"new {WellKnownTypes.Fqn.ApiVersion}({v.MajorVersion}, {v.MinorVersion.Value})"
                : $"new {WellKnownTypes.Fqn.ApiVersion}({v.MajorVersion})";

            code.AppendLine(v.IsDeprecated
                ? $"                .HasDeprecatedApiVersion({versionExpr})"
                : $"                .HasApiVersion({versionExpr})");
        }

        code.AppendLine("                .ReportApiVersions()");
        code.AppendLine("                .Build();");
        code.AppendLine();
    }

    /// <summary>
    ///     Emits API versioning fluent calls for an endpoint.
    /// </summary>
    private static void EmitVersioningCalls(StringBuilder code, in VersioningInfo versioning, bool hasGlobalVersionSet)
    {
        // If no global version set exists, don't emit anything
        if (!hasGlobalVersionSet)
            return;

        // Version-neutral endpoints don't map to any specific version
        if (versioning.IsVersionNeutral)
        {
            code.AppendLine("                .IsApiVersionNeutral()");
            return;
        }

        // Apply the version set to the endpoint
        code.AppendLine("                .WithApiVersionSet(versionSet)");

        // If endpoint has specific versions to map to, emit MapToApiVersion calls
        var effectiveVersions = versioning.EffectiveVersions;
        if (!effectiveVersions.IsDefaultOrEmpty)
            foreach (var v in effectiveVersions.AsImmutableArray())
            {
                var versionExpr = v.MinorVersion.HasValue
                    ? $"new {WellKnownTypes.Fqn.ApiVersion}({v.MajorVersion}, {v.MinorVersion.Value})"
                    : $"new {WellKnownTypes.Fqn.ApiVersion}({v.MajorVersion})";
                code.AppendLine($"                .MapToApiVersion({versionExpr})");
            }
    }

    private static InvokerContext ComputeInvokerContext(
        in EndpointDescriptor ep,
        int index,
        int maxArity)
    {
        var successInfo = ResultsUnionTypeBuilder.GetSuccessResponseInfo(
            ep.SuccessTypeFqn, ep.SuccessKind, ep.IsAcceptedResponse);

        var hasFormBinding = ep.HasFormParams;
        var hasBodyBinding = ep.HasBodyOrFormBinding;

        var unionResult = ResultsUnionTypeBuilder.ComputeReturnType(
            ep.SuccessTypeFqn, ep.SuccessKind,
            ep.InferredErrorTypeNames, ep.InferredCustomErrors,
            ep.DeclaredProducesErrors, hasBodyBinding, maxArity,
            ep.IsAcceptedResponse, ep.Middleware);

        var needsAwait = ep.IsAsync || hasBodyBinding || ep.HasBindAsyncParam;

        return new InvokerContext(successInfo, unionResult, hasFormBinding, hasBodyBinding, needsAwait, index);
    }

    private static (StringBuilder Code, bool UsesBindFail) EmitBodyCode(
        in EndpointDescriptor ep,
        in InvokerContext ctx)
    {
        var bodyCode = new StringBuilder();
        var usesBindFail = ctx.HasFormBinding;

        if (ctx.HasFormBinding)
            EmitFormContentTypeGuard(bodyCode);

        var args = new StringBuilder();
        var validationParams = new List<(int Index, string ParamName)>();
        for (var i = 0; i < ep.HandlerParameters.Length; i++)
        {
            var param = ep.HandlerParameters[i];
            usesBindFail |= EmitParameterBinding(bodyCode, in param, $"p{i}", "BindFail");
            if (i > 0) args.Append(", ");
            args.Append(BuildArgumentExpression(in param, $"p{i}"));

            if (param.RequiresValidation)
                validationParams.Add((i, $"p{i}"));
        }

        if (validationParams.Count > 0)
            EmitBclValidation(bodyCode, validationParams, ctx.UnionResult.ReturnTypeFqn, ctx.NeedsAwait);

        var awaitKeyword = ep.IsAsync ? "await " : "";
        bodyCode.AppendLine(
            $"            var result = {awaitKeyword}{ep.HandlerContainingTypeFqn}.{ep.HandlerMethodName}({args});");

        EmitErrorHandling(bodyCode, ep, ctx);

        return (bodyCode, usesBindFail);
    }

    private static void EmitErrorHandling(
        StringBuilder bodyCode,
        in EndpointDescriptor ep,
        in InvokerContext ctx)
    {
        if (ep.IsSse)
        {
            bodyCode.AppendLine($"            if (result.IsError) return {ctx.WrapReturn("ToProblem(result.Errors)")};");
            bodyCode.AppendLine(
                $"            return {ctx.WrapReturn($"{WellKnownTypes.Fqn.TypedResults.ServerSentEvents}(result.Value)")};");
        }
        else if (ctx.UnionResult.CanUseUnion)
            EmitUnionTypeErrorHandling(bodyCode, ep, ctx.UnionResult.ReturnTypeFqn, ctx.SuccessInfo, ctx.NeedsAwait);
        else
        {
            // Use minimal interface (IsError/Errors/Value) instead of convenience Match API
            var successFactory = GetSuccessFactoryWithLocation(ep, ctx.SuccessInfo);
            bodyCode.AppendLine($"            if (result.IsError) return {ctx.WrapReturn("ToProblem(result.Errors)")};");
            bodyCode.AppendLine($"            return {ctx.WrapReturn(successFactory)};");
        }
    }

    private static void EmitWrapperMethod(StringBuilder code, in InvokerContext ctx)
    {
        code.AppendLine($"        private static async Task {ctx.WrapperName}(HttpContext ctx)");
        code.AppendLine("        {");
        code.AppendLine($"            var __result = await {ctx.CoreName}(ctx);");
        code.AppendLine("            await __result.ExecuteAsync(ctx);");
        code.AppendLine("        }");
        code.AppendLine();
    }

    private static void EmitCoreMethod(
        StringBuilder code,
        StringBuilder bodyCode,
        in InvokerContext ctx,
        bool usesBindFail)
    {
        var returnType = ctx.UnionResult.ReturnTypeFqn;
        code.AppendLine(
            ctx.NeedsAwait
                ? $"        private static async Task<{returnType}> {ctx.CoreName}(HttpContext ctx)"
                : $"        private static Task<{returnType}> {ctx.CoreName}(HttpContext ctx)");

        code.AppendLine("        {");

        if (usesBindFail)
            EmitBindFailHelper(code, returnType, ctx.NeedsAwait);

        if (ctx.HasBodyBinding)
            EmitBindFail415Helper(code, returnType, ctx.NeedsAwait);

        code.Append(bodyCode);
        code.AppendLine("        }");
        code.AppendLine();
    }

    private static void EmitInvoker(StringBuilder code, in EndpointDescriptor ep, int index, int maxArity)
    {
        var ctx = ComputeInvokerContext(ep, index, maxArity);
        var (bodyCode, usesBindFail) = EmitBodyCode(ep, ctx);

        EmitWrapperMethod(code, ctx);
        EmitCoreMethod(code, bodyCode, ctx, usesBindFail);
    }

    /// <summary>
    ///     Emits BCL validation calls for parameters that have ValidationAttribute or implement IValidatableObject.
    ///     Uses System.ComponentModel.DataAnnotations.Validator.TryValidateObject for validation.
    /// </summary>
    private static void EmitBclValidation(StringBuilder code, List<(int Index, string ParamName)> validationParams,
        string returnTypeFqn, bool isAsync)
    {
        code.AppendLine();
        code.AppendLine("            // BCL Validation");

        foreach (var (_, paramName) in validationParams)
        {
            code.AppendLine(
                $"            var {paramName}ValidationResults = new {WellKnownTypes.Fqn.List}<{WellKnownTypes.Fqn.ValidationResult}>();");
            code.AppendLine(
                $"            if (!{WellKnownTypes.Fqn.Validator}.TryValidateObject({paramName}!, new {WellKnownTypes.Fqn.ValidationContext}({paramName}!), {paramName}ValidationResults, validateAllProperties: true))");
            code.AppendLine("            {");
            BindingCodeEmitter.EmitValidationDictBuilder(
                code, 16, "validationDict", $"{paramName}ValidationResults", "vr",
                "key", "vr.ErrorMessage ?? \"\"",
                keyVarDecl: "var key = vr.MemberNames.FirstOrDefault() ?? \"\";");

            var returnExpr = isAsync
                ? $"{WellKnownTypes.Fqn.TypedResults.ValidationProblem}(validationDict)"
                : $"Task.FromResult<{returnTypeFqn}>({WellKnownTypes.Fqn.TypedResults.ValidationProblem}(validationDict))";
            code.AppendLine($"                return {returnExpr};");
            code.AppendLine("            }");
        }

        code.AppendLine();
    }

    private static void EmitBindFailHelper(StringBuilder code, string returnTypeFqn, bool isAsync)
    {
        code.AppendLine(
            $"            static {WellKnownTypes.Fqn.ProblemDetails} CreateBindProblem(string param, string reason) => new()");
        code.AppendLine("            {");
        code.AppendLine("                Title = \"Bad Request\",");
        code.AppendLine("                Detail = $\"Parameter '{param}' {reason}.\",");
        code.AppendLine("                Status = 400,");
        code.AppendLine($"                Type = \"{WellKnownTypes.Constants.HttpStatusesBaseUrl}400\",");
        code.AppendLine("            };");
        code.AppendLine();

        const string badRequestExpr = $"{WellKnownTypes.Fqn.TypedResults.BadRequest}(CreateBindProblem(param, reason))";
        var returnExpr = isAsync ? badRequestExpr : $"Task.FromResult<{returnTypeFqn}>({badRequestExpr})";
        var returnType = isAsync ? returnTypeFqn : $"Task<{returnTypeFqn}>";

        code.AppendLine($"            static {returnType} BindFail(string param, string reason)");
        code.AppendLine($"                => {returnExpr};");
        code.AppendLine();
    }

    private static void EmitBindFail415Helper(StringBuilder code, string returnTypeFqn, bool isAsync)
    {
        const string expr = $"{WellKnownTypes.Fqn.TypedResults.StatusCode}(415)";
        var returnExpr = isAsync ? expr : $"Task.FromResult<{returnTypeFqn}>({expr})";
        var returnType = isAsync ? returnTypeFqn : $"Task<{returnTypeFqn}>";

        code.AppendLine($"            static {returnType} BindFail415()");
        code.AppendLine($"                => {returnExpr};");
        code.AppendLine();
    }

    private static void EmitUnionTypeErrorHandling(
        StringBuilder code,
        in EndpointDescriptor ep,
        string returnType,
        SuccessResponseInfo successInfo,
        bool needsAwait)
    {
        code.AppendLine("            if (result.IsError)");
        code.AppendLine("            {");
        code.AppendLine("                var first = result.FirstError;");

        EmitValidationHandling(code, ep, WrapReturn);
        EmitProblemDetailsBuilding(code);
        EmitErrorTypeSwitch(code, ep, WrapReturn);

        code.AppendLine("            }");
        code.AppendLine();

        // Generate Location header for POST endpoints with Created response and Id property
        var successFactory = GetSuccessFactoryWithLocation(ep, successInfo);
        code.AppendLine($"            return {WrapReturn(successFactory)};");
        return;

        string WrapReturn(string expr) => needsAwait ? expr : $"Task.FromResult<{returnType}>({expr})";
    }

    /// <summary>
    ///     Returns the appropriate success factory, with Location header support for Created responses.
    /// </summary>
    private static string GetSuccessFactoryWithLocation(in EndpointDescriptor ep, SuccessResponseInfo successInfo)
    {
        // Only apply Location header for POST endpoints returning Created with an Id property
        if (ep.HttpMethod != WellKnownTypes.HttpMethod.Post)
            return successInfo.Factory;

        if (successInfo.StatusCode != 201)
            return successInfo.Factory;

        // Location header requires both a body (with the Id value) and a detected Id property
        if (!successInfo.HasBody)
            return successInfo.Factory;

        return ep.LocationIdPropertyName is not { Length: > 0 } idProp
            ? successInfo.Factory
            :
            // Generate Location URL: request path + "/" + id value
            // For POST /api/users with response { Id: 123 }, Location becomes /api/users/123
            $"{WellKnownTypes.Fqn.TypedResults.Created}($\"{{ctx.Request.Path}}/{{result.Value.{idProp}}}\", result.Value)";
    }

    private static void EmitValidationHandling(StringBuilder code, in EndpointDescriptor ep,
        Func<string, string> wrapReturn)
    {
        var hasValidation = !ep.InferredErrorTypeNames.IsDefaultOrEmpty &&
                            ep.InferredErrorTypeNames.AsImmutableArray().Contains(ErrorMapping.Validation);

        if (!hasValidation) return;

        code.AppendLine($"                if (first.Type == {WellKnownTypes.Fqn.ErrorType}.Validation)");
        code.AppendLine("                {");
        BindingCodeEmitter.EmitValidationDictBuilder(
            code, 20, "validationDict", "result.Errors", "e",
            "e.Code", "e.Description",
            $"e.Type != {WellKnownTypes.Fqn.ErrorType}.Validation");
        code.AppendLine(
            $"                    return {wrapReturn($"{WellKnownTypes.Fqn.TypedResults.ValidationProblem}(validationDict)")};");
        code.AppendLine("                }");
    }

    private static void EmitProblemDetailsBuilding(StringBuilder code)
    {
        code.AppendLine($"                var problem = new {WellKnownTypes.Fqn.ProblemDetails}");
        code.AppendLine("                {");
        code.AppendLine("                    Title = first.Code,");
        code.AppendLine("                    Detail = first.Description,");
        code.AppendLine(
            $"                    Status = first.Type switch {{ {ErrorMapping.GenerateStatusSwitch(WellKnownTypes.Fqn.ErrorType)} }}");
        code.AppendLine("                };");
        code.AppendLine("                problem.Type = $\"https://httpstatuses.io/{problem.Status}\";");
        code.AppendLine();
    }

    private static void EmitErrorTypeSwitch(StringBuilder code, in EndpointDescriptor ep,
        Func<string, string> wrapReturn)
    {
        code.AppendLine("                switch (first.Type)");
        code.AppendLine("                {");

        if (!ep.InferredErrorTypeNames.IsDefaultOrEmpty)
            foreach (var errorTypeName in ep.InferredErrorTypeNames.AsImmutableArray()
                         .Where(static e => e != ErrorMapping.Validation)
                         .Distinct()
                         .OrderBy(static x => x, StringComparer.Ordinal))
            {
                var factory = ErrorMapping.GetFactory(errorTypeName);

                code.AppendLine($"                    case {WellKnownTypes.Fqn.ErrorType}.{errorTypeName}:");
                code.AppendLine($"                        return {wrapReturn(factory)};");
            }

        code.AppendLine("                    default:");
        code.AppendLine($"                        return {wrapReturn(ErrorMapping.GetFactory(ErrorMapping.Failure))};");
        code.AppendLine("                }");
    }

    /// <summary>
    ///     Emits parameter binding code and returns whether BindFail helper is used.
    /// </summary>
    private static bool EmitParameterBinding(StringBuilder code, in EndpointParameter param, string paramName,
        string bindFailFn)
    {
        return param.Source switch
        {
            EndpointParameterSource.Route => EmitRouteBinding(code, in param, paramName, bindFailFn),
            EndpointParameterSource.Query => EmitQueryBinding(code, in param, paramName, bindFailFn),
            EndpointParameterSource.Header => EmitHeaderBinding(code, in param, paramName, bindFailFn),
            EndpointParameterSource.Body => EmitBodyBinding(code, in param, paramName, bindFailFn),
            EndpointParameterSource.Service => EmitServiceBinding(code, in param, paramName),
            EndpointParameterSource.KeyedService => EmitKeyedServiceBinding(code, in param, paramName),
            EndpointParameterSource.HttpContext => EmitHttpContextBinding(code, paramName),
            EndpointParameterSource.CancellationToken => EmitCancellationTokenBinding(code, paramName),
            EndpointParameterSource.Stream => EmitStreamBinding(code, paramName),
            EndpointParameterSource.PipeReader => EmitPipeReaderBinding(code, paramName),
            EndpointParameterSource.FormFile => EmitFormFileBinding(code, in param, paramName, bindFailFn),
            EndpointParameterSource.FormFiles => EmitFormFilesBinding(code, paramName),
            EndpointParameterSource.FormCollection => EmitFormCollectionBinding(code, paramName),
            EndpointParameterSource.Form => EmitFormBinding(code, in param, paramName, bindFailFn),
            EndpointParameterSource.AsParameters => EmitAsParametersBinding(code, in param, paramName, bindFailFn),
            _ => false
        };
    }

    private static bool EmitServiceBinding(StringBuilder code, in EndpointParameter param, string paramName)
    {
        code.AppendLine($"            var {paramName} = ctx.RequestServices.GetRequiredService<{param.TypeFqn}>();");
        return false;
    }

    private static bool EmitKeyedServiceBinding(StringBuilder code, in EndpointParameter param, string paramName)
    {
        code.AppendLine(
            $"            var {paramName} = ctx.RequestServices.GetRequiredKeyedService<{param.TypeFqn}>({param.KeyName});");
        return false;
    }

    private static bool EmitHttpContextBinding(StringBuilder code, string paramName)
    {
        code.AppendLine($"            var {paramName} = ctx;");
        return false;
    }

    private static bool EmitCancellationTokenBinding(StringBuilder code, string paramName)
    {
        code.AppendLine($"            var {paramName} = ctx.RequestAborted;");
        return false;
    }

    private static bool EmitStreamBinding(StringBuilder code, string paramName)
    {
        code.AppendLine($"            var {paramName} = ctx.Request.Body;");
        return false;
    }

    private static bool EmitPipeReaderBinding(StringBuilder code, string paramName)
    {
        code.AppendLine($"            var {paramName} = ctx.Request.BodyReader;");
        return false;
    }

    private static bool EmitFormFilesBinding(StringBuilder code, string paramName)
    {
        code.AppendLine($"            var {paramName} = form.Files;");
        return false;
    }

    private static bool EmitFormCollectionBinding(StringBuilder code, string paramName)
    {
        code.AppendLine($"            var {paramName} = form;");
        return false;
    }

    private static bool EmitFormFileBinding(StringBuilder code, in EndpointParameter param, string paramName,
        string bindFailFn)
    {
        code.AppendLine($"            var {paramName} = form.Files.GetFile(\"{param.KeyName ?? param.Name}\");");
        if (param.IsNullable) return false;

        code.AppendLine(
            $"            if ({paramName} is null) return {bindFailFn}(\"{param.Name}\", \"is required\");");
        return true;
    }

    private static bool EmitRouteBinding(StringBuilder code, in EndpointParameter param, string paramName,
        string bindFailFn)
    {
        var routeName = param.KeyName ?? param.Name;
        code.AppendLine(
            param.TypeFqn.IsStringType()
                ? $"            if (!TryGetRouteValue(ctx, \"{routeName}\", out var {paramName})) return {bindFailFn}(\"{param.Name}\", \"is missing from route\");"
                : $"            if (!TryGetRouteValue(ctx, \"{routeName}\", out var {paramName}Raw) || !{GetTryParseExpression(param.TypeFqn, paramName + "Raw", paramName, param.CustomBinding)}) return {bindFailFn}(\"{param.Name}\", \"has invalid format\");");
        return true;
    }

    private static bool EmitQueryBinding(StringBuilder code, in EndpointParameter param, string paramName,
        string bindFailFn)
    {
        if (param.CustomBinding is CustomBindingMethod.BindAsync or CustomBindingMethod.BindAsyncWithParam)
            return EmitBindAsyncBinding(code, in param, paramName, bindFailFn);

        var queryKey = param.KeyName ?? param.Name;
        return param is { IsCollection: true, CollectionItemTypeFqn: { } itemType }
            ? EmitCollectionQueryBinding(code, in param, paramName, queryKey, itemType, bindFailFn)
            : EmitScalarQueryBinding(code, in param, paramName, queryKey, bindFailFn);
    }

    private static bool EmitBindAsyncBinding(StringBuilder code, in EndpointParameter param, string paramName,
        string bindFailFn)
    {
        var baseType = param.TypeFqn.TrimEnd('?');
        code.AppendLine($"            var {paramName} = await {baseType}.BindAsync(ctx);");
        if (param.IsNullable) return false;

        code.AppendLine(
            $"            if ({paramName} is null) return {bindFailFn}(\"{param.Name}\", \"binding failed\");");
        return true;
    }

    private static bool EmitCollectionQueryBinding(StringBuilder code, in EndpointParameter param, string paramName,
        string queryKey, string itemType, string bindFailFn)
    {
        code.AppendLine($"            var {paramName}Raw = ctx.Request.Query[\"{queryKey}\"];");
        code.AppendLine($"            var {paramName}List = new {WellKnownTypes.Fqn.List}<{itemType}>();");
        code.AppendLine($"            foreach (var item in {paramName}Raw)");
        code.AppendLine("            {");

        var usesBindFail = false;
        if (itemType.IsStringType())
            code.AppendLine(
                $"                if (item is {{ Length: > 0 }} validItem) {paramName}List.Add(validItem);");
        else
        {
            usesBindFail = true;
            code.AppendLine(
                $"                if ({GetTryParseExpression(itemType, "item", "parsedItem")}) {paramName}List.Add(parsedItem);");
            code.AppendLine(
                $"                else if (!string.IsNullOrEmpty(item)) return {bindFailFn}(\"{param.Name}\", \"has invalid item format\");");
        }

        code.AppendLine("            }");
        var isArray = param.TypeFqn.EndsWith("[]");
        var assignment = isArray ? $"{paramName}List.ToArray()" : $"{paramName}List";
        code.AppendLine($"            var {paramName} = {assignment};");
        return usesBindFail;
    }

    private static bool EmitScalarQueryBinding(StringBuilder code, in EndpointParameter param, string paramName,
        string queryKey, string bindFailFn)
    {
        var usesBindFail = false;
        var declType = param.TypeFqn.EndsWith("?") ? param.TypeFqn : param.TypeFqn + "?";
        code.AppendLine($"            {declType} {paramName};");
        code.AppendLine($"            if (!TryGetQueryValue(ctx, \"{queryKey}\", out var {paramName}Raw))");
        code.AppendLine("            {");
        if (param.IsNullable)
            code.AppendLine($"                {paramName} = default;");
        else
        {
            usesBindFail = true;
            code.AppendLine($"                return {bindFailFn}(\"{param.Name}\", \"is required\");");
        }

        code.AppendLine("            }");
        code.AppendLine("            else");
        code.AppendLine("            {");
        if (param.TypeFqn.IsStringType())
            code.AppendLine($"                {paramName} = {paramName}Raw;");
        else
        {
            usesBindFail = true;
            code.AppendLine(
                $"                if (!{GetTryParseExpression(param.TypeFqn, paramName + "Raw", paramName + "Temp", param.CustomBinding)}) return {bindFailFn}(\"{param.Name}\", \"has invalid format\");");
            code.AppendLine($"                {paramName} = {paramName}Temp;");
        }

        code.AppendLine("            }");
        return usesBindFail;
    }

    private static bool EmitHeaderBinding(StringBuilder code, in EndpointParameter param, string paramName,
        string bindFailFn)
    {
        var key = param.KeyName ?? param.Name;
        var usesBindFail = false;

        if (param is { IsCollection: true, CollectionItemTypeFqn: { } itemType })
        {
            code.AppendLine($"            {param.TypeFqn} {paramName};");
            code.AppendLine(
                $"            if (!ctx.Request.Headers.TryGetValue(\"{key}\", out var {paramName}Raw) || {paramName}Raw.Count is 0)");
            code.AppendLine("            {");
            if (param.IsNullable)
                code.AppendLine($"                {paramName} = default!;");
            else
            {
                usesBindFail = true;
                code.AppendLine($"                return {bindFailFn}(\"{param.Name}\", \"is required\");");
            }

            code.AppendLine("            }");
            code.AppendLine("            else");
            code.AppendLine("            {");
            code.AppendLine($"                var {paramName}List = new {WellKnownTypes.Fqn.List}<{itemType}>();");
            code.AppendLine($"                foreach (var item in {paramName}Raw)");
            code.AppendLine("                {");
            code.AppendLine(
                itemType.IsStringType()
                    ? $"                    if (item is {{ Length: > 0 }} validItem) {paramName}List.Add(validItem);"
                    : $"                    if ({GetTryParseExpression(itemType, "item", "parsedItem")}) {paramName}List.Add(parsedItem);");
            code.AppendLine("                }");
            var isArray = param.TypeFqn.EndsWith("[]");
            var assignment = isArray ? $"{paramName}List.ToArray()" : $"{paramName}List";
            code.AppendLine($"                {paramName} = {assignment};");
        }
        else
        {
            var declType = param.TypeFqn.EndsWith("?") ? param.TypeFqn : param.TypeFqn + "?";
            code.AppendLine($"            {declType} {paramName};");
            code.AppendLine(
                $"            if (!ctx.Request.Headers.TryGetValue(\"{key}\", out var {paramName}Raw) || {paramName}Raw.Count is 0)");
            code.AppendLine("            {");
            if (param.IsNullable)
                code.AppendLine($"                {paramName} = default;");
            else
            {
                usesBindFail = true;
                code.AppendLine($"                return {bindFailFn}(\"{param.Name}\", \"is required\");");
            }

            code.AppendLine("            }");
            code.AppendLine("            else");
            code.AppendLine("            {");
            if (param.TypeFqn.IsStringType())
                code.AppendLine($"                {paramName} = {paramName}Raw.ToString();");
            else
            {
                usesBindFail = true;
                code.AppendLine(
                    $"                if (!{GetTryParseExpression(param.TypeFqn, paramName + "Raw.ToString()", paramName + "Temp")}) return {bindFailFn}(\"{param.Name}\", \"has invalid format\"); {paramName} = {paramName}Temp;");
            }
        }

        code.AppendLine("            }");

        return usesBindFail;
    }

    private static bool EmitBodyBinding(StringBuilder code, in EndpointParameter param, string paramName,
        string bindFailFn)
    {
        code.AppendLine("            if (!ctx.Request.HasJsonContentType()) return BindFail415();");
        code.AppendLine($"            {param.TypeFqn}? {paramName};");
        code.AppendLine("            try");
        code.AppendLine("            {");
        code.AppendLine(
            $"                {paramName} = await ctx.Request.ReadFromJsonAsync<{param.TypeFqn}>(cancellationToken: ctx.RequestAborted);");
        code.AppendLine("            }");
        code.AppendLine($"            catch ({WellKnownTypes.Fqn.JsonException})");
        code.AppendLine("            {");
        code.AppendLine($"                return {bindFailFn}(\"{param.Name}\", \"has invalid JSON format\");");
        code.AppendLine("            }");
        code.AppendLine(
            $"            if ({paramName} is null) return {bindFailFn}(\"{param.Name}\", \"is required\");");
        return true;
    }

    private static bool EmitFormBinding(StringBuilder code, in EndpointParameter param, string paramName,
        string bindFailFn)
    {
        if (!param.Children.IsDefaultOrEmpty)
        {
            var usesBindFail = false;
            for (var i = 0; i < param.Children.Length; i++)
            {
                var child = param.Children[i];
                usesBindFail |= EmitParameterBinding(code, in child, $"{paramName}_f{i}", bindFailFn);
            }

            var args = string.Join(", ", param.Children.AsImmutableArray().Select((_, i) => $"{paramName}_f{i}"));
            code.AppendLine($"            var {paramName} = new {param.TypeFqn}({args});");
            return usesBindFail;
        }

        var usesBindFailScalar = false;
        var fieldName = param.KeyName ?? param.Name;
        var declType = param.IsNullable && !param.TypeFqn.EndsWith("?") ? param.TypeFqn + "?" : param.TypeFqn;
        code.AppendLine($"            {declType} {paramName};");
        code.AppendLine(
            $"            if (!form.TryGetValue(\"{fieldName}\", out var {paramName}Raw) || {paramName}Raw.Count is 0)");
        code.AppendLine("            {");
        if (param.IsNullable)
            code.AppendLine($"                {paramName} = default;");
        else
        {
            usesBindFailScalar = true;
            code.AppendLine($"                return {bindFailFn}(\"{param.Name}\", \"is required\");");
        }

        code.AppendLine("            }");
        code.AppendLine("            else");
        code.AppendLine("            {");
        if (param.TypeFqn.IsStringType())
            code.AppendLine($"                {paramName} = {paramName}Raw.ToString();");
        else
        {
            usesBindFailScalar = true;
            code.AppendLine(
                $"                if (!{GetTryParseExpression(param.TypeFqn, paramName + "Raw.ToString()", paramName + "Temp")}) return {bindFailFn}(\"{param.Name}\", \"has invalid format\");");
            code.AppendLine($"                {paramName} = {paramName}Temp;");
        }

        code.AppendLine("            }");
        return usesBindFailScalar;
    }

    private static bool EmitAsParametersBinding(StringBuilder code, in EndpointParameter param, string paramName,
        string bindFailFn)
    {
        var usesBindFail = false;
        var childVars = new List<string>();
        for (var i = 0; i < param.Children.Length; i++)
        {
            var child = param.Children[i];
            var childVarName = $"{paramName}_c{i}";
            usesBindFail |= EmitParameterBinding(code, in child, childVarName, bindFailFn);
            childVars.Add(BuildArgumentExpression(in child, childVarName));
        }

        code.AppendLine($"            var {paramName} = new {param.TypeFqn}({string.Join(", ", childVars)});");
        return usesBindFail;
    }

    private static void EmitFormContentTypeGuard(StringBuilder code)
    {
        code.AppendLine(
            "            if (!ctx.Request.HasFormContentType) return BindFail415();");
        code.AppendLine("            var form = await ctx.Request.ReadFormAsync(ctx.RequestAborted);");
        code.AppendLine();
    }

    private static void EmitJsonConfigExtension(StringBuilder code)
    {
        // Emit fluent builder: AddErrorOrEndpoints() returns IErrorOrEndpointsBuilder
        code.AppendLine("        /// <summary>");
        code.AppendLine("        /// Registers ErrorOr endpoint services and returns a builder for configuration.");
        code.AppendLine("        /// </summary>");
        code.AppendLine("        /// <param name=\"services\">The service collection to configure.</param>");
        code.AppendLine("        /// <returns>A builder for further configuration.</returns>");
        code.AppendLine("        /// <remarks>");
        code.AppendLine("        /// This follows ASP.NET Core's builder pattern (like AddRazorComponents())");
        code.AppendLine("        /// enabling fluent extension method chaining without callback nesting.");
        code.AppendLine("        /// </remarks>");
        code.AppendLine("        /// <example>");
        code.AppendLine("        /// <code>");
        code.AppendLine("        /// builder.Services.AddErrorOrEndpoints()");
        code.AppendLine("        ///     .UseJsonContext&lt;AppJsonSerializerContext&gt;()");
        code.AppendLine("        ///     .WithCamelCase()");
        code.AppendLine("        ///     .WithIgnoreNulls();");
        code.AppendLine("        /// </code>");
        code.AppendLine("        /// </example>");
        code.AppendLine(
            "        public static IErrorOrEndpointsBuilder AddErrorOrEndpoints(this IServiceCollection services)");
        code.AppendLine("        {");
        code.AppendLine("            // Register marker service for validation in MapErrorOrEndpoints()");
        code.AppendLine("            services.AddSingleton<ErrorOrEndpointsMarkerService>();");
        code.AppendLine("            return new ErrorOrEndpointsBuilder(services);");
        code.AppendLine("        }");
        code.AppendLine();
    }

    private static void EmitOptionsClass(SourceProductionContext spc)
    {
        const string source = """
                              // <auto-generated>
                              // This file was generated by ErrorOr.Generators source generator.
                              // </auto-generated>

                              #nullable enable

                              namespace ErrorOr.Generated
                              {
                                  /// <summary>
                                  /// Marker service to verify that AddErrorOrEndpoints() was called.
                                  /// </summary>
                                  /// <remarks>
                                  /// This follows the ASP.NET Core pattern used by RazorComponentsMarkerService
                                  /// to provide clear error messages when the service registration is missing.
                                  /// </remarks>
                                  internal sealed class ErrorOrEndpointsMarkerService { }

                                  /// <summary>
                                  /// Builder interface for configuring ErrorOr endpoints.
                                  /// </summary>
                                  /// <remarks>
                                  /// This pattern follows ASP.NET Core's IRazorComponentsBuilder design,
                                  /// enabling fluent extension method chaining without callback nesting.
                                  /// </remarks>
                                  public interface IErrorOrEndpointsBuilder
                                  {
                                      /// <summary>
                                      /// Gets the service collection being configured.
                                      /// </summary>
                                      global::Microsoft.Extensions.DependencyInjection.IServiceCollection Services { get; }
                                  }

                                  /// <summary>
                                  /// Default implementation of <see cref="IErrorOrEndpointsBuilder"/>.
                                  /// </summary>
                                  internal sealed class ErrorOrEndpointsBuilder : IErrorOrEndpointsBuilder
                                  {
                                      public ErrorOrEndpointsBuilder(global::Microsoft.Extensions.DependencyInjection.IServiceCollection services)
                                      {
                                          Services = services;
                                      }

                                      public global::Microsoft.Extensions.DependencyInjection.IServiceCollection Services { get; }
                                  }

                                  /// <summary>
                                  /// Extension methods for <see cref="IErrorOrEndpointsBuilder"/>.
                                  /// </summary>
                                  public static class ErrorOrEndpointsBuilderExtensions
                                  {
                                      /// <summary>
                                      /// Registers a JsonSerializerContext for AOT-compatible JSON serialization.
                                      /// </summary>
                                      /// <typeparam name="TContext">The JsonSerializerContext type.</typeparam>
                                      /// <param name="builder">The builder instance.</param>
                                      /// <returns>The builder instance for chaining.</returns>
                                      public static IErrorOrEndpointsBuilder UseJsonContext<TContext>(this IErrorOrEndpointsBuilder builder)
                                          where TContext : global::System.Text.Json.Serialization.JsonSerializerContext, new()
                                      {
                                          builder.Services.ConfigureHttpJsonOptions(options =>
                                          {
                                              options.SerializerOptions.TypeInfoResolverChain.Insert(0, new TContext());
                                          });
                                          return builder;
                                      }

                                      /// <summary>
                                      /// Uses camelCase for JSON property names.
                                      /// </summary>
                                      /// <param name="builder">The builder instance.</param>
                                      /// <param name="enabled">Whether to enable camelCase (default: true).</param>
                                      /// <returns>The builder instance for chaining.</returns>
                                      public static IErrorOrEndpointsBuilder WithCamelCase(this IErrorOrEndpointsBuilder builder, bool enabled = true)
                                      {
                                          if (enabled)
                                          {
                                              builder.Services.ConfigureHttpJsonOptions(options =>
                                              {
                                                  options.SerializerOptions.PropertyNamingPolicy = global::System.Text.Json.JsonNamingPolicy.CamelCase;
                                              });
                                          }
                                          return builder;
                                      }

                                      /// <summary>
                                      /// Ignores null values when serializing JSON.
                                      /// </summary>
                                      /// <param name="builder">The builder instance.</param>
                                      /// <param name="enabled">Whether to ignore nulls (default: true).</param>
                                      /// <returns>The builder instance for chaining.</returns>
                                      public static IErrorOrEndpointsBuilder WithIgnoreNulls(this IErrorOrEndpointsBuilder builder, bool enabled = true)
                                      {
                                          if (enabled)
                                          {
                                              builder.Services.ConfigureHttpJsonOptions(options =>
                                              {
                                                  options.SerializerOptions.DefaultIgnoreCondition = global::System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull;
                                              });
                                          }
                                          return builder;
                                      }
                                  }

                                  /// <summary>
                                  /// Composite convention builder that applies conventions to multiple endpoints.
                                  /// </summary>
                                  /// <remarks>
                                  /// This follows the ASP.NET Core pattern for applying global conventions
                                  /// to all endpoints registered by MapErrorOrEndpoints().
                                  /// </remarks>
                                  internal sealed class CompositeEndpointConventionBuilder : global::Microsoft.AspNetCore.Builder.IEndpointConventionBuilder
                                  {
                                      private readonly global::System.Collections.Generic.List<global::Microsoft.AspNetCore.Builder.IEndpointConventionBuilder> _builders;

                                      public CompositeEndpointConventionBuilder(global::System.Collections.Generic.List<global::Microsoft.AspNetCore.Builder.IEndpointConventionBuilder> builders)
                                      {
                                          _builders = builders;
                                      }

                                      public void Add(global::System.Action<global::Microsoft.AspNetCore.Builder.EndpointBuilder> convention)
                                      {
                                          foreach (var builder in _builders)
                                          {
                                              builder.Add(convention);
                                          }
                                      }

                                      public void Finally(global::System.Action<global::Microsoft.AspNetCore.Builder.EndpointBuilder> finallyConvention)
                                      {
                                          foreach (var builder in _builders)
                                          {
                                              builder.Finally(finallyConvention);
                                          }
                                      }
                                  }
                              }
                              """;
        spc.AddSource("ErrorOrEndpointOptions.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private static void EmitJsonContext(SourceProductionContext spc, List<string> jsonTypes,
        ImmutableArray<JsonContextInfo> userContexts)
    {
        // If user has their own JsonSerializerContext, emit a helper file instead
        if (userContexts is { IsDefaultOrEmpty: false, Length: > 0 })
        {
            EmitJsonContextHelper(spc, jsonTypes, userContexts);
            return;
        }

        // No user context - emit full ErrorOrJsonContext using IndentedStringBuilder
        var sb = new IndentedStringBuilder();
        sb.AppendLine(GeneratedCodeHelpers.AutoGeneratedHeader("ErrorOr.Generators"));
        sb.AppendLine("// JSON serialization context for Native AOT support.");
        sb.AppendLine(GeneratedCodeHelpers.NullableEnable);
        sb.AppendLine();
        sb.AppendLine(
            "[System.Text.Json.Serialization.JsonSourceGenerationOptions(DefaultIgnoreCondition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull)]");
        foreach (var type in jsonTypes)
            sb.AppendLine($"[System.Text.Json.Serialization.JsonSerializable(typeof({type}))]");
        sb.AppendLine(
            $"[System.Text.Json.Serialization.JsonSerializable(typeof({WellKnownTypes.Fqn.ProblemDetails}))]");
        sb.AppendLine(
            $"[System.Text.Json.Serialization.JsonSerializable(typeof({WellKnownTypes.Fqn.HttpValidationProblemDetails}))]");
        sb.AppendLine(
            "internal partial class ErrorOrJsonContext : System.Text.Json.Serialization.JsonSerializerContext { }");
        spc.AddSource("ErrorOrJsonContext.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private static void EmitJsonContextHelper(SourceProductionContext spc, List<string> jsonTypes,
        ImmutableArray<JsonContextInfo> userContexts)
    {
        var userContext = userContexts[0]; // Use first context found
        var fullClassName = userContext.Namespace is not null
            ? $"{userContext.Namespace}.{userContext.ClassName}"
            : userContext.ClassName;

        // Collect registered types from user context
        var registeredTypes = new HashSet<string>();
        foreach (var ctx in userContexts)
        foreach (var typeFqn in ctx.SerializableTypes)
            registeredTypes.Add(typeFqn);

        // Find missing types
        var missingTypes = new List<string>();

        // Check endpoint types
        foreach (var type in jsonTypes)
            if (!registeredTypes.Any(rt => type.TypeNamesEqual(rt)))
                missingTypes.Add(type);

        // Always check for ProblemDetails and HttpValidationProblemDetails
        if (!registeredTypes.Any(static rt => WellKnownTypes.Fqn.ProblemDetails.TypeNamesEqual(rt)))
            missingTypes.Add(WellKnownTypes.Fqn.ProblemDetails);
        if (!registeredTypes.Any(static rt =>
                WellKnownTypes.Fqn.HttpValidationProblemDetails.TypeNamesEqual(rt)))
            missingTypes.Add(WellKnownTypes.Fqn.HttpValidationProblemDetails);

        // Report EOE040 if user context lacks CamelCase policy
        if (!userContext.HasCamelCasePolicy)
            spc.ReportDiagnostic(Diagnostic.Create(
                Descriptors.MissingCamelCasePolicy,
                Location.None,
                fullClassName));

        // Emit helper file with missing types as comments using IndentedStringBuilder
        var sb = new IndentedStringBuilder();
        sb.AppendLine(GeneratedCodeHelpers.AutoGeneratedHeader("ErrorOr.Generators"));
        sb.AppendLine("// ErrorOrX JSON Context Helper");
        sb.AppendLine();
        sb.AppendLine($"// Detected user JsonSerializerContext: {fullClassName}");
        sb.AppendLine();

        if (missingTypes.Count > 0)
        {
            sb.AppendLine("// ============================================================================");
            sb.AppendLine("// MISSING TYPES - Add these [JsonSerializable] attributes to your context:");
            sb.AppendLine("// ============================================================================");
            sb.AppendLine("//");
            foreach (var type in missingTypes.Distinct())
            {
                var displayType = type.StripGlobalPrefix();
                sb.AppendLine($"// [JsonSerializable(typeof({displayType}))]");
            }

            sb.AppendLine("//");
        }
        else
            sb.AppendLine("// All required types are registered in your JsonSerializerContext.");

        if (!userContext.HasCamelCasePolicy)
        {
            sb.AppendLine();
            sb.AppendLine("// ============================================================================");
            sb.AppendLine("// RECOMMENDED - Add CamelCase policy for web API compatibility:");
            sb.AppendLine("// ============================================================================");
            sb.AppendLine("//");
            sb.AppendLine("// [JsonSourceGenerationOptions(");
            sb.AppendLine("//     PropertyNamingPolicy = JsonKnownNamingPolicy.CamelCase,");
            sb.AppendLine("//     DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull)]");
            sb.AppendLine("//");
        }

        // Use same filename as full context to ensure replacement (no stale file issues)
        spc.AddSource("ErrorOrJsonContext.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private static void EmitSupportMethods(StringBuilder code)
    {
        code.AppendLine(
            "        private static bool TryGetRouteValue(HttpContext ctx, string name, out string? value)");
        code.AppendLine("        {");
        code.AppendLine(
            "            if (!ctx.Request.RouteValues.TryGetValue(name, out var raw) || raw is null) { value = null; return false; }");
        code.AppendLine("            value = raw.ToString(); return value is not null;");
        code.AppendLine("        }");
        code.AppendLine();
        code.AppendLine(
            "        private static bool TryGetQueryValue(HttpContext ctx, string name, out string? value)");
        code.AppendLine("        {");
        code.AppendLine(
            "            if (!ctx.Request.Query.TryGetValue(name, out var raw) || raw.Count is 0) { value = null; return false; }");
        code.AppendLine("            value = raw.ToString(); return value is not null;");
        code.AppendLine("        }");
        code.AppendLine();
        code.AppendLine(
            $"        private static {WellKnownTypes.Fqn.Result} ToProblem({WellKnownTypes.Fqn.ReadOnlyList}<{WellKnownTypes.Fqn.Error}> errors)");
        code.AppendLine("        {");
        code.AppendLine($"            if (errors.Count is 0) return {WellKnownTypes.Fqn.TypedResults.Problem}();");
        code.AppendLine("            var hasValidation = false;");
        code.AppendLine(
            $"            for (var i = 0; i < errors.Count; i++) if (errors[i].Type == {WellKnownTypes.Fqn.ErrorType}.Validation) {{ hasValidation = true; break; }}");
        code.AppendLine("            if (hasValidation)");
        code.AppendLine("            {");
        BindingCodeEmitter.EmitValidationDictBuilder(
            code, 16, "dict", "errors", "e",
            "e.Code", "e.Description",
            $"e.Type != {WellKnownTypes.Fqn.ErrorType}.Validation");
        code.AppendLine($"                return {WellKnownTypes.Fqn.TypedResults.ValidationProblem}(dict);");
        code.AppendLine("            }");
        code.AppendLine("            var first = errors[0];");
        code.AppendLine($"            var problem = new {WellKnownTypes.Fqn.ProblemDetails}");
        code.AppendLine("            {");
        code.AppendLine("                Title = first.Code,");
        code.AppendLine("                Detail = first.Description,");
        code.AppendLine(
            $"                Status = first.Type switch {{ {ErrorMapping.GenerateStatusSwitch(WellKnownTypes.Fqn.ErrorType)} }}");
        code.AppendLine("            };");
        code.AppendLine("            problem.Type = $\"https://httpstatuses.io/{problem.Status}\";");
        code.AppendLine("            return problem.Status switch");
        code.AppendLine("            {");
        foreach (var caseExpr in ErrorMapping.GenerateStatusToFactoryCases())
            code.AppendLine($"                {caseExpr},");
        code.AppendLine($"                _ => {ErrorMapping.GetDefaultProblemFactory()}");
        code.AppendLine("            };");
        code.AppendLine("        }");
    }

    private static string BuildArgumentExpression(in EndpointParameter param, string paramName)
    {
        return param.Source switch
        {
            EndpointParameterSource.Body when !param.IsNullable => paramName + "!",
            EndpointParameterSource.Route when param is { IsNullable: false, IsNonNullableValueType: false } =>
                paramName + "!",
            EndpointParameterSource.Query when param is { IsNullable: false, IsNonNullableValueType: true } =>
                paramName + ".Value",
            EndpointParameterSource.Header when param is { IsNullable: false, IsNonNullableValueType: true } =>
                paramName + ".Value",
            EndpointParameterSource.Query when param is { IsNullable: false, IsNonNullableValueType: false } =>
                paramName + "!",
            EndpointParameterSource.Header when param is { IsNullable: false, IsNonNullableValueType: false } =>
                paramName + "!",
            _ => paramName
        };
    }

    private static string GetTryParseExpression(string typeFqn, string rawName, string outputName,
        CustomBindingMethod customBinding = CustomBindingMethod.None)
    {
        if (customBinding is CustomBindingMethod.TryParse or CustomBindingMethod.TryParseWithFormat)
        {
            var baseType = typeFqn.TrimEnd('?');
            return $"{baseType}.TryParse({rawName}, out var {outputName})";
        }

        var normalized = typeFqn.Replace("global::", "").TrimEnd('?');
        return normalized switch
        {
            "System.Int32" or "int" => $"int.TryParse({rawName}, out var {outputName})",
            "System.Int64" or "long" => $"long.TryParse({rawName}, out var {outputName})",
            "System.Int16" or "short" => $"short.TryParse({rawName}, out var {outputName})",
            "System.Byte" or "byte" => $"byte.TryParse({rawName}, out var {outputName})",
            "System.SByte" or "sbyte" => $"sbyte.TryParse({rawName}, out var {outputName})",
            "System.UInt16" or "ushort" => $"ushort.TryParse({rawName}, out var {outputName})",
            "System.UInt32" or "uint" => $"uint.TryParse({rawName}, out var {outputName})",
            "System.UInt64" or "ulong" => $"ulong.TryParse({rawName}, out var {outputName})",
            "System.Boolean" or "bool" => $"bool.TryParse({rawName}, out var {outputName})",
            "System.Guid" => $"global::System.Guid.TryParse({rawName}, out var {outputName})",
            "System.DateTime" => $"global::System.DateTime.TryParse({rawName}, out var {outputName})",
            "System.DateTimeOffset" => $"global::System.DateTimeOffset.TryParse({rawName}, out var {outputName})",
            "System.TimeSpan" => $"global::System.TimeSpan.TryParse({rawName}, out var {outputName})",
            "System.DateOnly" => $"global::System.DateOnly.TryParse({rawName}, out var {outputName})",
            "System.TimeOnly" => $"global::System.TimeOnly.TryParse({rawName}, out var {outputName})",
            "System.Double" or "double" => $"double.TryParse({rawName}, out var {outputName})",
            "System.Single" or "float" => $"float.TryParse({rawName}, out var {outputName})",
            "System.Decimal" or "decimal" => $"decimal.TryParse({rawName}, out var {outputName})",
            _ => "false"
        };
    }

    private static ImmutableArray<EndpointDescriptor> SortEndpoints(ImmutableArray<EndpointDescriptor> endpoints)
    {
        var list = new EndpointDescriptor[endpoints.Length];
        endpoints.CopyTo(list);
        Array.Sort(list, static (a, b) =>
        {
            var c = string.CompareOrdinal(a.HttpMethod, b.HttpMethod);
            if (c is not 0) return c;
            c = string.CompareOrdinal(a.Pattern, b.Pattern);
            return c is not 0 ? c : string.CompareOrdinal(a.HandlerMethodName, b.HandlerMethodName);
        });
        return [.. list];
    }

    private static List<string> CollectJsonTypes(ImmutableArray<EndpointDescriptor> endpoints)
    {
        var types = new HashSet<string>(StringComparer.Ordinal);
        foreach (var ep in endpoints)
        {
            foreach (var p in ep.HandlerParameters)
                if (p.Source == EndpointParameterSource.Body)
                    types.Add(p.TypeFqn);

            if (ep is { IsSse: true, SseItemTypeFqn: not null })
                types.Add(ep.SseItemTypeFqn);
            else
            {
                var successInfo = ResultsUnionTypeBuilder.GetSuccessResponseInfo(
                    ep.SuccessTypeFqn,
                    ep.SuccessKind,
                    ep.IsAcceptedResponse);
                if (successInfo.HasBody)
                    types.Add(ep.SuccessTypeFqn);
            }
        }

        var sorted = types.ToList();
        sorted.Sort(StringComparer.Ordinal);
        return sorted;
    }

    /// <summary>
    ///     Small helpers for code emission patterns.
    /// </summary>
    private static class Emit
    {
        /// <summary>
        ///     Maps HTTP verb to ASP.NET Core's Map* method name.
        /// </summary>
        public static string MapMethod(string httpMethod) => httpMethod switch
        {
            "GET" => "MapGet",
            "POST" => "MapPost",
            "PUT" => "MapPut",
            "DELETE" => "MapDelete",
            "PATCH" => "MapPatch",
            _ => "MapMethods"
        };
    }

    /// <summary>
    ///     Aggregated version set information with hasVersioning flag.
    /// </summary>
    private readonly record struct VersionSetContext(
        ImmutableArray<ApiVersionInfo> AllVersions,
        bool HasVersionNeutralEndpoints)
    {
        public bool HasVersioning => !AllVersions.IsDefaultOrEmpty || HasVersionNeutralEndpoints;
    }

    /// <summary>
    ///     Context for invoker emission, holding precomputed values and providing helper methods.
    /// </summary>
    private readonly record struct InvokerContext(
        SuccessResponseInfo SuccessInfo,
        UnionTypeResult UnionResult,
        bool HasFormBinding,
        bool HasBodyBinding,
        bool NeedsAwait,
        int Index)
    {
        public string WrapperName => $"Invoke_Ep{Index}";
        public string CoreName => $"Invoke_Ep{Index}_Core";

        public string WrapReturn(string expr) =>
            NeedsAwait ? expr : $"Task.FromResult<{UnionResult.ReturnTypeFqn}>({expr})";
    }
}
