using System.Collections.Immutable;
using System.Text;
using ANcpLua.Roslyn.Utilities;
using ANcpLua.Roslyn.Utilities.Contexts;
using ANcpLua.Roslyn.Utilities.Models;
using ErrorOr.Analyzers;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace ErrorOr.Generators;

/// <summary>
///     Source generator that automatically discovers types from ErrorOr endpoints
///     and generates [JsonSerializable] attributes for Native AOT compatibility.
/// </summary>
[Generator(LanguageNames.CSharp)]
public sealed class AotJsonGenerator : IIncrementalGenerator
{
    private const string AotJsonAttributeFqn = "ErrorOr.AotJsonAttribute";
    private const string AotJsonAssemblyAttributeFqn = "ErrorOr.AotJsonAssemblyAttribute";
    private const string JsonSerializerContextFqn = "System.Text.Json.Serialization.JsonSerializerContext";
    private const int DefaultMaxDepth = 10;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 1. Emit the marker attributes
        context.RegisterPostInitializationOutput(EmitAotJsonAttribute);

        // 2. Find classes with [AotJson] attribute using ForAttributeWithMetadataNameOfClassesAndRecords
        var aotJsonContexts = context.SyntaxProvider
            .ForAttributeWithMetadataNameOfClassesAndRecords(AotJsonAttributeFqn)
            .SelectFlow(static (ctx, ct) => ExtractAotJsonContextFlow(ctx, ct))
            .ReportAndContinue(context)
            .WithTrackingName("AotJson_Contexts");

        // 3. Find assembly-level [AotJsonAssembly] attributes
        var assemblyConfigs = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                AotJsonAssemblyAttributeFqn,
                static (node, _) => node is CompilationUnitSyntax,
                static (ctx, ct) => ExtractAssemblyConfig(ctx, ct))
            .Where(static c => c.HasValue)
            .Select(static (c, _) => c!.Value);

        // 4. Get endpoint types from the existing ErrorOrEndpointGenerator pipeline
        // Property traversal is now done during extraction - no CompilationProvider needed for caching
        var endpointTypes = CreateEndpointTypeProvider(context);

        // 5. Combine context with discovered types (no CompilationProvider - enables proper caching)
        var combined = aotJsonContexts
            .Combine(endpointTypes.CollectAsEquatableArray());

        // 6. Generate output for [AotJson] decorated contexts
        context.RegisterSourceOutput(combined, static (spc, data) =>
        {
            var (contextInfo, endpointTypeInfos) = data;
            GenerateJsonSerializableAttributes(spc, contextInfo, endpointTypeInfos);
        });

        // 7. Handle assembly-level auto-generation when no [AotJson] context exists
        // No CompilationProvider - enables proper caching
        var autoGeneration = assemblyConfigs
            .Combine(aotJsonContexts.Collect())
            .Combine(endpointTypes.CollectAsEquatableArray());

        context.RegisterSourceOutput(autoGeneration, static (spc, data) =>
        {
            var ((assemblyConfig, existingContexts), endpointTypeInfos) = data;

            // Only auto-generate if no [AotJson] context exists
            if (!existingContexts.IsDefaultOrEmpty)
                return;

            GenerateAutoContext(spc, assemblyConfig, endpointTypeInfos);
        });
    }

    /// <summary>
    ///     Emits the [AotJson], [AotJsonAssembly] attributes and enums for users to apply.
    /// </summary>
    private static void EmitAotJsonAttribute(IncrementalGeneratorPostInitializationContext context)
    {
        const string source = """
                              // <auto-generated/>
                              #nullable enable

                              namespace ErrorOr
                              {
                                  /// <summary>
                                  /// Automatically discovers and generates [JsonSerializable] attributes for all types
                                  /// used in ErrorOr endpoints. Apply to a partial class inheriting from JsonSerializerContext.
                                  /// </summary>
                                  [global::System.AttributeUsage(global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
                                  public sealed class AotJsonAttribute : global::System.Attribute
                                  {
                                      /// <summary>Scan ErrorOr endpoint returns for serializable types. Default: true.</summary>
                                      public bool ScanEndpoints { get; set; } = true;

                                      /// <summary>Additional namespaces to scan for serializable types.</summary>
                                      public string[]? ScanNamespaces { get; set; }

                                      /// <summary>Explicit types to always include.</summary>
                                      public global::System.Type[]? IncludeTypes { get; set; }

                                      /// <summary>Types to exclude from generation.</summary>
                                      public global::System.Type[]? ExcludeTypes { get; set; }

                                      /// <summary>Collection variants to generate. Default: List | Array.</summary>
                                      public global::ErrorOr.CollectionKind GenerateCollections { get; set; } = global::ErrorOr.CollectionKind.List | global::ErrorOr.CollectionKind.Array;

                                      /// <summary>Include ProblemDetails types. Default: true.</summary>
                                      public bool IncludeProblemDetails { get; set; } = true;

                                      /// <summary>Traverse property types to discover nested types. Default: true.</summary>
                                      public bool TraversePropertyTypes { get; set; } = true;

                                      /// <summary>Maximum depth for property type traversal. Default: 10.</summary>
                                      public int MaxTraversalDepth { get; set; } = 10;

                                      /// <summary>JSON property naming policy. Default: CamelCase.</summary>
                                      public global::ErrorOr.JsonNamingPolicy NamingPolicy { get; set; } = global::ErrorOr.JsonNamingPolicy.CamelCase;
                                  }

                                  /// <summary>
                                  /// Assembly-level attribute for zero-config AOT JSON serialization.
                                  /// When applied, automatically generates a JsonSerializerContext with all discovered types.
                                  /// </summary>
                                  [global::System.AttributeUsage(global::System.AttributeTargets.Assembly, AllowMultiple = false)]
                                  public sealed class AotJsonAssemblyAttribute : global::System.Attribute
                                  {
                                      /// <summary>Namespace for the generated context. Default: project root namespace.</summary>
                                      public string? ContextNamespace { get; set; }

                                      /// <summary>Name of the generated context class. Default: "AotJsonContext".</summary>
                                      public string ContextTypeName { get; set; } = "AotJsonContext";

                                      /// <summary>JSON property naming policy. Default: CamelCase.</summary>
                                      public global::ErrorOr.JsonNamingPolicy NamingPolicy { get; set; } = global::ErrorOr.JsonNamingPolicy.CamelCase;

                                      /// <summary>Collection variants to generate. Default: All.</summary>
                                      public global::ErrorOr.CollectionKind GenerateCollections { get; set; } = global::ErrorOr.CollectionKind.All;

                                      /// <summary>Include ProblemDetails types. Default: true.</summary>
                                      public bool IncludeProblemDetails { get; set; } = true;

                                      /// <summary>Traverse property types to discover nested types. Default: true.</summary>
                                      public bool TraversePropertyTypes { get; set; } = true;

                                      /// <summary>Maximum depth for property type traversal. Default: 10.</summary>
                                      public int MaxTraversalDepth { get; set; } = 10;
                                  }

                                  /// <summary>Collection variants to generate for discovered types.</summary>
                                  [global::System.Flags]
                                  public enum CollectionKind
                                  {
                                      None = 0,
                                      List = 1 << 0,
                                      Array = 1 << 1,
                                      IEnumerable = 1 << 2,
                                      IReadOnlyList = 1 << 3,
                                      All = List | Array | IEnumerable | IReadOnlyList
                                  }

                                  /// <summary>JSON property naming policy options.</summary>
                                  public enum JsonNamingPolicy
                                  {
                                      /// <summary>Use default naming (PascalCase).</summary>
                                      Default = 0,
                                      /// <summary>Use camelCase naming.</summary>
                                      CamelCase = 1,
                                      /// <summary>Use snake_case naming.</summary>
                                      SnakeCase = 2,
                                      /// <summary>Use kebab-case naming.</summary>
                                      KebabCase = 3
                                  }
                              }
                              """;

        context.AddSource("AotJsonAttribute.g.cs", source);
    }

    /// <summary>
    ///     Extracts assembly-level [AotJsonAssembly] configuration.
    /// </summary>
    private static AotJsonAssemblyConfig? ExtractAssemblyConfig(
        GeneratorAttributeSyntaxContext ctx,
        CancellationToken ct)
    {
        ct.ThrowIfCancellationRequested();

        var attr = ctx.Attributes.FirstOrDefault(a =>
            a.AttributeClass?.ToDisplayString() == AotJsonAssemblyAttributeFqn);

        if (attr is null)
            return null;

        var contextNamespace = GetNamedArgumentValue<string?>(attr, "ContextNamespace", null);
        var contextTypeName = GetNamedArgumentValue(attr, "ContextTypeName", "AotJsonContext");
        var namingPolicy = (JsonNamingPolicy)GetNamedArgumentValue(attr, "NamingPolicy", 1);
        var generateCollections = (CollectionKind)GetNamedArgumentValue(attr, "GenerateCollections", (int)CollectionKind.All);
        var includeProblemDetails = GetNamedArgumentValue(attr, "IncludeProblemDetails", true);
        var traversePropertyTypes = GetNamedArgumentValue(attr, "TraversePropertyTypes", true);
        var maxTraversalDepth = GetNamedArgumentValue(attr, "MaxTraversalDepth", DefaultMaxDepth);

        return new AotJsonAssemblyConfig(
            contextNamespace,
            contextTypeName,
            namingPolicy,
            generateCollections,
            includeProblemDetails,
            traversePropertyTypes,
            maxTraversalDepth);
    }

    /// <summary>
    ///     Extracts context info from the [AotJson] decorated class using DiagnosticFlow.
    /// </summary>
    private static DiagnosticFlow<AotJsonContextInfo> ExtractAotJsonContextFlow(
        GeneratorAttributeSyntaxContext ctx,
        CancellationToken ct)
    {
        ct.ThrowIfCancellationRequested();

        if (ctx.TargetSymbol is not INamedTypeSymbol classSymbol)
            return DiagnosticFlow.Fail<AotJsonContextInfo>();

        var location = classSymbol.Locations.FirstOrDefault() ?? Location.None;

        // Check if class is partial
        var syntax = ctx.TargetNode as ClassDeclarationSyntax;
        if (syntax is not null && !syntax.Modifiers.Any(SyntaxKind.PartialKeyword))
            return DiagnosticFlow.Fail<AotJsonContextInfo>(
                DiagnosticInfo.Create(Descriptors.AotJsonOnNonPartialClass, location, classSymbol.Name));

        // Verify it inherits from JsonSerializerContext
        if (!InheritsFromJsonSerializerContext(classSymbol))
            return DiagnosticFlow.Fail<AotJsonContextInfo>();

        // Extract attribute data
        var attr = ctx.Attributes.FirstOrDefault(a =>
            a.AttributeClass?.ToDisplayString() == AotJsonAttributeFqn);

        if (attr is null)
            return DiagnosticFlow.Fail<AotJsonContextInfo>();

        // Extract properties from attribute
        var scanEndpoints = GetNamedArgumentValue(attr, "ScanEndpoints", true);
        var scanNamespaces = GetNamedArgumentArrayValue<string>(attr, "ScanNamespaces");
        var includeTypes = GetNamedArgumentTypeArrayValue(attr, "IncludeTypes");
        var excludeTypes = GetNamedArgumentTypeArrayValue(attr, "ExcludeTypes");
        var generateCollections = GetNamedArgumentValue(attr, "GenerateCollections", 3); // List | Array
        var includeProblemDetails = GetNamedArgumentValue(attr, "IncludeProblemDetails", true);
        var traversePropertyTypes = GetNamedArgumentValue(attr, "TraversePropertyTypes", true);
        var namingPolicy = (JsonNamingPolicy)GetNamedArgumentValue(attr, "NamingPolicy", 1);
        var maxTraversalDepth = GetNamedArgumentValue(attr, "MaxTraversalDepth", DefaultMaxDepth);

        var contextInfo = new AotJsonContextInfo(
            classSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
            classSymbol.Name,
            classSymbol.ContainingNamespace?.ToDisplayString(),
            scanEndpoints,
            scanNamespaces.AsEquatableArray(),
            includeTypes.AsEquatableArray(),
            excludeTypes.AsEquatableArray(),
            (CollectionKind)generateCollections,
            includeProblemDetails,
            traversePropertyTypes,
            namingPolicy,
            maxTraversalDepth);

        return DiagnosticFlow.Ok(contextInfo);
    }

    /// <summary>
    ///     Creates a provider that discovers types from ErrorOr endpoint methods.
    /// </summary>
    private static IncrementalValuesProvider<DiscoveredTypeInfo> CreateEndpointTypeProvider(
        IncrementalGeneratorInitializationContext context)
    {
        // Scan all HTTP method attributes
        var httpAttributes = new[]
        {
            WellKnownTypes.GetAttribute,
            WellKnownTypes.PostAttribute,
            WellKnownTypes.PutAttribute,
            WellKnownTypes.DeleteAttribute,
            WellKnownTypes.PatchAttribute
        };

        // Create a combined provider for all HTTP methods
        var providers = httpAttributes.Select(attr =>
            context.SyntaxProvider
                .ForAttributeWithMetadataName(
                    attr,
                    static (node, _) => node is MethodDeclarationSyntax,
                    static (ctx, ct) => ExtractTypesFromMethod(ctx, ct))
                .SelectMany(static (types, _) => types));

        // Combine all providers - start with first, then add remaining
        var combined = providers.First();
        foreach (var provider in providers.Skip(1))
            combined = combined.Collect()
                .Combine(provider.Collect())
                .SelectMany(static (pair, _) =>
                    pair.Left.Concat(pair.Right));

        return combined
            .Where(static t => !string.IsNullOrEmpty(t.FullyQualifiedName))
            .Distinct()
            .WithTrackingName("AotJson_EndpointTypes");
    }

    /// <summary>
    ///     Extracts serializable types from a method's return type and parameters.
    ///     Also traverses property types during extraction (while ITypeSymbol is available)
    ///     to enable proper incremental caching without needing CompilationProvider.
    /// </summary>
    private static ImmutableArray<DiscoveredTypeInfo> ExtractTypesFromMethod(
        GeneratorAttributeSyntaxContext ctx,
        CancellationToken ct)
    {
        ct.ThrowIfCancellationRequested();

        if (ctx.TargetSymbol is not IMethodSymbol method)
            return ImmutableArray<DiscoveredTypeInfo>.Empty;

        var types = ImmutableArray.CreateBuilder<DiscoveredTypeInfo>();
        var visitedTypes = new HashSet<string>();
        var compilation = ctx.SemanticModel.Compilation;
        var awaitableCtx = new AwaitableContext(compilation);
        var collectionCtx = new CollectionContext(compilation);

        // Extract from return type and traverse property types inline
        var returnType = method.ReturnType;
        ExtractTypesRecursive(returnType, types, visitedTypes, awaitableCtx, collectionCtx,
            DiscoveredTypeSource.EndpointReturn);

        // Extract from parameters (request bodies) and traverse property types inline
        foreach (var param in method.Parameters)
            if (IsSerializableParameter(param))
                ExtractTypesRecursive(param.Type, types, visitedTypes, awaitableCtx, collectionCtx,
                    DiscoveredTypeSource.EndpointParameter);

        return types.ToImmutable();
    }

    /// <summary>
    ///     Recursively extracts types, unwrapping Task, ErrorOr, collections, etc.
    ///     Also traverses property types inline for proper caching.
    /// </summary>
    private static void ExtractTypesRecursive(
        ITypeSymbol type,
        ImmutableArray<DiscoveredTypeInfo>.Builder types,
        HashSet<string> visitedTypes,
        AwaitableContext awaitableCtx,
        CollectionContext collectionCtx,
        DiscoveredTypeSource source)
    {
        // Skip null/error types
        if (type is null || type.TypeKind == TypeKind.Error)
            return;

        // Unwrap Task/ValueTask
        if (awaitableCtx.IsTaskLike(type) && type is INamedTypeSymbol { TypeArguments.Length: 1 } taskType)
        {
            ExtractTypesRecursive(taskType.TypeArguments[0], types, visitedTypes, awaitableCtx, collectionCtx, source);
            return;
        }

        // Unwrap ErrorOr<T>
        if (type is INamedTypeSymbol { Name: "ErrorOr", TypeArguments.Length: 1 } errorOrType)
        {
            ExtractTypesRecursive(errorOrType.TypeArguments[0], types, visitedTypes, awaitableCtx, collectionCtx,
                source);
            return;
        }

        // Handle collections - extract element type but also keep the collection
        if (collectionCtx.IsEnumerable(type))
        {
            var elementType = collectionCtx.GetElementType(type);
            if (elementType is not null)
            {
                // Don't add IEnumerable<T>, IAsyncEnumerable<T>, etc. directly - just the element
                ExtractTypesRecursive(elementType, types, visitedTypes, awaitableCtx, collectionCtx, source);
                return;
            }
        }

        // Handle arrays
        if (type is IArrayTypeSymbol arrayType)
        {
            ExtractTypesRecursive(arrayType.ElementType, types, visitedTypes, awaitableCtx, collectionCtx, source);
            return;
        }

        // Skip primitives and well-known types
        if (IsPrimitiveOrBuiltIn(type))
            return;

        // Skip special ASP.NET types that are handled differently
        if (IsSpecialAspNetType(type))
            return;

        // Add the type
        var fqn = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var displayName = type.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);

        types.Add(new DiscoveredTypeInfo(fqn, displayName, false, source));

        // Traverse property types inline for proper caching
        TraversePropertyTypesForExtraction(type, types, visitedTypes, 0, DefaultMaxDepth);
    }

    /// <summary>
    ///     Traverses a type's properties during extraction to discover nested types.
    ///     This is called while ITypeSymbol is available, enabling proper incremental caching
    ///     by avoiding the need for Compilation in the generation phase.
    /// </summary>
    private static void TraversePropertyTypesForExtraction(
        ITypeSymbol type,
        ImmutableArray<DiscoveredTypeInfo>.Builder types,
        HashSet<string> visitedTypes,
        int currentDepth,
        int maxDepth)
    {
        // Stop at max depth
        if (currentDepth >= maxDepth)
            return;

        // Skip null/error types
        if (type is null || type.TypeKind == TypeKind.Error)
            return;

        var fqn = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

        // Cycle detection - skip if already visited
        if (!visitedTypes.Add(fqn))
            return;

        // Skip primitives
        if (IsPrimitiveOrBuiltIn(type))
            return;

        // Skip special types
        if (IsSpecialAspNetType(type))
            return;

        // For named types, traverse properties
        if (type is not INamedTypeSymbol namedType)
            return;

        foreach (var member in namedType.GetMembers())
        {
            if (member is not IPropertySymbol property)
                continue;

            // Only public properties
            if (property.DeclaredAccessibility != Accessibility.Public)
                continue;

            // Skip indexers
            if (property.IsIndexer)
                continue;

            var propertyType = property.Type;

            // Unwrap nullable
            if (propertyType is INamedTypeSymbol
                {
                    OriginalDefinition.SpecialType: SpecialType.System_Nullable_T
                } nullable)
                propertyType = nullable.TypeArguments[0];

            // Handle arrays
            if (propertyType is IArrayTypeSymbol arrayType)
            {
                AddPropertyType(arrayType.ElementType, types, visitedTypes, currentDepth, maxDepth);
                continue;
            }

            // Handle generic collections
            if (propertyType is INamedTypeSymbol { IsGenericType: true } genericType)
            {
                var typeName = genericType.ConstructedFrom.ToDisplayString();
                if (typeName.StartsWith("System.Collections.Generic.", StringComparison.Ordinal) ||
                    typeName.StartsWith("System.Collections.Immutable.", StringComparison.Ordinal))
                {
                    foreach (var typeArg in genericType.TypeArguments)
                        AddPropertyType(typeArg, types, visitedTypes, currentDepth, maxDepth);
                    continue;
                }
            }

            // Traverse the property type
            AddPropertyType(propertyType, types, visitedTypes, currentDepth, maxDepth);
        }
    }

    /// <summary>
    ///     Adds a property type to the discovered types and recurses into its properties.
    /// </summary>
    private static void AddPropertyType(
        ITypeSymbol type,
        ImmutableArray<DiscoveredTypeInfo>.Builder types,
        HashSet<string> visitedTypes,
        int currentDepth,
        int maxDepth)
    {
        // Skip primitives
        if (IsPrimitiveOrBuiltIn(type))
            return;

        // Skip special types
        if (IsSpecialAspNetType(type))
            return;

        var fqn = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var displayName = type.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);

        // Add as property traversal type (will be filtered based on TraversePropertyTypes setting)
        types.Add(new DiscoveredTypeInfo(fqn, displayName, false, DiscoveredTypeSource.PropertyTraversal));

        // Continue traversing
        TraversePropertyTypesForExtraction(type, types, visitedTypes, currentDepth + 1, maxDepth);
    }

    /// <summary>
    ///     Generates the [JsonSerializable] attributes for the context class.
    ///     No Compilation parameter needed - property traversal was done during extraction.
    /// </summary>
    private static void GenerateJsonSerializableAttributes(
        SourceProductionContext spc,
        AotJsonContextInfo contextInfo,
        EquatableArray<DiscoveredTypeInfo> endpointTypes)
    {
        var allTypes = new HashSet<string>();
        var excludeSet = new HashSet<string>(contextInfo.ExcludeTypes);

        // 1. Add types from endpoints (if enabled)
        if (contextInfo.ScanEndpoints)
            foreach (var type in endpointTypes)
            {
                // Skip PropertyTraversal types if TraversePropertyTypes is disabled
                if (type.Source == DiscoveredTypeSource.PropertyTraversal && !contextInfo.TraversePropertyTypes)
                    continue;

                if (!excludeSet.Contains(type.FullyQualifiedName))
                    allTypes.Add(type.FullyQualifiedName);
            }

        // 2. Add explicit includes
        foreach (var type in contextInfo.IncludeTypes)
            if (!excludeSet.Contains(type))
                allTypes.Add(type);

        // 3. Add ProblemDetails types (if enabled)
        if (contextInfo.IncludeProblemDetails)
        {
            allTypes.Add("global::Microsoft.AspNetCore.Mvc.ProblemDetails");
            allTypes.Add("global::Microsoft.AspNetCore.Http.HttpValidationProblemDetails");
        }

        // 4. Property traversal is now done during extraction phase - removed runtime traversal

        // 5. Generate collection variants
        var withCollections = new HashSet<string>(allTypes);
        foreach (var typeName in allTypes)
        {
            if (contextInfo.GenerateCollections.HasFlag(CollectionKind.List))
                withCollections.Add($"global::System.Collections.Generic.List<{typeName}>");

            if (contextInfo.GenerateCollections.HasFlag(CollectionKind.Array))
                withCollections.Add($"{typeName}[]");

            if (contextInfo.GenerateCollections.HasFlag(CollectionKind.Enumerable))
                withCollections.Add($"global::System.Collections.Generic.IEnumerable<{typeName}>");

            if (contextInfo.GenerateCollections.HasFlag(CollectionKind.ReadOnlyList))
                withCollections.Add($"global::System.Collections.Generic.IReadOnlyList<{typeName}>");
        }

        // 6. Generate the source
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("// Generated by AotJsonGenerator");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(contextInfo.Namespace))
        {
            sb.AppendLine($"namespace {contextInfo.Namespace};");
            sb.AppendLine();
        }

        // Emit [JsonSerializable] attributes
        foreach (var type in withCollections.OrderBy(t => t, StringComparer.Ordinal))
            sb.AppendLine($"[global::System.Text.Json.Serialization.JsonSerializable(typeof({type}))]");

        sb.AppendLine($"partial class {contextInfo.ContextTypeName};");

        spc.AddSource($"{contextInfo.ContextTypeName}.AotJson.g.cs", sb.ToString());
    }

    /// <summary>
    ///     Generates an auto-generated JsonSerializerContext when [AotJsonAssembly] is used
    ///     and no [AotJson] context exists.
    ///     No Compilation parameter needed - property traversal was done during extraction.
    /// </summary>
    private static void GenerateAutoContext(
        SourceProductionContext spc,
        AotJsonAssemblyConfig config,
        EquatableArray<DiscoveredTypeInfo> endpointTypes)
    {
        var allTypes = new HashSet<string>();

        // 1. Add types from endpoints
        foreach (var type in endpointTypes)
        {
            // Skip PropertyTraversal types if TraversePropertyTypes is disabled
            if (type.Source == DiscoveredTypeSource.PropertyTraversal && !config.TraversePropertyTypes)
                continue;

            allTypes.Add(type.FullyQualifiedName);
        }

        // 2. Add ProblemDetails types (if enabled)
        if (config.IncludeProblemDetails)
        {
            allTypes.Add("global::Microsoft.AspNetCore.Mvc.ProblemDetails");
            allTypes.Add("global::Microsoft.AspNetCore.Http.HttpValidationProblemDetails");
        }

        // 3. Property traversal is now done during extraction phase - removed runtime traversal

        // 4. Generate collection variants
        var withCollections = new HashSet<string>(allTypes);
        foreach (var typeName in allTypes)
        {
            if (config.GenerateCollections.HasFlag(CollectionKind.List))
                withCollections.Add($"global::System.Collections.Generic.List<{typeName}>");

            if (config.GenerateCollections.HasFlag(CollectionKind.Array))
                withCollections.Add($"{typeName}[]");

            if (config.GenerateCollections.HasFlag(CollectionKind.Enumerable))
                withCollections.Add($"global::System.Collections.Generic.IEnumerable<{typeName}>");

            if (config.GenerateCollections.HasFlag(CollectionKind.ReadOnlyList))
                withCollections.Add($"global::System.Collections.Generic.IReadOnlyList<{typeName}>");
        }

        // 5. Generate the source
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("// Generated by AotJsonGenerator from [assembly: AotJsonAssembly]");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(config.ContextNamespace))
        {
            sb.AppendLine($"namespace {config.ContextNamespace};");
            sb.AppendLine();
        }

        // Emit naming policy
        var policyName = config.NamingPolicy switch
        {
            JsonNamingPolicy.CamelCase => "CamelCase",
            JsonNamingPolicy.SnakeCase => "SnakeCaseLower",
            JsonNamingPolicy.KebabCase => "KebabCaseLower",
            _ => null
        };

        if (policyName is not null)
        {
            sb.AppendLine("[global::System.Text.Json.Serialization.JsonSourceGenerationOptions(");
            sb.AppendLine($"    PropertyNamingPolicy = global::System.Text.Json.Serialization.JsonKnownNamingPolicy.{policyName},");
            sb.AppendLine("    DefaultIgnoreCondition = global::System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull)]");
        }

        // Emit [JsonSerializable] attributes
        foreach (var type in withCollections.OrderBy(t => t, StringComparer.Ordinal))
            sb.AppendLine($"[global::System.Text.Json.Serialization.JsonSerializable(typeof({type}))]");

        sb.AppendLine($"internal partial class {config.ContextTypeName} : global::System.Text.Json.Serialization.JsonSerializerContext");
        sb.AppendLine("{");
        sb.AppendLine("}");

        spc.AddSource($"{config.ContextTypeName}.g.cs", sb.ToString());
    }

    #region Helper Methods

    private static bool InheritsFromJsonSerializerContext(INamedTypeSymbol symbol)
    {
        var current = symbol.BaseType;
        while (current is not null)
        {
            if (current.ToDisplayString() == JsonSerializerContextFqn)
                return true;
            current = current.BaseType;
        }

        return false;
    }

    private static T GetNamedArgumentValue<T>(AttributeData attr, string name, T defaultValue)
    {
        var arg = attr.NamedArguments.FirstOrDefault(a => a.Key == name);
        return arg.Key is not null && arg.Value.Value is T value ? value : defaultValue;
    }

    private static ImmutableArray<string> GetNamedArgumentArrayValue<T>(AttributeData attr, string name)
    {
        var arg = attr.NamedArguments.FirstOrDefault(a => a.Key == name);
        if (arg.Key is null || arg.Value.IsNull)
            return ImmutableArray<string>.Empty;

        return arg.Value.Values
            .Where(v => v.Value is not null)
            .Select(v => v.Value!.ToString()!)
            .ToImmutableArray();
    }

    private static ImmutableArray<string> GetNamedArgumentTypeArrayValue(AttributeData attr, string name)
    {
        var arg = attr.NamedArguments.FirstOrDefault(a => a.Key == name);
        if (arg.Key is null || arg.Value.IsNull)
            return ImmutableArray<string>.Empty;

        return arg.Value.Values
            .Where(v => v.Value is INamedTypeSymbol)
            .Select(v => ((INamedTypeSymbol)v.Value!).ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat))
            .ToImmutableArray();
    }

    private static bool IsSerializableParameter(IParameterSymbol param)
    {
        // Skip special types
        var typeName = param.Type.ToDisplayString();
        if (typeName.Contains("HttpContext") ||
            typeName.Contains("CancellationToken") ||
            typeName.Contains("IFormFile") ||
            typeName.Contains("Stream") ||
            typeName.Contains("PipeReader"))
            return false;

        // Check for [FromBody] or complex type that would be body
        var hasFromBody = param.GetAttributes().Any(a =>
            a.AttributeClass?.Name is "FromBodyAttribute" or "FromBody");

        if (hasFromBody)
            return true;

        // Complex types on POST/PUT/PATCH would be body
        return !IsPrimitiveOrBuiltIn(param.Type);
    }

    private static bool IsPrimitiveOrBuiltIn(ITypeSymbol type)
    {
        if (type.SpecialType != SpecialType.None)
            return true;

        var name = type.ToDisplayString();
        return name is
            "string" or "System.String" or
            "int" or "System.Int32" or
            "long" or "System.Int64" or
            "short" or "System.Int16" or
            "byte" or "System.Byte" or
            "bool" or "System.Boolean" or
            "float" or "System.Single" or
            "double" or "System.Double" or
            "decimal" or "System.Decimal" or
            "System.Guid" or "Guid" or
            "System.DateTime" or "DateTime" or
            "System.DateTimeOffset" or "DateTimeOffset" or
            "System.DateOnly" or "DateOnly" or
            "System.TimeOnly" or "TimeOnly" or
            "System.TimeSpan" or "TimeSpan" or
            "System.Uri" or "Uri";
    }

    private static bool IsSpecialAspNetType(ITypeSymbol type)
    {
        var name = type.ToDisplayString();
        return name.Contains("HttpContext") ||
               name.Contains("CancellationToken") ||
               name.Contains("IFormFile") ||
               name.Contains("ClaimsPrincipal") ||
               name.Contains("IResult") ||
               name.Contains("ActionResult");
    }

    #endregion
}
