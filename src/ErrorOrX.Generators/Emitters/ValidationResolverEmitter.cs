using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace ErrorOr.Generators.Emitters;

/// <summary>
///     Emits a source-generated <c>IValidatableInfoResolver</c> that bridges ErrorOrX endpoints
///     with .NET 10's <c>Microsoft.Extensions.Validation</c> infrastructure.
/// </summary>
/// <remarks>
///     The built-in ValidationsGenerator discovers DTO types from Minimal API handler
///     delegates, but ErrorOrX wraps user handlers behind generated Invoke_EpN delegates
///     whose parameters are HttpContext â€” not the original DTOs. This emitter closes
///     that cross-assembly visibility gap.
/// </remarks>
internal static class ValidationResolverEmitter
{
    public static void Emit(SourceProductionContext spc, ImmutableArray<EndpointDescriptor> endpoints)
    {
        var validatableTypes = CollectValidatableTypes(endpoints);
        if (validatableTypes.Count is 0)
        {
            return;
        }

        var code = new StringBuilder();
        code.AppendLine(GeneratedCodeHelpers.AutoGeneratedHeader("ErrorOr.Generators"));
        code.AppendLine("#pragma warning disable ASP0029 // Type is for evaluation purposes only");
        code.AppendLine(GeneratedCodeHelpers.NullableEnable);
        code.AppendLine();
        code.AppendLine("namespace ErrorOr.Generated");
        code.AppendLine("{");
        code.AppendLine("    using System;");
        code.AppendLine("    using System.Reflection;");
        code.AppendLine("    using System.ComponentModel.DataAnnotations;");

        EmitResolverClass(code, validatableTypes);

        foreach (var type in validatableTypes)
        {
            EmitTypeInfoClass(code, type);
            EmitPropertyInfoClasses(code, type);
        }

        code.AppendLine("}");

        spc.AddSource("ErrorOrValidationResolver.g.cs", SourceText.From(code.ToString(), Encoding.UTF8));
    }

    private static List<ValidatableTypeDescriptor> CollectValidatableTypes(
        ImmutableArray<EndpointDescriptor> endpoints)
    {
        var seen = new HashSet<string>(StringComparer.Ordinal);
        var types = new List<ValidatableTypeDescriptor>();

        foreach (var ep in endpoints)
        {
            foreach (var param in ep.HandlerParameters.AsImmutableArray())
            {
                if (!param.RequiresValidation || param.ValidatableProperties.IsDefaultOrEmpty)
                {
                    continue;
                }

                if (seen.Add(param.TypeFqn))
                {
                    types.Add(new ValidatableTypeDescriptor(param.TypeFqn, param.ValidatableProperties));
                }
            }
        }

        types.Sort(static (a, b) => string.CompareOrdinal(a.TypeFqn, b.TypeFqn));
        return types;
    }

    private static void EmitResolverClass(StringBuilder code, List<ValidatableTypeDescriptor> types)
    {
        code.AppendLine();
        code.AppendLine("    /// <summary>");
        code.AppendLine(
            "    /// Generated IValidatableInfoResolver that provides validation metadata for ErrorOrX endpoint DTOs.");
        code.AppendLine("    /// </summary>");
        code.AppendLine(
            $"    internal sealed class ErrorOrValidatableInfoResolver : {WellKnownTypes.Fqn.ValidatableInfoResolver}");
        code.AppendLine("    {");
        code.AppendLine(
            $"        public bool TryGetValidatableTypeInfo(Type type, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out {WellKnownTypes.Fqn.IValidatableInfo}? validatableInfo)");
        code.AppendLine("        {");

        foreach (var type in types)
        {
            var safeId = type.TypeFqn.SanitizeIdentifier();
            code.AppendLine($"            if (type == typeof({type.TypeFqn}))");
            code.AppendLine("            {");
            code.AppendLine($"                validatableInfo = {safeId}_TypeInfo.Instance;");
            code.AppendLine("                return true;");
            code.AppendLine("            }");
            code.AppendLine();
        }

        code.AppendLine("            validatableInfo = null;");
        code.AppendLine("            return false;");
        code.AppendLine("        }");
        code.AppendLine();
        code.AppendLine(
            $"        public bool TryGetValidatableParameterInfo(ParameterInfo parameterInfo, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out {WellKnownTypes.Fqn.IValidatableInfo}? validatableInfo)");
        code.AppendLine("        {");
        code.AppendLine("            validatableInfo = null;");
        code.AppendLine("            return false;");
        code.AppendLine("        }");
        code.AppendLine("    }");
    }

    private static void EmitTypeInfoClass(StringBuilder code, ValidatableTypeDescriptor type)
    {
        var safeId = type.TypeFqn.SanitizeIdentifier();
        code.AppendLine();
        code.AppendLine(
            $"    internal sealed class {safeId}_TypeInfo : {WellKnownTypes.Fqn.ValidatableTypeInfoBase}");
        code.AppendLine("    {");
        code.AppendLine($"        public static readonly {safeId}_TypeInfo Instance = new();");
        code.AppendLine();
        code.AppendLine(
            $"        private {safeId}_TypeInfo() : base(typeof({type.TypeFqn}), new {WellKnownTypes.Fqn.ValidatablePropertyInfoBase}[]");
        code.AppendLine("        {");

        foreach (var prop in type.Properties.AsImmutableArray())
        {
            var propId = $"{safeId}_{prop.Name}_Prop";
            code.AppendLine($"            new {propId}(),");
        }

        code.AppendLine("        }) { }");
        code.AppendLine();
        code.AppendLine(
            "        protected override ValidationAttribute[] GetValidationAttributes() => [];");
        code.AppendLine("    }");
    }

    private static void EmitPropertyInfoClasses(StringBuilder code, ValidatableTypeDescriptor type)
    {
        var safeId = type.TypeFqn.SanitizeIdentifier();
        foreach (var prop in type.Properties.AsImmutableArray())
        {
            var propId = $"{safeId}_{prop.Name}_Prop";
            code.AppendLine();
            code.AppendLine(
                $"    internal sealed class {propId} : {WellKnownTypes.Fqn.ValidatablePropertyInfoBase}");
            code.AppendLine("    {");
            code.AppendLine(
                $"        public {propId}() : base(typeof({type.TypeFqn}), typeof({prop.TypeFqn}), \"{prop.Name}\", \"{prop.DisplayName}\") {{ }}");
            code.AppendLine();
            code.AppendLine("        protected override ValidationAttribute[] GetValidationAttributes() =>");
            code.AppendLine("        [");

            foreach (var attr in prop.ValidationAttributes.AsImmutableArray())
            {
                var attrExpr = FormatAttributeInstantiation(attr);
                code.AppendLine($"            {attrExpr},");
            }

            code.AppendLine("        ];");
            code.AppendLine("    }");
        }
    }

    private static string FormatAttributeInstantiation(ValidatableAttributeInfo attr)
    {
        var sb = new StringBuilder();
        sb.Append($"new {attr.AttributeTypeFqn}(");

        if (!attr.ConstructorArgLiterals.IsDefaultOrEmpty)
        {
            var first = true;
            foreach (var arg in attr.ConstructorArgLiterals.AsImmutableArray())
            {
                if (!first)
                {
                    sb.Append(", ");
                }

                sb.Append(arg);
                first = false;
            }
        }

        sb.Append(')');

        if (!attr.NamedArgLiterals.IsDefaultOrEmpty)
        {
            sb.Append(" { ");
            var first = true;
            foreach (var named in attr.NamedArgLiterals.AsImmutableArray())
            {
                if (!first)
                {
                    sb.Append(", ");
                }

                sb.Append($"{named.Name} = {named.Value}");
                first = false;
            }

            sb.Append(" }");
        }

        return sb.ToString();
    }

}
