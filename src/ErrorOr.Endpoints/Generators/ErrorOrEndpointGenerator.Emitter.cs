using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace ErrorOr.Endpoints.Generators;

/// <summary>
///     Code emission logic for endpoint mappings.
/// </summary>
public sealed partial class ErrorOrEndpointGenerator
{
    internal static void EmitEndpoints(SourceProductionContext spc, ImmutableArray<EndpointDescriptor> endpoints,
        int maxArity = 6)
    {
        var sorted = SortEndpoints(endpoints);
        var jsonTypes = CollectJsonTypes(sorted);

        EmitGlobalUsings(spc);
        EmitMappings(spc, sorted, jsonTypes.Count > 0, maxArity);

        if (jsonTypes.Count > 0)
            EmitJsonContextSuggestion(spc, jsonTypes);
    }

    private static void EmitGlobalUsings(SourceProductionContext spc)
    {
        const string source = """
            // <auto-generated/>
            global using ErrorOr.Endpoints.Generated;
            """;
        spc.AddSource("ErrorOrEndpoints.GlobalUsings.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private static void EmitMappings(SourceProductionContext spc, ImmutableArray<EndpointDescriptor> endpoints,
        bool hasJsonTypes, int maxArity)
    {
        var code = new StringBuilder();
        code.AppendLine("// <auto-generated>");
        code.AppendLine("// This file was generated by ErrorOr.Generators source generator.");
        code.AppendLine("// Any modifications will be overwritten on next build.");
        code.AppendLine("// </auto-generated>");
        code.AppendLine();
        code.AppendLine("#nullable enable");
        code.AppendLine("using System;");
        code.AppendLine("using System.Linq;");
        code.AppendLine("using System.Threading.Tasks;");
        code.AppendLine("using Microsoft.AspNetCore.Builder;");
        code.AppendLine("using Microsoft.AspNetCore.Http;");
        code.AppendLine("using Microsoft.AspNetCore.Routing;");
        code.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        code.AppendLine();
        code.AppendLine("namespace ErrorOr.Endpoints.Generated");
        code.AppendLine("{");
        code.AppendLine("    /// <summary>");
        code.AppendLine("    /// Generated endpoint mappings for all [ErrorOrEndpoint] handlers in this assembly.");
        code.AppendLine("    /// </summary>");
        code.AppendLine("    public static class ErrorOrEndpointMappings");
        code.AppendLine("    {");
        code.AppendLine("        /// <summary>");
        code.AppendLine("        /// Maps all ErrorOr endpoints to the application's routing table.");
        code.AppendLine("        /// </summary>");
        code.AppendLine("        /// <param name=\"app\">The endpoint route builder to add mappings to.</param>");
        code.AppendLine("        public static void MapErrorOrEndpoints(this IEndpointRouteBuilder app)");
        code.AppendLine("        {");

        for (var i = 0; i < endpoints.Length; i++)
            EmitMapCall(code, endpoints[i], i, maxArity);

        code.AppendLine("        }");
        code.AppendLine();

        if (hasJsonTypes)
            EmitJsonConfigExtension(code);

        for (var i = 0; i < endpoints.Length; i++)
            EmitInvoker(code, endpoints[i], i, maxArity);

        EmitSupportMethods(code);
        code.AppendLine("    }");
        code.AppendLine("}");

        spc.AddSource("ErrorOrEndpointMappings.cs", SourceText.From(code.ToString(), Encoding.UTF8));
    }

    private static void EmitMapCall(StringBuilder code, in EndpointDescriptor ep, int index, int maxArity)
    {
        var successInfo = ResultsUnionTypeBuilder.GetSuccessResponseInfo(
            ep.SuccessTypeFqn,
            ep.SuccessKind,
            ep.HttpMethod,
            ep.IsAcceptedResponse);

        var unionResult = ResultsUnionTypeBuilder.ComputeReturnType(
            ep.SuccessTypeFqn,
            ep.SuccessKind,
            ep.HttpMethod,
            ep.InferredErrorTypes,
            ep.InferredCustomErrors,
            ep.DeclaredProducesErrors,
            maxArity,
            ep.IsAcceptedResponse);

        code.AppendLine(
            $"            // {ep.HttpMethod} {ep.Pattern} -> {ep.HandlerContainingTypeFqn}.{ep.HandlerMethodName}");
        code.AppendLine(
            $"            app.MapMethods(@\"{ep.Pattern}\", new[] {{ \"{ep.HttpMethod}\" }}, (Delegate)Invoke_Ep{index})");

        var className = ExtractTypeName(ep.HandlerContainingTypeFqn);
        var tagName = className.EndsWith("Endpoints") ? className[..^"Endpoints".Length] : className;
        var operationId = $"{tagName}_{ep.HandlerMethodName}";

        code.AppendLine($"            .WithName(\"{operationId}\")");
        code.AppendLine($"            .WithTags(\"{tagName}\")");

        var bodyParam = ep.HandlerParameters.AsImmutableArray()
            .FirstOrDefault(static p => p.Source == EndpointParameterSource.Body);
        if (bodyParam.Name is not null)
            code.AppendLine($"            .Accepts<{bodyParam.TypeFqn}>(\"application/json\")");
        else if (HasFormParams(ep))
            code.AppendLine("            .Accepts(typeof(object), \"multipart/form-data\")");

        if (ep.IsSse)
            code.AppendLine(
                $"            .WithMetadata(new {WellKnownTypes.Fqn.ProducesResponseTypeAttribute}(200) {{ ContentTypes = new[] {{ \"text/event-stream\" }} }})");
        else if (!unionResult.CanUseUnion)
        {
            code.AppendLine(successInfo.HasBody
                ? $"            .Produces<{ep.SuccessTypeFqn}>({successInfo.StatusCode})"
                : $"            .Produces({successInfo.StatusCode})");

            foreach (var statusCode in unionResult.ExplicitProduceCodes.AsImmutableArray().Distinct()
                         .OrderBy(static x => x))
                code.AppendLine(statusCode == 400
                    ? "            .ProducesValidationProblem()"
                    : $"            .ProducesProblem({statusCode})");
        }

        code.AppendLine("            ;");
        code.AppendLine();
    }

    private static void EmitInvoker(StringBuilder code, in EndpointDescriptor ep, int index, int maxArity)
    {
        var successInfo = ResultsUnionTypeBuilder.GetSuccessResponseInfo(
            ep.SuccessTypeFqn,
            ep.SuccessKind,
            ep.HttpMethod,
            ep.IsAcceptedResponse);

        var unionResult = ResultsUnionTypeBuilder.ComputeReturnType(
            ep.SuccessTypeFqn,
            ep.SuccessKind,
            ep.HttpMethod,
            ep.InferredErrorTypes,
            ep.InferredCustomErrors,
            ep.DeclaredProducesErrors,
            maxArity,
            ep.IsAcceptedResponse);

        var needsAwait = ep.IsAsync || HasFormParams(ep) || HasBodyParam(ep) || HasBindAsyncParam(ep);

        var bodyCode = new StringBuilder();
        var usedBindFail = HasFormParams(ep);

        if (usedBindFail)
            EmitFormContentTypeGuard(bodyCode);

        var args = new StringBuilder();
        for (var i = 0; i < ep.HandlerParameters.Length; i++)
        {
            var param = ep.HandlerParameters[i];
            usedBindFail |= EmitParameterBinding(bodyCode, in param, $"p{i}", "BindFail");
            if (i > 0) args.Append(", ");
            args.Append(BuildArgumentExpression(in param, $"p{i}"));
        }

        var awaitKeyword = ep.IsAsync ? "await " : "";
        bodyCode.AppendLine(
            $"            var result = {awaitKeyword}{ep.HandlerContainingTypeFqn}.{ep.HandlerMethodName}({args});");

        string WrapReturn(string expr) =>
            needsAwait ? expr : $"Task.FromResult<{unionResult.ReturnTypeFqn}>({expr})";

        if (ep.IsSse)
        {
            bodyCode.AppendLine($"            if (result.IsError) return {WrapReturn("ToProblem(result.Errors)")};");
            bodyCode.AppendLine($"            return {WrapReturn("TypedResults.ServerSentEvents(result.Value)")};");
        }
        else if (unionResult.CanUseUnion)
            EmitUnionTypeErrorHandling(bodyCode, ep, unionResult.ReturnTypeFqn, successInfo, needsAwait);
        else
            bodyCode.AppendLine(
                $"            return {WrapReturn($"result.Match<{WellKnownTypes.Fqn.Result}>({successInfo.MatchFactory}, errors => ToProblem(errors))")};");

        code.AppendLine(
            needsAwait
                ? $"        private static async Task<{unionResult.ReturnTypeFqn}> Invoke_Ep{index}(HttpContext ctx)"
                : $"        private static Task<{unionResult.ReturnTypeFqn}> Invoke_Ep{index}(HttpContext ctx)");

        code.AppendLine("        {");

        if (usedBindFail)
            EmitBindFailHelper(code, unionResult.ReturnTypeFqn, needsAwait);

        code.Append(bodyCode);
        code.AppendLine("        }");
        code.AppendLine();
    }

    private static bool HasBodyParam(in EndpointDescriptor ep) =>
        ep.HandlerParameters.AsImmutableArray().Any(static p => p.Source == EndpointParameterSource.Body);

    private static bool HasBindAsyncParam(in EndpointDescriptor ep) =>
        ep.HandlerParameters.AsImmutableArray().Any(static p =>
            p.CustomBinding is CustomBindingMethod.BindAsync or CustomBindingMethod.BindAsyncWithParam);

    private static void EmitBindFailHelper(StringBuilder code, string returnTypeFqn, bool isAsync)
    {
        code.AppendLine(
            $"            static {WellKnownTypes.Fqn.ProblemDetails} CreateBindProblem(string param, string reason) => new()");
        code.AppendLine("            {");
        code.AppendLine("                Title = \"Bad Request\",");
        code.AppendLine("                Detail = $\"Parameter '{param}' {reason}.\",");
        code.AppendLine("                Status = 400,");
        code.AppendLine("                Type = \"https://httpstatuses.io/400\",");
        code.AppendLine("            };");
        code.AppendLine();

        var badRequestExpr = "TypedResults.BadRequest(CreateBindProblem(param, reason))";
        var returnExpr = isAsync ? badRequestExpr : $"Task.FromResult<{returnTypeFqn}>({badRequestExpr})";
        var returnType = isAsync ? returnTypeFqn : $"Task<{returnTypeFqn}>";

        code.AppendLine($"            static {returnType} BindFail(string param, string reason)");
        code.AppendLine($"                => {returnExpr};");
        code.AppendLine();
    }

    private static void EmitUnionTypeErrorHandling(
        StringBuilder code,
        in EndpointDescriptor ep,
        string returnType,
        SuccessResponseInfo successInfo,
        bool needsAwait)
    {
        string WrapReturn(string expr) =>
            needsAwait ? expr : $"Task.FromResult<{returnType}>({expr})";

        code.AppendLine("            if (result.IsError)");
        code.AppendLine("            {");
        code.AppendLine("                var first = result.FirstError;");

        EmitValidationHandling(code, ep, WrapReturn);
        EmitProblemDetailsBuilding(code);
        EmitErrorTypeSwitch(code, ep, WrapReturn);

        code.AppendLine("            }");
        code.AppendLine();

        code.AppendLine($"            return {WrapReturn(successInfo.Factory)};");
    }

    private static void EmitValidationHandling(StringBuilder code, in EndpointDescriptor ep,
        Func<string, string> wrapReturn)
    {
        var hasValidation = !ep.InferredErrorTypes.IsDefaultOrEmpty &&
                            ep.InferredErrorTypes.AsImmutableArray().Contains((int)ErrorType.Validation);

        if (!hasValidation) return;

        code.AppendLine($"                if (first.Type == {WellKnownTypes.Fqn.ErrorType}.Validation)");
        code.AppendLine("                {");
        code.AppendLine(
            $"                    var validationDict = new {WellKnownTypes.Fqn.Dictionary}<string, string[]>();");
        code.AppendLine("                    foreach (var e in result.Errors)");
        code.AppendLine("                    {");
        code.AppendLine(
            $"                        if (e.Type != {WellKnownTypes.Fqn.ErrorType}.Validation) continue;");
        code.AppendLine("                        if (!validationDict.TryGetValue(e.Code, out var existing))");
        code.AppendLine("                            validationDict[e.Code] = new[] { e.Description };");
        code.AppendLine("                        else");
        code.AppendLine("                        {");
        code.AppendLine("                            var arr = new string[existing.Length + 1];");
        code.AppendLine("                            existing.CopyTo(arr, 0);");
        code.AppendLine("                            arr[existing.Length] = e.Description;");
        code.AppendLine("                            validationDict[e.Code] = arr;");
        code.AppendLine("                        }");
        code.AppendLine("                    }");
        code.AppendLine($"                    return {wrapReturn("TypedResults.ValidationProblem(validationDict)")};");
        code.AppendLine("                }");
    }

    private static void EmitProblemDetailsBuilding(StringBuilder code)
    {
        code.AppendLine($"                var problem = new {WellKnownTypes.Fqn.ProblemDetails}");
        code.AppendLine("                {");
        code.AppendLine("                    Title = first.Code,");
        code.AppendLine("                    Detail = first.Description,");
        code.AppendLine(
            $"                    Status = first.Type switch {{ {ErrorMapping.GenerateStatusSwitch(WellKnownTypes.Fqn.ErrorType)} }}");
        code.AppendLine("                };");
        code.AppendLine("                problem.Type = $\"https://httpstatuses.io/{problem.Status}\";");
        code.AppendLine();
    }

    private static void EmitErrorTypeSwitch(StringBuilder code, in EndpointDescriptor ep,
        Func<string, string> wrapReturn)
    {
        code.AppendLine("                switch (first.Type)");
        code.AppendLine("                {");

        if (!ep.InferredErrorTypes.IsDefaultOrEmpty)
        {
            foreach (var errorTypeInt in ep.InferredErrorTypes.AsImmutableArray()
                         .Where(static e => e != (int)ErrorType.Validation)
                         .Distinct()
                         .OrderBy(static x => x))
            {
                var errorType = Enum.IsDefined(typeof(ErrorType), errorTypeInt)
                    ? (ErrorType)errorTypeInt
                    : ErrorType.Failure;
                var enumName = errorType.ToString();

                var factory = errorType switch
                {
                    ErrorType.Unauthorized => "TypedResults.Unauthorized()",
                    ErrorType.Forbidden => "TypedResults.Forbid()",
                    ErrorType.NotFound => "TypedResults.NotFound(problem)",
                    ErrorType.Conflict => "TypedResults.Conflict(problem)",
                    _ => "TypedResults.InternalServerError(problem)"
                };

                code.AppendLine($"                    case {WellKnownTypes.Fqn.ErrorType}.{enumName}:");
                code.AppendLine($"                        return {wrapReturn(factory)};");
            }
        }

        code.AppendLine("                    default:");
        code.AppendLine($"                        return {wrapReturn("TypedResults.InternalServerError(problem)")};");
        code.AppendLine("                }");
    }

    /// <summary>
    ///     Emits parameter binding code and returns whether BindFail helper is used.
    /// </summary>
    private static bool EmitParameterBinding(StringBuilder code, in EndpointParameter param, string paramName,
        string bindFailFn) =>
        param.Source switch
        {
            EndpointParameterSource.Route => EmitRouteBinding(code, in param, paramName, bindFailFn),
            EndpointParameterSource.Query => EmitQueryBinding(code, in param, paramName, bindFailFn),
            EndpointParameterSource.Header => EmitHeaderBinding(code, in param, paramName, bindFailFn),
            EndpointParameterSource.Body => EmitBodyBinding(code, in param, paramName, bindFailFn),
            EndpointParameterSource.Service => EmitServiceBinding(code, in param, paramName),
            EndpointParameterSource.KeyedService => EmitKeyedServiceBinding(code, in param, paramName),
            EndpointParameterSource.HttpContext => EmitHttpContextBinding(code, paramName),
            EndpointParameterSource.CancellationToken => EmitCancellationTokenBinding(code, paramName),
            EndpointParameterSource.Stream => EmitStreamBinding(code, paramName),
            EndpointParameterSource.PipeReader => EmitPipeReaderBinding(code, paramName),
            EndpointParameterSource.FormFile => EmitFormFileBinding(code, in param, paramName, bindFailFn),
            EndpointParameterSource.FormFiles => EmitFormFilesBinding(code, paramName),
            EndpointParameterSource.FormCollection => EmitFormCollectionBinding(code, paramName),
            EndpointParameterSource.Form => EmitFormBinding(code, in param, paramName, bindFailFn),
            EndpointParameterSource.AsParameters => EmitAsParametersBinding(code, in param, paramName, bindFailFn),
            _ => false
        };

    private static bool EmitServiceBinding(StringBuilder code, in EndpointParameter param, string paramName)
    {
        code.AppendLine($"            var {paramName} = ctx.RequestServices.GetRequiredService<{param.TypeFqn}>();");
        return false;
    }

    private static bool EmitKeyedServiceBinding(StringBuilder code, in EndpointParameter param, string paramName)
    {
        code.AppendLine(
            $"            var {paramName} = ctx.RequestServices.GetRequiredKeyedService<{param.TypeFqn}>({param.KeyName});");
        return false;
    }

    private static bool EmitHttpContextBinding(StringBuilder code, string paramName)
    {
        code.AppendLine($"            var {paramName} = ctx;");
        return false;
    }

    private static bool EmitCancellationTokenBinding(StringBuilder code, string paramName)
    {
        code.AppendLine($"            var {paramName} = ctx.RequestAborted;");
        return false;
    }

    private static bool EmitStreamBinding(StringBuilder code, string paramName)
    {
        code.AppendLine($"            var {paramName} = ctx.Request.Body;");
        return false;
    }

    private static bool EmitPipeReaderBinding(StringBuilder code, string paramName)
    {
        code.AppendLine($"            var {paramName} = ctx.Request.BodyReader;");
        return false;
    }

    private static bool EmitFormFilesBinding(StringBuilder code, string paramName)
    {
        code.AppendLine($"            var {paramName} = form.Files;");
        return false;
    }

    private static bool EmitFormCollectionBinding(StringBuilder code, string paramName)
    {
        code.AppendLine($"            var {paramName} = form;");
        return false;
    }

    private static bool EmitFormFileBinding(StringBuilder code, in EndpointParameter param, string paramName,
        string bindFailFn)
    {
        code.AppendLine($"            var {paramName} = form.Files.GetFile(\"{param.KeyName ?? param.Name}\");");
        if (param.IsNullable) return false;

        code.AppendLine(
            $"            if ({paramName} is null) return {bindFailFn}(\"{param.Name}\", \"is required\");");
        return true;
    }

    private static bool EmitRouteBinding(StringBuilder code, in EndpointParameter param, string paramName,
        string bindFailFn)
    {
        var routeName = param.KeyName ?? param.Name;
        code.AppendLine(
            IsStringType(param.TypeFqn)
                ? $"            if (!TryGetRouteValue(ctx, \"{routeName}\", out var {paramName})) return {bindFailFn}(\"{param.Name}\", \"is missing from route\");"
                : $"            if (!TryGetRouteValue(ctx, \"{routeName}\", out var {paramName}Raw) || !{GetTryParseExpression(param.TypeFqn, paramName + "Raw", paramName, param.CustomBinding)}) return {bindFailFn}(\"{param.Name}\", \"has invalid format\");");
        return true;
    }

    private static bool EmitQueryBinding(StringBuilder code, in EndpointParameter param, string paramName,
        string bindFailFn)
    {
        if (param.CustomBinding is CustomBindingMethod.BindAsync or CustomBindingMethod.BindAsyncWithParam)
            return EmitBindAsyncBinding(code, in param, paramName, bindFailFn);

        var queryKey = param.KeyName ?? param.Name;
        return param is { IsCollection: true, CollectionItemTypeFqn: { } itemType }
            ? EmitCollectionQueryBinding(code, in param, paramName, queryKey, itemType, bindFailFn)
            : EmitScalarQueryBinding(code, in param, paramName, queryKey, bindFailFn);
    }

    private static bool EmitBindAsyncBinding(StringBuilder code, in EndpointParameter param, string paramName,
        string bindFailFn)
    {
        var baseType = param.TypeFqn.TrimEnd('?');
        code.AppendLine($"            var {paramName} = await {baseType}.BindAsync(ctx);");
        if (param.IsNullable) return false;

        code.AppendLine(
            $"            if ({paramName} is null) return {bindFailFn}(\"{param.Name}\", \"binding failed\");");
        return true;
    }

    private static bool EmitCollectionQueryBinding(StringBuilder code, in EndpointParameter param, string paramName,
        string queryKey, string itemType, string bindFailFn)
    {
        code.AppendLine($"            var {paramName}Raw = ctx.Request.Query[\"{queryKey}\"];");
        code.AppendLine($"            var {paramName}List = new {WellKnownTypes.Fqn.List}<{itemType}>();");
        code.AppendLine($"            foreach (var item in {paramName}Raw)");
        code.AppendLine("            {");

        var usesBindFail = false;
        if (IsStringType(itemType))
            code.AppendLine(
                $"                if (item is {{ Length: > 0 }} validItem) {paramName}List.Add(validItem);");
        else
        {
            usesBindFail = true;
            code.AppendLine(
                $"                if ({GetTryParseExpression(itemType, "item", "parsedItem")}) {paramName}List.Add(parsedItem);");
            code.AppendLine(
                $"                else if (!string.IsNullOrEmpty(item)) return {bindFailFn}(\"{param.Name}\", \"has invalid item format\");");
        }

        code.AppendLine("            }");
        var isArray = param.TypeFqn.EndsWith("[]");
        var assignment = isArray ? $"{paramName}List.ToArray()" : $"{paramName}List";
        code.AppendLine($"            var {paramName} = {assignment};");
        return usesBindFail;
    }

    private static bool EmitScalarQueryBinding(StringBuilder code, in EndpointParameter param, string paramName,
        string queryKey, string bindFailFn)
    {
        var usesBindFail = false;
        var declType = param.TypeFqn.EndsWith("?") ? param.TypeFqn : param.TypeFqn + "?";
        code.AppendLine($"            {declType} {paramName};");
        code.AppendLine($"            if (!TryGetQueryValue(ctx, \"{queryKey}\", out var {paramName}Raw))");
        code.AppendLine("            {");
        if (param.IsNullable)
            code.AppendLine($"                {paramName} = default;");
        else
        {
            usesBindFail = true;
            code.AppendLine($"                return {bindFailFn}(\"{param.Name}\", \"is required\");");
        }

        code.AppendLine("            }");
        code.AppendLine("            else");
        code.AppendLine("            {");
        if (IsStringType(param.TypeFqn))
            code.AppendLine($"                {paramName} = {paramName}Raw;");
        else
        {
            usesBindFail = true;
            code.AppendLine(
                $"                if (!{GetTryParseExpression(param.TypeFqn, paramName + "Raw", paramName + "Temp", param.CustomBinding)}) return {bindFailFn}(\"{param.Name}\", \"has invalid format\");");
            code.AppendLine($"                {paramName} = {paramName}Temp;");
        }

        code.AppendLine("            }");
        return usesBindFail;
    }

    private static bool EmitHeaderBinding(StringBuilder code, in EndpointParameter param, string paramName,
        string bindFailFn)
    {
        var key = param.KeyName ?? param.Name;
        var usesBindFail = false;

        if (param is { IsCollection: true, CollectionItemTypeFqn: { } itemType })
        {
            code.AppendLine($"            {param.TypeFqn} {paramName};");
            code.AppendLine(
                $"            if (!ctx.Request.Headers.TryGetValue(\"{key}\", out var {paramName}Raw) || {paramName}Raw.Count is 0)");
            code.AppendLine("            {");
            if (param.IsNullable)
                code.AppendLine($"                {paramName} = default!;");
            else
            {
                usesBindFail = true;
                code.AppendLine($"                return {bindFailFn}(\"{param.Name}\", \"is required\");");
            }

            code.AppendLine("            }");
            code.AppendLine("            else");
            code.AppendLine("            {");
            code.AppendLine($"                var {paramName}List = new {WellKnownTypes.Fqn.List}<{itemType}>();");
            code.AppendLine($"                foreach (var item in {paramName}Raw)");
            code.AppendLine("                {");
            if (IsStringType(itemType))
                code.AppendLine(
                    $"                    if (item is {{ Length: > 0 }} validItem) {paramName}List.Add(validItem);");
            else
                code.AppendLine(
                    $"                    if ({GetTryParseExpression(itemType, "item", "parsedItem")}) {paramName}List.Add(parsedItem);");
            code.AppendLine("                }");
            var isArray = param.TypeFqn.EndsWith("[]");
            var assignment = isArray ? $"{paramName}List.ToArray()" : $"{paramName}List";
            code.AppendLine($"                {paramName} = {assignment};");
            code.AppendLine("            }");
        }
        else
        {
            var declType = param.TypeFqn.EndsWith("?") ? param.TypeFqn : param.TypeFqn + "?";
            code.AppendLine($"            {declType} {paramName};");
            code.AppendLine(
                $"            if (!ctx.Request.Headers.TryGetValue(\"{key}\", out var {paramName}Raw) || {paramName}Raw.Count is 0)");
            code.AppendLine("            {");
            if (param.IsNullable)
                code.AppendLine($"                {paramName} = default;");
            else
            {
                usesBindFail = true;
                code.AppendLine($"                return {bindFailFn}(\"{param.Name}\", \"is required\");");
            }

            code.AppendLine("            }");
            code.AppendLine("            else");
            code.AppendLine("            {");
            if (IsStringType(param.TypeFqn))
                code.AppendLine($"                {paramName} = {paramName}Raw.ToString();");
            else
            {
                usesBindFail = true;
                code.AppendLine(
                    $"                if (!{GetTryParseExpression(param.TypeFqn, paramName + "Raw.ToString()", paramName + "Temp")}) return {bindFailFn}(\"{param.Name}\", \"has invalid format\"); {paramName} = {paramName}Temp;");
            }

            code.AppendLine("            }");
        }

        return usesBindFail;
    }

    private static bool EmitBodyBinding(StringBuilder code, in EndpointParameter param, string paramName,
        string bindFailFn)
    {
        code.AppendLine($"            {param.TypeFqn}? {paramName};");
        code.AppendLine("            try");
        code.AppendLine("            {");
        code.AppendLine(
            $"                {paramName} = await ctx.Request.ReadFromJsonAsync<{param.TypeFqn}>(cancellationToken: ctx.RequestAborted);");
        code.AppendLine("            }");
        code.AppendLine($"            catch ({WellKnownTypes.Fqn.JsonException})");
        code.AppendLine("            {");
        code.AppendLine($"                return {bindFailFn}(\"{param.Name}\", \"has invalid JSON format\");");
        code.AppendLine("            }");
        code.AppendLine(
            $"            if ({paramName} is null) return {bindFailFn}(\"{param.Name}\", \"is required\");");
        return true;
    }

    private static bool EmitFormBinding(StringBuilder code, in EndpointParameter param, string paramName,
        string bindFailFn)
    {
        if (!param.Children.IsDefaultOrEmpty)
        {
            var usesBindFail = false;
            for (var i = 0; i < param.Children.Length; i++)
            {
                var child = param.Children[i];
                usesBindFail |= EmitParameterBinding(code, in child, $"{paramName}_f{i}", bindFailFn);
            }

            var args = string.Join(", ", param.Children.AsImmutableArray().Select((_, i) => $"{paramName}_f{i}"));
            code.AppendLine($"            var {paramName} = new {param.TypeFqn}({args});");
            return usesBindFail;
        }

        var usesBindFailScalar = false;
        var fieldName = param.KeyName ?? param.Name;
        var declType = param.IsNullable && !param.TypeFqn.EndsWith("?") ? param.TypeFqn + "?" : param.TypeFqn;
        code.AppendLine($"            {declType} {paramName};");
        code.AppendLine(
            $"            if (!form.TryGetValue(\"{fieldName}\", out var {paramName}Raw) || {paramName}Raw.Count is 0)");
        code.AppendLine("            {");
        if (param.IsNullable)
            code.AppendLine($"                {paramName} = default;");
        else
        {
            usesBindFailScalar = true;
            code.AppendLine($"                return {bindFailFn}(\"{param.Name}\", \"is required\");");
        }

        code.AppendLine("            }");
        code.AppendLine("            else");
        code.AppendLine("            {");
        if (IsStringType(param.TypeFqn))
            code.AppendLine($"                {paramName} = {paramName}Raw.ToString();");
        else
        {
            usesBindFailScalar = true;
            code.AppendLine(
                $"                if (!{GetTryParseExpression(param.TypeFqn, paramName + "Raw.ToString()", paramName + "Temp")}) return {bindFailFn}(\"{param.Name}\", \"has invalid format\");");
            code.AppendLine($"                {paramName} = {paramName}Temp;");
        }

        code.AppendLine("            }");
        return usesBindFailScalar;
    }

    private static bool EmitAsParametersBinding(StringBuilder code, in EndpointParameter param, string paramName,
        string bindFailFn)
    {
        var usesBindFail = false;
        var childVars = new List<string>();
        for (var i = 0; i < param.Children.Length; i++)
        {
            var child = param.Children[i];
            var childVarName = $"{paramName}_c{i}";
            usesBindFail |= EmitParameterBinding(code, in child, childVarName, bindFailFn);
            childVars.Add(BuildArgumentExpression(in child, childVarName));
        }

        code.AppendLine($"            var {paramName} = new {param.TypeFqn}({string.Join(", ", childVars)});");
        return usesBindFail;
    }

    private static void EmitFormContentTypeGuard(StringBuilder code)
    {
        code.AppendLine(
            "            if (!ctx.Request.HasFormContentType) return BindFail(\"form\", \"content-type must be multipart/form-data\");");
        code.AppendLine("            var form = await ctx.Request.ReadFormAsync(ctx.RequestAborted);");
        code.AppendLine();
    }

    private static void EmitJsonConfigExtension(StringBuilder code)
    {
        code.AppendLine(
            "        public static IServiceCollection AddErrorOrEndpointJson<TContext>(this IServiceCollection services)");
        code.AppendLine("            where TContext : System.Text.Json.Serialization.JsonSerializerContext, new()");
        code.AppendLine("        {");
        code.AppendLine("            var context = new TContext();");
        code.AppendLine(
            "            services.ConfigureHttpJsonOptions(options => options.SerializerOptions.TypeInfoResolverChain.Insert(0, context));");
        code.AppendLine("            return services;");
        code.AppendLine("        }");
        code.AppendLine();
    }

    private static void EmitJsonContextSuggestion(SourceProductionContext spc, List<string> jsonTypes)
    {
        var code = new StringBuilder();
        code.AppendLine("// SUGGESTED JSON CONTEXT FOR NATIVE AOT");
        code.AppendLine("#if ERROROR_JSON");
        code.AppendLine(
            "[System.Text.Json.Serialization.JsonSourceGenerationOptions(DefaultIgnoreCondition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull)]");
        foreach (var type in jsonTypes)
            code.AppendLine($"[System.Text.Json.Serialization.JsonSerializable(typeof({type}))]");
        code.AppendLine(
            $"[System.Text.Json.Serialization.JsonSerializable(typeof({WellKnownTypes.Fqn.ProblemDetails}))]");
        code.AppendLine(
            $"[System.Text.Json.Serialization.JsonSerializable(typeof({WellKnownTypes.Fqn.HttpValidationProblemDetails}))]");
        code.AppendLine(
            "internal partial class ErrorOrJsonContext : System.Text.Json.Serialization.JsonSerializerContext { }");
        code.AppendLine("#endif");
        spc.AddSource("ErrorOrJsonContext.suggested.cs", SourceText.From(code.ToString(), Encoding.UTF8));
    }

    private static void EmitSupportMethods(StringBuilder code)
    {
        code.AppendLine(
            "        private static bool TryGetRouteValue(HttpContext ctx, string name, out string? value)");
        code.AppendLine("        {");
        code.AppendLine(
            "            if (!ctx.Request.RouteValues.TryGetValue(name, out var raw) || raw is null) { value = null; return false; }");
        code.AppendLine("            value = raw.ToString(); return value is not null;");
        code.AppendLine("        }");
        code.AppendLine();
        code.AppendLine(
            "        private static bool TryGetQueryValue(HttpContext ctx, string name, out string? value)");
        code.AppendLine("        {");
        code.AppendLine(
            "            if (!ctx.Request.Query.TryGetValue(name, out var raw) || raw.Count is 0) { value = null; return false; }");
        code.AppendLine("            value = raw.ToString(); return value is not null;");
        code.AppendLine("        }");
        code.AppendLine();
        code.AppendLine(
            $"        private static {WellKnownTypes.Fqn.Result} ToProblem({WellKnownTypes.Fqn.ReadOnlyList}<{WellKnownTypes.Fqn.Error}> errors)");
        code.AppendLine("        {");
        code.AppendLine("            if (errors.Count is 0) return TypedResults.Problem();");
        code.AppendLine("            var hasValidation = false;");
        code.AppendLine(
            $"            for (var i = 0; i < errors.Count; i++) if (errors[i].Type == {WellKnownTypes.Fqn.ErrorType}.Validation) {{ hasValidation = true; break; }}");
        code.AppendLine("            if (hasValidation)");
        code.AppendLine("            {");
        code.AppendLine($"                var dict = new {WellKnownTypes.Fqn.Dictionary}<string, string[]>();");
        code.AppendLine("                for (var i = 0; i < errors.Count; i++)");
        code.AppendLine("                {");
        code.AppendLine(
            $"                    var e = errors[i]; if (e.Type != {WellKnownTypes.Fqn.ErrorType}.Validation) continue;");
        code.AppendLine(
            "                    if (!dict.TryGetValue(e.Code, out var existing)) dict[e.Code] = new[] { e.Description };");
        code.AppendLine(
            "                    else { var n = new string[existing.Length + 1]; existing.CopyTo(n, 0); n[existing.Length] = e.Description; dict[e.Code] = n; }");
        code.AppendLine("                }");
        code.AppendLine("                return TypedResults.ValidationProblem(dict);");
        code.AppendLine("            }");
        code.AppendLine("            var first = errors[0];");
        code.AppendLine($"            var problem = new {WellKnownTypes.Fqn.ProblemDetails}");
        code.AppendLine("            {");
        code.AppendLine("                Title = first.Code,");
        code.AppendLine("                Detail = first.Description,");
        code.AppendLine(
            $"                Status = first.Type switch {{ {ErrorMapping.GenerateStatusSwitch(WellKnownTypes.Fqn.ErrorType)} }}");
        code.AppendLine("            };");
        code.AppendLine("            problem.Type = $\"https://httpstatuses.io/{problem.Status}\";");
        code.AppendLine("            return problem.Status switch");
        code.AppendLine("            {");
        code.AppendLine("                401 => TypedResults.Unauthorized(),");
        code.AppendLine("                403 => TypedResults.Forbid(),");
        code.AppendLine("                404 => TypedResults.NotFound(problem),");
        code.AppendLine("                409 => TypedResults.Conflict(problem),");
        code.AppendLine("                422 => TypedResults.UnprocessableEntity(problem),");
        code.AppendLine("                500 => TypedResults.InternalServerError(problem),");
        code.AppendLine(
            "                _ => TypedResults.Problem(detail: first.Description, statusCode: problem.Status ?? 500, title: first.Code, type: problem.Type)");
        code.AppendLine("            };");
        code.AppendLine("        }");
    }

    private static string BuildArgumentExpression(in EndpointParameter param, string paramName) =>
        param.Source switch
        {
            EndpointParameterSource.Body when !param.IsNullable => paramName + "!",
            EndpointParameterSource.Route when param is { IsNullable: false, IsNonNullableValueType: false } =>
                paramName + "!",
            EndpointParameterSource.Query when param is { IsNullable: false, IsNonNullableValueType: true } =>
                paramName + ".Value",
            EndpointParameterSource.Header when param is { IsNullable: false, IsNonNullableValueType: true } =>
                paramName + ".Value",
            EndpointParameterSource.Query when param is { IsNullable: false, IsNonNullableValueType: false } =>
                paramName + "!",
            EndpointParameterSource.Header when param is { IsNullable: false, IsNonNullableValueType: false } =>
                paramName + "!",
            _ => paramName
        };

    private static string GetTryParseExpression(string typeFqn, string rawName, string outputName,
        CustomBindingMethod customBinding = CustomBindingMethod.None)
    {
        if (customBinding is CustomBindingMethod.TryParse or CustomBindingMethod.TryParseWithFormat)
        {
            var baseType = typeFqn.TrimEnd('?');
            return $"{baseType}.TryParse({rawName}, out var {outputName})";
        }

        var normalized = typeFqn.Replace("global::", "").TrimEnd('?');
        return normalized switch
        {
            "System.Int32" or "int" => $"int.TryParse({rawName}, out var {outputName})",
            "System.Int64" or "long" => $"long.TryParse({rawName}, out var {outputName})",
            "System.Int16" or "short" => $"short.TryParse({rawName}, out var {outputName})",
            "System.Byte" or "byte" => $"byte.TryParse({rawName}, out var {outputName})",
            "System.SByte" or "sbyte" => $"sbyte.TryParse({rawName}, out var {outputName})",
            "System.UInt16" or "ushort" => $"ushort.TryParse({rawName}, out var {outputName})",
            "System.UInt32" or "uint" => $"uint.TryParse({rawName}, out var {outputName})",
            "System.UInt64" or "ulong" => $"ulong.TryParse({rawName}, out var {outputName})",
            "System.Boolean" or "bool" => $"bool.TryParse({rawName}, out var {outputName})",
            "System.Guid" => $"global::System.Guid.TryParse({rawName}, out var {outputName})",
            "System.DateTime" => $"global::System.DateTime.TryParse({rawName}, out var {outputName})",
            "System.DateTimeOffset" => $"global::System.DateTimeOffset.TryParse({rawName}, out var {outputName})",
            "System.TimeSpan" => $"global::System.TimeSpan.TryParse({rawName}, out var {outputName})",
            "System.DateOnly" => $"global::System.DateOnly.TryParse({rawName}, out var {outputName})",
            "System.TimeOnly" => $"global::System.TimeOnly.TryParse({rawName}, out var {outputName})",
            "System.Double" or "double" => $"double.TryParse({rawName}, out var {outputName})",
            "System.Single" or "float" => $"float.TryParse({rawName}, out var {outputName})",
            "System.Decimal" or "decimal" => $"decimal.TryParse({rawName}, out var {outputName})",
            _ => "false"
        };
    }

    private static bool IsStringType(string typeFqn) =>
        typeFqn is "global::System.String" or "System.String" or "string";

    private static bool HasFormParams(in EndpointDescriptor ep) =>
        ep.HandlerParameters.AsImmutableArray().Any(static p =>
            p.Source is EndpointParameterSource.Form or EndpointParameterSource.FormFile
                or EndpointParameterSource.FormFiles or EndpointParameterSource.FormCollection);

    private static string ExtractTypeName(string fqn)
    {
        var i = fqn.LastIndexOf('.');
        var n = i >= 0 ? fqn[(i + 1)..] : fqn;
        return n.StartsWith("::") ? n[2..] : n;
    }

    private static ImmutableArray<EndpointDescriptor> SortEndpoints(ImmutableArray<EndpointDescriptor> endpoints)
    {
        var list = new EndpointDescriptor[endpoints.Length];
        endpoints.CopyTo(list);
        Array.Sort(list, static (a, b) =>
        {
            var c = string.CompareOrdinal(a.HttpMethod, b.HttpMethod);
            if (c is not 0) return c;
            c = string.CompareOrdinal(a.Pattern, b.Pattern);
            return c is not 0 ? c : string.CompareOrdinal(a.HandlerMethodName, b.HandlerMethodName);
        });
        return [.. list];
    }

    private static List<string> CollectJsonTypes(ImmutableArray<EndpointDescriptor> endpoints)
    {
        var types = new HashSet<string>(StringComparer.Ordinal);
        foreach (var ep in endpoints)
        {
            foreach (var p in ep.HandlerParameters)
                if (p.Source == EndpointParameterSource.Body)
                    types.Add(p.TypeFqn);

            if (ep is { IsSse: true, SseItemTypeFqn: not null })
                types.Add(ep.SseItemTypeFqn);
            else
            {
                var successInfo = ResultsUnionTypeBuilder.GetSuccessResponseInfo(
                    ep.SuccessTypeFqn,
                    ep.SuccessKind,
                    ep.HttpMethod,
                    ep.IsAcceptedResponse);
                if (successInfo.HasBody)
                    types.Add(ep.SuccessTypeFqn);
            }
        }

        var sorted = types.ToList();
        sorted.Sort(StringComparer.Ordinal);
        return sorted;
    }
}