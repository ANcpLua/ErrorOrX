//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#nullable enable
// Suppress warnings about obsolete types and members
// in generated code
#pragma warning disable CS0612, CS0618

namespace System.Runtime.CompilerServices
{
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.AspNetCore.OpenApi.SourceGenerators, Version=10.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60", "10.0.0.0")]
    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
    file sealed class InterceptsLocationAttribute : System.Attribute
    {
        public InterceptsLocationAttribute(int version, string data)
        {
        }
    }
}

namespace Microsoft.AspNetCore.OpenApi.Generated
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics.CodeAnalysis;
    using System.Globalization;
    using System.Linq;
    using System.Reflection;
    using System.Text;
    using System.Text.Json;
    using System.Text.Json.Nodes;
    using System.Threading;
    using System.Threading.Tasks;
    using Microsoft.AspNetCore.OpenApi;
    using Microsoft.AspNetCore.Mvc.Controllers;
    using Microsoft.AspNetCore.Mvc.ModelBinding.Metadata;
    using Microsoft.Extensions.DependencyInjection;
    using Microsoft.OpenApi;

    [System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.AspNetCore.OpenApi.SourceGenerators, Version=10.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60", "10.0.0.0")]
    file record XmlComment(
        string? Summary,
        string? Description,
        string? Remarks,
        string? Returns,
        string? Value,
        bool Deprecated,
        List<string>? Examples,
        List<XmlParameterComment>? Parameters,
        List<XmlResponseComment>? Responses);

    [System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.AspNetCore.OpenApi.SourceGenerators, Version=10.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60", "10.0.0.0")]
    file record XmlParameterComment(string? Name, string? Description, string? Example, bool Deprecated);

    [System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.AspNetCore.OpenApi.SourceGenerators, Version=10.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60", "10.0.0.0")]
    file record XmlResponseComment(string Code, string? Description, string? Example);

    [System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.AspNetCore.OpenApi.SourceGenerators, Version=10.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60", "10.0.0.0")]
    file static class XmlCommentCache
    {
        private static Dictionary<string, XmlComment>? _cache;
        public static Dictionary<string, XmlComment> Cache => _cache ??= GenerateCacheEntries();

        private static Dictionary<string, XmlComment> GenerateCacheEntries()
        {
            var cache = new Dictionary<string, XmlComment>();
            cache.Add(@"T:ErrorOr.ErrorOr`1", new XmlComment(@"A discriminated union of errors or a value.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:ErrorOr.ErrorOr`1.#ctor", new XmlComment(@"Prevents a default ErrorOr struct from being created.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:ErrorOr.ErrorOr`1.IsError", new XmlComment(@"Gets a value indicating whether the state is error.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:ErrorOr.ErrorOr`1.Errors", new XmlComment(@"Gets the list of errors.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:ErrorOr.ErrorOr`1.ErrorsOrEmptyList", new XmlComment(@"Gets the list of errors. If the state is not error, the list will be empty.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:ErrorOr.ErrorOr`1.Value", new XmlComment(@"Gets the value.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:ErrorOr.ErrorOr`1.FirstError", new XmlComment(@"Gets the first error.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:ErrorOr.ErrorOr`1.From(System.Collections.Generic.List{ErrorOr.Error})", new XmlComment(@"Creates an ErrorOr&lt;TValue&gt; from a list of errors.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:ErrorOr.ErrorOr`1.Else(System.Func{System.Collections.Generic.IReadOnlyList{ErrorOr.Error},ErrorOr.Error})", new XmlComment(@"If the state is error, the provided function onError is executed and its result is returned.", null, null, @"The result from calling onError if state is error; otherwise the original TValue ErrorOr&lt;TValue&gt;.Value.", null, false, null, [new XmlParameterComment(@"onError", @"The function to execute if the state is error.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOr`1.Else(System.Func{System.Collections.Generic.IReadOnlyList{ErrorOr.Error},System.Collections.Generic.IReadOnlyList{ErrorOr.Error}})", new XmlComment(@"If the state is error, the provided function onError is executed and its result is returned.", null, null, @"The result from calling onError if state is error; otherwise the original TValue ErrorOr&lt;TValue&gt;.Value.", null, false, null, [new XmlParameterComment(@"onError", @"The function to execute if the state is error.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOr`1.Else(ErrorOr.Error@)", new XmlComment(@"If the state is error, the provided error is returned.", null, null, @"The given error.", null, false, null, [new XmlParameterComment(@"error", @"The error to return.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOr`1.Else(System.Func{System.Collections.Generic.IReadOnlyList{ErrorOr.Error},`0})", new XmlComment(@"If the state is error, the provided function onError is executed and its result is returned.", null, null, @"The result from calling onError if state is error; otherwise the original TValue ErrorOr&lt;TValue&gt;.Value.", null, false, null, [new XmlParameterComment(@"onError", @"The function to execute if the state is error.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOr`1.Else(`0)", new XmlComment(@"If the state is error, the provided function onError is executed and its result is returned.", null, null, @"The result from calling onError if state is error; otherwise the original TValue ErrorOr&lt;TValue&gt;.Value.", null, false, null, [new XmlParameterComment(@"onError", @"The value to return if the state is error.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOr`1.ElseAsync(System.Func{System.Collections.Generic.IReadOnlyList{ErrorOr.Error},System.Threading.Tasks.Task{`0}})", new XmlComment(@"If the state is error, the provided function onError is executed asynchronously and its result is returned.", null, null, @"The result from calling onError if state is error; otherwise the original TValue ErrorOr&lt;TValue&gt;.Value.", null, false, null, [new XmlParameterComment(@"onError", @"The function to execute if the state is error.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOr`1.ElseAsync(System.Func{System.Collections.Generic.IReadOnlyList{ErrorOr.Error},System.Threading.Tasks.Task{ErrorOr.Error}})", new XmlComment(@"If the state is error, the provided function onError is executed asynchronously and its result is returned.", null, null, @"The result from calling onError if state is error; otherwise the original TValue ErrorOr&lt;TValue&gt;.Value.", null, false, null, [new XmlParameterComment(@"onError", @"The function to execute if the state is error.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOr`1.ElseAsync(System.Func{System.Collections.Generic.IReadOnlyList{ErrorOr.Error},System.Threading.Tasks.Task{System.Collections.Generic.IReadOnlyList{ErrorOr.Error}}})", new XmlComment(@"If the state is error, the provided function onError is executed asynchronously and its result is returned.", null, null, @"The result from calling onError if state is error; otherwise the original TValue ErrorOr&lt;TValue&gt;.Value.", null, false, null, [new XmlParameterComment(@"onError", @"The function to execute if the state is error.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOr`1.ElseAsync(System.Threading.Tasks.Task{ErrorOr.Error})", new XmlComment(@"If the state is error, the provided error is awaited and returned.", null, null, @"The result from awaiting the given error.", null, false, null, [new XmlParameterComment(@"error", @"The error to return if the state is error.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOr`1.ElseAsync(System.Threading.Tasks.Task{`0})", new XmlComment(@"If the state is error, the provided function onError is executed asynchronously and its result is returned.", null, null, @"The result from calling onError if state is error; otherwise the original TValue ErrorOr&lt;TValue&gt;.Value.", null, false, null, [new XmlParameterComment(@"onError", @"The function to execute if the state is error.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOr`1.ElseDo(System.Action{System.Collections.Generic.IReadOnlyList{ErrorOr.Error}})", new XmlComment(@"If the state is error, the provided action onError is executed for side-effects.", null, null, @"The original ErrorOr instance.", null, false, null, [new XmlParameterComment(@"onError", @"The action to execute if the state is error.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOr`1.ElseDoAsync(System.Func{System.Collections.Generic.IReadOnlyList{ErrorOr.Error},System.Threading.Tasks.Task})", new XmlComment(@"If the state is error, the provided action onError is executed asynchronously for side-effects.", null, null, @"The original ErrorOr instance.", null, false, null, [new XmlParameterComment(@"onError", @"The action to execute if the state is error.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOr`1.FailIf(System.Func{`0,System.Boolean},ErrorOr.Error@)", new XmlComment(@"If the state is value, the provided function onValue is invoked.
If onValue returns true, the given error will be returned, and the state will be error.", null, null, @"The given error if onValue returns true; otherwise, the original ErrorOr instance.", null, false, null, [new XmlParameterComment(@"onValue", @"The function to execute if the state is value.", null, false), new XmlParameterComment(@"error", @"The Error to return if the given onValue function returned true.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOr`1.FailIf(System.Func{`0,System.Boolean},System.Func{`0,ErrorOr.Error})", new XmlComment(@"If the state is value, the provided function onValue is invoked.
If onValue returns true, the given errorBuilder function will be executed, and the state will be error.", null, null, @"The given errorBuilder functions return value if onValue returns true; otherwise, the original ErrorOr instance.", null, false, null, [new XmlParameterComment(@"onValue", @"The function to execute if the state is value.", null, false), new XmlParameterComment(@"errorBuilder", @"The error builder function to execute and return if the given onValue function returned true.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOr`1.FailIfAsync(System.Func{`0,System.Boolean},System.Func{`0,System.Threading.Tasks.Task{ErrorOr.Error}})", new XmlComment(@"If the state is value, the provided function onValue is invoked.
If onValue returns true, the given errorBuilder function will be executed asynchronously, and the state will be error.", null, null, @"The given errorBuilder functions return value if onValue returns true; otherwise, the original ErrorOr instance.", null, false, null, [new XmlParameterComment(@"onValue", @"The function to execute if the state is value.", null, false), new XmlParameterComment(@"errorBuilder", @"The error builder function to execute and return if the given onValue function returned true.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOr`1.FailIfAsync(System.Func{`0,System.Threading.Tasks.Task{System.Boolean}},System.Func{`0,ErrorOr.Error})", new XmlComment(@"If the state is value, the provided function onValue is invoked asynchronously.
If onValue returns true, the given errorBuilder function will be executed, and the state will be error.", null, null, @"The given errorBuilder functions return value if onValue returns true; otherwise, the original ErrorOr instance.", null, false, null, [new XmlParameterComment(@"onValue", @"The function to execute if the state is value.", null, false), new XmlParameterComment(@"errorBuilder", @"The error builder function to execute and return if the given onValue function returned true.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOr`1.FailIfAsync(System.Func{`0,System.Threading.Tasks.Task{System.Boolean}},ErrorOr.Error)", new XmlComment(@"If the state is value, the provided function onValue is invoked asynchronously.
If onValue returns true, the given error will be returned, and the state will be error.", null, null, @"The given error if onValue returns true; otherwise, the original ErrorOr instance.", null, false, null, [new XmlParameterComment(@"onValue", @"The function to execute if the statement is value.", null, false), new XmlParameterComment(@"error", @"The Error to return if the given onValue function returned true.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOr`1.FailIfAsync(System.Func{`0,System.Threading.Tasks.Task{System.Boolean}},System.Func{`0,System.Threading.Tasks.Task{ErrorOr.Error}})", new XmlComment(@"If the state is value, the provided function onValue is invoked.
If onValue returns true, the given errorBuilder function will be executed, and the state will be error.", null, null, @"The given errorBuilder functions return value if onValue returns true; otherwise, the original ErrorOr instance.", null, false, null, [new XmlParameterComment(@"onValue", @"The function to execute if the state is value.", null, false), new XmlParameterComment(@"errorBuilder", @"The error builder function to execute and return if the given onValue function returned true.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOr`1.op_Implicit(`0)~ErrorOr.ErrorOr{`0}", new XmlComment(@"Creates an ErrorOr&lt;TValue&gt; from a value.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:ErrorOr.ErrorOr`1.op_Implicit(ErrorOr.Error)~ErrorOr.ErrorOr{`0}", new XmlComment(@"Creates an ErrorOr&lt;TValue&gt; from an error.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:ErrorOr.ErrorOr`1.op_Implicit(System.Collections.Generic.List{ErrorOr.Error})~ErrorOr.ErrorOr{`0}", new XmlComment(@"Creates an ErrorOr&lt;TValue&gt; from a list of errors.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:ErrorOr.ErrorOr`1.op_Implicit(ErrorOr.Error[])~ErrorOr.ErrorOr{`0}", new XmlComment(@"Creates an ErrorOr&lt;TValue&gt; from a list of errors.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:ErrorOr.ErrorOr`1.Match``1(System.Func{`0,``0},System.Func{System.Collections.Generic.IReadOnlyList{ErrorOr.Error},``0})", new XmlComment(@"Executes the appropriate function based on the state of the ErrorOr&lt;TValue&gt;.
If the state is a value, the provided function onValue is executed and its result is returned.
If the state is an error, the provided function onError is executed and its result is returned.", null, null, @"The result of the executed function.", null, false, null, [new XmlParameterComment(@"onValue", @"The function to execute if the state is a value.", null, false), new XmlParameterComment(@"onError", @"The function to execute if the state is an error.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOr`1.MatchAsync``1(System.Func{`0,System.Threading.Tasks.Task{``0}},System.Func{System.Collections.Generic.IReadOnlyList{ErrorOr.Error},System.Threading.Tasks.Task{``0}})", new XmlComment(@"Asynchronously executes the appropriate function based on the state of the ErrorOr&lt;TValue&gt;.
If the state is a value, the provided function onValue is executed asynchronously and its result is returned.
If the state is an error, the provided function onError is executed asynchronously and its result is returned.", null, null, @"A task representing the asynchronous operation that yields the result of the executed function.", null, false, null, [new XmlParameterComment(@"onValue", @"The asynchronous function to execute if the state is a value.", null, false), new XmlParameterComment(@"onError", @"The asynchronous function to execute if the state is an error.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOr`1.MatchFirst``1(System.Func{`0,``0},System.Func{ErrorOr.Error,``0})", new XmlComment(@"Executes the appropriate function based on the state of the ErrorOr&lt;TValue&gt;.
If the state is a value, the provided function onValue is executed and its result is returned.
If the state is an error, the provided function onFirstError is executed using the first error, and its result is returned.", null, null, @"The result of the executed function.", null, false, null, [new XmlParameterComment(@"onValue", @"The function to execute if the state is a value.", null, false), new XmlParameterComment(@"onFirstError", @"The function to execute with the first error if the state is an error.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOr`1.MatchFirstAsync``1(System.Func{`0,System.Threading.Tasks.Task{``0}},System.Func{ErrorOr.Error,System.Threading.Tasks.Task{``0}})", new XmlComment(@"Asynchronously executes the appropriate function based on the state of the ErrorOr&lt;TValue&gt;.
If the state is a value, the provided function onValue is executed asynchronously and its result is returned.
If the state is an error, the provided function onFirstError is executed asynchronously using the first error, and its result is returned.", null, null, @"A task representing the asynchronous operation that yields the result of the executed function.", null, false, null, [new XmlParameterComment(@"onValue", @"The asynchronous function to execute if the state is a value.", null, false), new XmlParameterComment(@"onFirstError", @"The asynchronous function to execute with the first error if the state is an error.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOr`1.Switch(System.Action{`0},System.Action{System.Collections.Generic.IReadOnlyList{ErrorOr.Error}})", new XmlComment(@"Executes the appropriate action based on the state of the ErrorOr&lt;TValue&gt;.
If the state is an error, the provided action onError is executed.
If the state is a value, the provided action onValue is executed.", null, null, null, null, false, null, [new XmlParameterComment(@"onValue", @"The action to execute if the state is a value.", null, false), new XmlParameterComment(@"onError", @"The action to execute if the state is an error.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOr`1.SwitchAsync(System.Func{`0,System.Threading.Tasks.Task},System.Func{System.Collections.Generic.IReadOnlyList{ErrorOr.Error},System.Threading.Tasks.Task})", new XmlComment(@"Asynchronously executes the appropriate action based on the state of the ErrorOr&lt;TValue&gt;.
If the state is an error, the provided action onError is executed asynchronously.
If the state is a value, the provided action onValue is executed asynchronously.", null, null, @"A task representing the asynchronous operation.", null, false, null, [new XmlParameterComment(@"onValue", @"The asynchronous action to execute if the state is a value.", null, false), new XmlParameterComment(@"onError", @"The asynchronous action to execute if the state is an error.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOr`1.SwitchFirst(System.Action{`0},System.Action{ErrorOr.Error})", new XmlComment(@"Executes the appropriate action based on the state of the ErrorOr&lt;TValue&gt;.
If the state is an error, the provided action onFirstError is executed using the first error as input.
If the state is a value, the provided action onValue is executed.", null, null, null, null, false, null, [new XmlParameterComment(@"onValue", @"The action to execute if the state is a value.", null, false), new XmlParameterComment(@"onFirstError", @"The action to execute with the first error if the state is an error.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOr`1.SwitchFirstAsync(System.Func{`0,System.Threading.Tasks.Task},System.Func{ErrorOr.Error,System.Threading.Tasks.Task})", new XmlComment(@"Asynchronously executes the appropriate action based on the state of the ErrorOr&lt;TValue&gt;.
If the state is an error, the provided action onFirstError is executed asynchronously using the first error as input.
If the state is a value, the provided action onValue is executed asynchronously.", null, null, @"A task representing the asynchronous operation.", null, false, null, [new XmlParameterComment(@"onValue", @"The asynchronous action to execute if the state is a value.", null, false), new XmlParameterComment(@"onFirstError", @"The asynchronous action to execute with the first error if the state is an error.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOr`1.Then``1(System.Func{`0,ErrorOr.ErrorOr{``0}})", new XmlComment(@"If the state is a value, the provided function onValue is executed and its result is returned.", null, null, @"The result from calling onValue if state is value; otherwise the original IReadOnlyList&lt;Error&gt; ErrorOr&lt;TValue&gt;.Errors.", null, false, null, [new XmlParameterComment(@"onValue", @"The function to execute if the state is a value.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOr`1.ThenDo(System.Action{`0})", new XmlComment(@"If the state is a value, the provided action is invoked.", null, null, @"The original ErrorOr instance.", null, false, null, [new XmlParameterComment(@"action", @"The action to execute if the state is a value.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOr`1.Then``1(System.Func{`0,``0})", new XmlComment(@"If the state is a value, the provided function onValue is executed and its result is returned.", null, null, @"The result from calling onValue if state is value; otherwise the original IReadOnlyList&lt;Error&gt; ErrorOr&lt;TValue&gt;.Errors.", null, false, null, [new XmlParameterComment(@"onValue", @"The function to execute if the state is a value.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOr`1.ThenAsync``1(System.Func{`0,System.Threading.Tasks.Task{ErrorOr.ErrorOr{``0}}})", new XmlComment(@"If the state is a value, the provided function onValue is executed asynchronously and its result is returned.", null, null, @"The result from calling onValue if state is value; otherwise the original IReadOnlyList&lt;Error&gt; ErrorOr&lt;TValue&gt;.Errors.", null, false, null, [new XmlParameterComment(@"onValue", @"The function to execute if the state is a value.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOr`1.ThenDoAsync(System.Func{`0,System.Threading.Tasks.Task})", new XmlComment(@"If the state is a value, the provided action is invoked asynchronously.", null, null, @"The original ErrorOr instance.", null, false, null, [new XmlParameterComment(@"action", @"The action to execute if the state is a value.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOr`1.ThenAsync``1(System.Func{`0,System.Threading.Tasks.Task{``0}})", new XmlComment(@"If the state is a value, the provided function onValue is executed asynchronously and its result is returned.", null, null, @"The result from calling onValue if state is value; otherwise the original IReadOnlyList&lt;Error&gt; ErrorOr&lt;TValue&gt;.Errors.", null, false, null, [new XmlParameterComment(@"onValue", @"The function to execute if the state is a value.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOrExtensions.Else``1(System.Threading.Tasks.Task{ErrorOr.ErrorOr{``0}},System.Func{System.Collections.Generic.IReadOnlyList{ErrorOr.Error},``0})", new XmlComment(@"If the state is error, the provided function onError is executed asynchronously and its result is returned.", null, null, @"The result from calling onError if state is error; otherwise the original value.", null, false, null, [new XmlParameterComment(@"errorOr", @"The ErrorOr instance.", null, false), new XmlParameterComment(@"onError", @"The function to execute if the state is error.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOrExtensions.Else``1(System.Threading.Tasks.Task{ErrorOr.ErrorOr{``0}},``0)", new XmlComment(@"If the state is error, the provided function onError is executed asynchronously and its result is returned.", null, null, @"The result from calling onError if state is error; otherwise the original value.", null, false, null, [new XmlParameterComment(@"errorOr", @"The ErrorOr instance.", null, false), new XmlParameterComment(@"onError", @"The function to execute if the state is error.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOrExtensions.ElseAsync``1(System.Threading.Tasks.Task{ErrorOr.ErrorOr{``0}},System.Func{System.Collections.Generic.IReadOnlyList{ErrorOr.Error},System.Threading.Tasks.Task{``0}})", new XmlComment(@"If the state is error, the provided function onError is executed asynchronously and its result is returned.", null, null, @"The result from calling onError if state is error; otherwise the original value.", null, false, null, [new XmlParameterComment(@"errorOr", @"The ErrorOr instance.", null, false), new XmlParameterComment(@"onError", @"The function to execute if the state is error.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOrExtensions.ElseAsync``1(System.Threading.Tasks.Task{ErrorOr.ErrorOr{``0}},System.Threading.Tasks.Task{``0})", new XmlComment(@"If the state is error, the provided function onError is executed asynchronously and its result is returned.", null, null, @"The result from calling onError if state is error; otherwise the original value.", null, false, null, [new XmlParameterComment(@"errorOr", @"The ErrorOr instance.", null, false), new XmlParameterComment(@"onError", @"The function to execute if the state is error.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOrExtensions.Else``1(System.Threading.Tasks.Task{ErrorOr.ErrorOr{``0}},System.Func{System.Collections.Generic.IReadOnlyList{ErrorOr.Error},ErrorOr.Error})", new XmlComment(@"If the state is error, the provided function onError is executed asynchronously and its result is returned.", null, null, @"The result from calling onError if state is error; otherwise the original value.", null, false, null, [new XmlParameterComment(@"errorOr", @"The ErrorOr instance.", null, false), new XmlParameterComment(@"onError", @"The function to execute if the state is error.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOrExtensions.Else``1(System.Threading.Tasks.Task{ErrorOr.ErrorOr{``0}},System.Func{System.Collections.Generic.IReadOnlyList{ErrorOr.Error},System.Collections.Generic.IReadOnlyList{ErrorOr.Error}})", new XmlComment(@"If the state is error, the provided function onError is executed asynchronously and its result is returned.", null, null, @"The result from calling onError if state is error; otherwise the original value.", null, false, null, [new XmlParameterComment(@"errorOr", @"The ErrorOr instance.", null, false), new XmlParameterComment(@"onError", @"The function to execute if the state is error.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOrExtensions.Else``1(System.Threading.Tasks.Task{ErrorOr.ErrorOr{``0}},ErrorOr.Error)", new XmlComment(@"If the state is error, the provided error is returned.", null, null, @"The given error.", null, false, null, [new XmlParameterComment(@"errorOr", @"The ErrorOr instance.", null, false), new XmlParameterComment(@"error", @"The error to return.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOrExtensions.ElseAsync``1(System.Threading.Tasks.Task{ErrorOr.ErrorOr{``0}},System.Func{System.Collections.Generic.IReadOnlyList{ErrorOr.Error},System.Threading.Tasks.Task{ErrorOr.Error}})", new XmlComment(@"If the state is error, the provided function onError is executed asynchronously and its result is returned.", null, null, @"The result from calling onError if state is error; otherwise the original value.", null, false, null, [new XmlParameterComment(@"errorOr", @"The ErrorOr instance.", null, false), new XmlParameterComment(@"onError", @"The function to execute if the state is error.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOrExtensions.ElseAsync``1(System.Threading.Tasks.Task{ErrorOr.ErrorOr{``0}},System.Func{System.Collections.Generic.IReadOnlyList{ErrorOr.Error},System.Threading.Tasks.Task{System.Collections.Generic.IReadOnlyList{ErrorOr.Error}}})", new XmlComment(@"If the state is error, the provided function onError is executed asynchronously and its result is returned.", null, null, @"The result from calling onError if state is error; otherwise the original value.", null, false, null, [new XmlParameterComment(@"errorOr", @"The ErrorOr instance.", null, false), new XmlParameterComment(@"onError", @"The function to execute if the state is error.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOrExtensions.ElseAsync``1(System.Threading.Tasks.Task{ErrorOr.ErrorOr{``0}},System.Threading.Tasks.Task{ErrorOr.Error})", new XmlComment(@"If the state is error, the provided function onError is executed asynchronously and its result is returned.", null, null, @"The result from calling onError if state is error; otherwise the original value.", null, false, null, [new XmlParameterComment(@"errorOr", @"The ErrorOr instance.", null, false), new XmlParameterComment(@"onError", @"The function to execute if the state is error.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOrExtensions.ElseDo``1(System.Threading.Tasks.Task{ErrorOr.ErrorOr{``0}},System.Action{System.Collections.Generic.IReadOnlyList{ErrorOr.Error}})", new XmlComment(@"If the state is error, the provided action onError is executed for side-effects.", null, null, @"The original ErrorOr instance.", null, false, null, [new XmlParameterComment(@"errorOr", @"The ErrorOr instance.", null, false), new XmlParameterComment(@"onError", @"The action to execute if the state is error.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOrExtensions.ElseDoAsync``1(System.Threading.Tasks.Task{ErrorOr.ErrorOr{``0}},System.Func{System.Collections.Generic.IReadOnlyList{ErrorOr.Error},System.Threading.Tasks.Task})", new XmlComment(@"If the state is error, the provided action onError is executed asynchronously for side-effects.", null, null, @"The original ErrorOr instance.", null, false, null, [new XmlParameterComment(@"errorOr", @"The ErrorOr instance.", null, false), new XmlParameterComment(@"onError", @"The action to execute if the state is error.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOrExtensions.FailIf``1(System.Threading.Tasks.Task{ErrorOr.ErrorOr{``0}},System.Func{``0,System.Boolean},ErrorOr.Error)", new XmlComment(@"If the state is value, the provided function onValue is invoked asynchronously.
If onValue returns true, the given error will be returned, and the state will be error.", null, null, @"The given error if onValue returns true; otherwise, the original ErrorOr instance.", null, false, null, [new XmlParameterComment(@"errorOr", @"The ErrorOr instance.", null, false), new XmlParameterComment(@"onValue", @"The function to execute if the state is a value.", null, false), new XmlParameterComment(@"error", @"The Error to return if the given onValue function returned true..", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOrExtensions.FailIf``1(System.Threading.Tasks.Task{ErrorOr.ErrorOr{``0}},System.Func{``0,System.Boolean},System.Func{``0,ErrorOr.Error})", new XmlComment(@"If the state is value, the provided function onValue is invoked asynchronously.
If onValue returns true, the given errorBuilder will be returned, and the state will be error.", null, null, @"The given errorBuilder functions return value if onValue returns true; otherwise, the original ErrorOr instance.", null, false, null, [new XmlParameterComment(@"errorOr", @"The ErrorOr instance.", null, false), new XmlParameterComment(@"onValue", @"The function to execute if the state is a value.", null, false), new XmlParameterComment(@"errorBuilder", @"The error builder function to execute and return if the given onValue function returned true.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOrExtensions.FailIfAsync``1(System.Threading.Tasks.Task{ErrorOr.ErrorOr{``0}},System.Func{``0,System.Boolean},System.Func{``0,System.Threading.Tasks.Task{ErrorOr.Error}})", new XmlComment(@"If the state is value, the provided function onValue is invoked.
If onValue returns true, the given errorBuilder function will be executed asynchronously, and the state will be error.", null, null, @"The given errorBuilder functions return value if onValue returns true; otherwise, the original ErrorOr instance.", null, false, null, [new XmlParameterComment(@"errorOr", @"The ErrorOr instance.", null, false), new XmlParameterComment(@"onValue", @"The function to execute if the state is value.", null, false), new XmlParameterComment(@"errorBuilder", @"The error builder function to execute and return if the given onValue function returned true.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOrExtensions.FailIfAsync``1(System.Threading.Tasks.Task{ErrorOr.ErrorOr{``0}},System.Func{``0,System.Threading.Tasks.Task{System.Boolean}},System.Func{``0,ErrorOr.Error})", new XmlComment(@"If the state is value, the provided function onValue is invoked asynchronously.
If onValue returns true, the given errorBuilder function will be executed, and the state will be error.", null, null, @"The given errorBuilder functions return value if onValue returns true; otherwise, the original ErrorOr instance.", null, false, null, [new XmlParameterComment(@"errorOr", @"The ErrorOr instance.", null, false), new XmlParameterComment(@"onValue", @"The function to execute if the state is value.", null, false), new XmlParameterComment(@"errorBuilder", @"The error builder function to execute and return if the given onValue function returned true.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOrExtensions.FailIfAsync``1(System.Threading.Tasks.Task{ErrorOr.ErrorOr{``0}},System.Func{``0,System.Threading.Tasks.Task{System.Boolean}},ErrorOr.Error)", new XmlComment(@"If the state is value, the provided function onValue is invoked asynchronously.
If onValue returns true, the given error will be returned, and the state will be error.", null, null, @"The given error if onValue returns true; otherwise, the original ErrorOr instance.", null, false, null, [new XmlParameterComment(@"errorOr", @"The ErrorOr instance.", null, false), new XmlParameterComment(@"onValue", @"The function to execute if the statement is value.", null, false), new XmlParameterComment(@"error", @"The Error to return if the given onValue function returned true.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOrExtensions.FailIfAsync``1(System.Threading.Tasks.Task{ErrorOr.ErrorOr{``0}},System.Func{``0,System.Threading.Tasks.Task{System.Boolean}},System.Func{``0,System.Threading.Tasks.Task{ErrorOr.Error}})", new XmlComment(@"If the state is value, the provided function onValue is invoked asynchronously.
If onValue returns true, the given errorBuilder will be returned, and the state will be error.", null, null, @"The given errorBuilder functions return value if onValue returns true; otherwise, the original ErrorOr instance.", null, false, null, [new XmlParameterComment(@"errorOr", @"The ErrorOr instance.", null, false), new XmlParameterComment(@"onValue", @"The function to execute if the statement is value.", null, false), new XmlParameterComment(@"errorBuilder", @"The error builder function to execute and return if the given onValue function returned true.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOrExtensions.Match``2(System.Threading.Tasks.Task{ErrorOr.ErrorOr{``0}},System.Func{``0,``1},System.Func{System.Collections.Generic.IReadOnlyList{ErrorOr.Error},``1})", new XmlComment(@"Executes the appropriate function based on the state of the ErrorOr&lt;TValue&gt;.
If the state is a value, the provided function onValue is executed and its result is returned.
If the state is an error, the provided function onError is executed and its result is returned.", null, null, @"The result of the executed function.", null, false, null, [new XmlParameterComment(@"errorOr", @"The ErrorOr instance.", null, false), new XmlParameterComment(@"onValue", @"The function to execute if the state is a value.", null, false), new XmlParameterComment(@"onError", @"The function to execute if the state is an error.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOrExtensions.MatchAsync``2(System.Threading.Tasks.Task{ErrorOr.ErrorOr{``0}},System.Func{``0,System.Threading.Tasks.Task{``1}},System.Func{System.Collections.Generic.IReadOnlyList{ErrorOr.Error},System.Threading.Tasks.Task{``1}})", new XmlComment(@"Asynchronously executes the appropriate function based on the state of the ErrorOr&lt;TValue&gt;.
If the state is a value, the provided function onValue is executed asynchronously and its result is returned.
If the state is an error, the provided function onError is executed asynchronously and its result is returned.", null, null, @"The result of the executed function.", null, false, null, [new XmlParameterComment(@"errorOr", @"The ErrorOr instance.", null, false), new XmlParameterComment(@"onValue", @"The function to execute if the state is a value.", null, false), new XmlParameterComment(@"onError", @"The function to execute if the state is an error.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOrExtensions.MatchFirst``2(System.Threading.Tasks.Task{ErrorOr.ErrorOr{``0}},System.Func{``0,``1},System.Func{ErrorOr.Error,``1})", new XmlComment(@"Executes the appropriate function based on the state of the ErrorOr&lt;TValue&gt;.
If the state is a value, the provided function onValue is executed and its result is returned.
If the state is an error, the provided function onFirstError is executed and its result is returned.", null, null, @"The result of the executed function.", null, false, null, [new XmlParameterComment(@"errorOr", @"The ErrorOr instance.", null, false), new XmlParameterComment(@"onValue", @"The function to execute if the state is a value.", null, false), new XmlParameterComment(@"onFirstError", @"The function to execute if the state is an error.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOrExtensions.MatchFirstAsync``2(System.Threading.Tasks.Task{ErrorOr.ErrorOr{``0}},System.Func{``0,System.Threading.Tasks.Task{``1}},System.Func{ErrorOr.Error,System.Threading.Tasks.Task{``1}})", new XmlComment(@"Asynchronously executes the appropriate function based on the state of the ErrorOr&lt;TValue&gt;.
If the state is a value, the provided function onValue is executed asynchronously and its result is returned.
If the state is an error, the provided function onFirstError is executed asynchronously and its result is returned.", null, null, @"The result of the executed function.", null, false, null, [new XmlParameterComment(@"errorOr", @"The ErrorOr instance.", null, false), new XmlParameterComment(@"onValue", @"The function to execute if the state is a value.", null, false), new XmlParameterComment(@"onFirstError", @"The function to execute if the state is an error.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOrExtensions.Switch``1(System.Threading.Tasks.Task{ErrorOr.ErrorOr{``0}},System.Action{``0},System.Action{System.Collections.Generic.IReadOnlyList{ErrorOr.Error}})", new XmlComment(@"Executes the appropriate action based on the state of the ErrorOr&lt;TValue&gt;.
If the state is an error, the provided action onError is executed.
If the state is a value, the provided action onValue is executed.", null, null, @"The result of the executed function.", null, false, null, [new XmlParameterComment(@"errorOr", @"The ErrorOr instance.", null, false), new XmlParameterComment(@"onValue", @"The action to execute if the state is a value.", null, false), new XmlParameterComment(@"onError", @"The action to execute if the state is an error.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOrExtensions.SwitchAsync``1(System.Threading.Tasks.Task{ErrorOr.ErrorOr{``0}},System.Func{``0,System.Threading.Tasks.Task},System.Func{System.Collections.Generic.IReadOnlyList{ErrorOr.Error},System.Threading.Tasks.Task})", new XmlComment(@"Executes the appropriate action based on the state of the ErrorOr&lt;TValue&gt;.
If the state is an error, the provided action onError is executed.
If the state is a value, the provided action onValue is executed.", null, null, @"The result of the executed function.", null, false, null, [new XmlParameterComment(@"errorOr", @"The ErrorOr instance.", null, false), new XmlParameterComment(@"onValue", @"The action to execute if the state is a value.", null, false), new XmlParameterComment(@"onError", @"The action to execute if the state is an error.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOrExtensions.SwitchFirst``1(System.Threading.Tasks.Task{ErrorOr.ErrorOr{``0}},System.Action{``0},System.Action{ErrorOr.Error})", new XmlComment(@"Executes the appropriate action based on the state of the ErrorOr&lt;TValue&gt;.
If the state is an error, the provided action onError is executed.
If the state is a value, the provided action onValue is executed.", null, null, @"The result of the executed function.", null, false, null, [new XmlParameterComment(@"errorOr", @"The ErrorOr instance.", null, false), new XmlParameterComment(@"onValue", @"The action to execute if the state is a value.", null, false), new XmlParameterComment(@"onError", @"The action to execute if the state is an error.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOrExtensions.SwitchFirstAsync``1(System.Threading.Tasks.Task{ErrorOr.ErrorOr{``0}},System.Func{``0,System.Threading.Tasks.Task},System.Func{ErrorOr.Error,System.Threading.Tasks.Task})", new XmlComment(@"Executes the appropriate action based on the state of the ErrorOr&lt;TValue&gt;.
If the state is an error, the provided action onError is executed.
If the state is a value, the provided action onValue is executed.", null, null, @"The result of the executed function.", null, false, null, [new XmlParameterComment(@"errorOr", @"The ErrorOr instance.", null, false), new XmlParameterComment(@"onValue", @"The action to execute if the state is a value.", null, false), new XmlParameterComment(@"onError", @"The action to execute if the state is an error.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOrExtensions.Then``2(System.Threading.Tasks.Task{ErrorOr.ErrorOr{``0}},System.Func{``0,ErrorOr.ErrorOr{``1}})", new XmlComment(@"If the state of errorOr is a value, the provided function onValue is executed and its result is returned.", null, null, @"The result from calling onValue if state is value; otherwise the original errors.", null, false, null, [new XmlParameterComment(@"errorOr", @"The ErrorOr instance.", null, false), new XmlParameterComment(@"onValue", @"The function to execute if the state is a value.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOrExtensions.Then``2(System.Threading.Tasks.Task{ErrorOr.ErrorOr{``0}},System.Func{``0,``1})", new XmlComment(@"If the state of errorOr is a value, the provided function onValue is executed and its result is returned.", null, null, @"The result from calling onValue if state is value; otherwise the original errors.", null, false, null, [new XmlParameterComment(@"errorOr", @"The ErrorOr instance.", null, false), new XmlParameterComment(@"onValue", @"The function to execute if the state is a value.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOrExtensions.ThenDo``1(System.Threading.Tasks.Task{ErrorOr.ErrorOr{``0}},System.Action{``0})", new XmlComment(@"If the state of errorOr is a value, the provided action is invoked.", null, null, @"The original errorOr.", null, false, null, [new XmlParameterComment(@"errorOr", @"The ErrorOr instance.", null, false), new XmlParameterComment(@"action", @"The action to execute if the state is a value.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOrExtensions.ThenAsync``2(System.Threading.Tasks.Task{ErrorOr.ErrorOr{``0}},System.Func{``0,System.Threading.Tasks.Task{ErrorOr.ErrorOr{``1}}})", new XmlComment(@"If the state of errorOr is a value, the provided function onValue is executed asynchronously and its result is returned.", null, null, @"The result from calling onValue if state is value; otherwise the original errors.", null, false, null, [new XmlParameterComment(@"errorOr", @"The ErrorOr instance.", null, false), new XmlParameterComment(@"onValue", @"The function to execute if the state is a value.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOrExtensions.ThenAsync``2(System.Threading.Tasks.Task{ErrorOr.ErrorOr{``0}},System.Func{``0,System.Threading.Tasks.Task{``1}})", new XmlComment(@"If the state of errorOr is a value, the provided function onValue is executed asynchronously and its result is returned.", null, null, @"The result from calling onValue if state is value; otherwise the original errors.", null, false, null, [new XmlParameterComment(@"errorOr", @"The ErrorOr instance.", null, false), new XmlParameterComment(@"onValue", @"The function to execute if the state is a value.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOrExtensions.ThenDoAsync``1(System.Threading.Tasks.Task{ErrorOr.ErrorOr{``0}},System.Func{``0,System.Threading.Tasks.Task})", new XmlComment(@"If the state of errorOr is a value, the provided action is executed asynchronously.", null, null, @"The original errorOr.", null, false, null, [new XmlParameterComment(@"errorOr", @"The ErrorOr instance.", null, false), new XmlParameterComment(@"action", @"The action to execute if the state is a value.", null, false)], null));
            cache.Add(@"M:ErrorOr.ErrorOrExtensions.ToErrorOr``1(``0)", new XmlComment(@"Creates an ErrorOr&lt;TValue&gt; instance with the given value.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:ErrorOr.ErrorOrExtensions.ToErrorOr``1(ErrorOr.Error@)", new XmlComment(@"Creates an ErrorOr&lt;TValue&gt; instance with the given error.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:ErrorOr.ErrorOrExtensions.ToErrorOr``1(System.Collections.Generic.List{ErrorOr.Error})", new XmlComment(@"Creates an ErrorOr&lt;TValue&gt; instance with the given errors.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:ErrorOr.ErrorOrExtensions.ToErrorOr``1(ErrorOr.Error[])", new XmlComment(@"Creates an ErrorOr&lt;TValue&gt; instance with the given errors.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:ErrorOr.ErrorOrFactory.From``1(``0)", new XmlComment(@"Creates a new instance of ErrorOr&lt;TValue&gt; with a value.", null, null, @"An instance of ErrorOr&lt;TValue&gt; containing the provided value.", null, false, null, [new XmlParameterComment(@"value", @"The value to wrap.", null, false)], null));
            cache.Add(@"P:ErrorOr.IErrorOr`1.Value", new XmlComment(@"Gets the value.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:ErrorOr.IErrorOr", new XmlComment(@"Type-less interface for the ErrorOr object.", null, @"This interface is intended for use when the underlying type of the ErrorOr object is unknown.", null, null, false, null, null, null));
            cache.Add(@"P:ErrorOr.IErrorOr.Errors", new XmlComment(@"Gets the list of errors.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:ErrorOr.IErrorOr.IsError", new XmlComment(@"Gets a value indicating whether the state is error.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:ErrorOr.IErrorOr.FirstError", new XmlComment(@"Gets the first error.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:ErrorOr.Error", new XmlComment(@"Represents an error.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:ErrorOr.Error.Code", new XmlComment(@"Gets the unique error code.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:ErrorOr.Error.Description", new XmlComment(@"Gets the error description.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:ErrorOr.Error.Type", new XmlComment(@"Gets the error type.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:ErrorOr.Error.NumericType", new XmlComment(@"Gets the numeric value of the type.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:ErrorOr.Error.Metadata", new XmlComment(@"Gets the metadata.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:ErrorOr.Error.Failure(System.String,System.String,System.Collections.Generic.Dictionary{System.String,System.Object})", new XmlComment(@"Creates an Error of type ErrorType.Failure from a code and description.", null, null, null, null, false, null, [new XmlParameterComment(@"code", @"The unique error code.", null, false), new XmlParameterComment(@"description", @"The error description.", null, false), new XmlParameterComment(@"metadata", @"A dictionary which provides optional space for information.", null, false)], null));
            cache.Add(@"M:ErrorOr.Error.Unexpected(System.String,System.String,System.Collections.Generic.Dictionary{System.String,System.Object})", new XmlComment(@"Creates an Error of type ErrorType.Unexpected from a code and description.", null, null, null, null, false, null, [new XmlParameterComment(@"code", @"The unique error code.", null, false), new XmlParameterComment(@"description", @"The error description.", null, false), new XmlParameterComment(@"metadata", @"A dictionary which provides optional space for information.", null, false)], null));
            cache.Add(@"M:ErrorOr.Error.Validation(System.String,System.String,System.Collections.Generic.Dictionary{System.String,System.Object})", new XmlComment(@"Creates an Error of type ErrorType.Validation from a code and description.", null, null, null, null, false, null, [new XmlParameterComment(@"code", @"The unique error code.", null, false), new XmlParameterComment(@"description", @"The error description.", null, false), new XmlParameterComment(@"metadata", @"A dictionary which provides optional space for information.", null, false)], null));
            cache.Add(@"M:ErrorOr.Error.Conflict(System.String,System.String,System.Collections.Generic.Dictionary{System.String,System.Object})", new XmlComment(@"Creates an Error of type ErrorType.Conflict from a code and description.", null, null, null, null, false, null, [new XmlParameterComment(@"code", @"The unique error code.", null, false), new XmlParameterComment(@"description", @"The error description.", null, false), new XmlParameterComment(@"metadata", @"A dictionary which provides optional space for information.", null, false)], null));
            cache.Add(@"M:ErrorOr.Error.NotFound(System.String,System.String,System.Collections.Generic.Dictionary{System.String,System.Object})", new XmlComment(@"Creates an Error of type ErrorType.NotFound from a code and description.", null, null, null, null, false, null, [new XmlParameterComment(@"code", @"The unique error code.", null, false), new XmlParameterComment(@"description", @"The error description.", null, false), new XmlParameterComment(@"metadata", @"A dictionary which provides optional space for information.", null, false)], null));
            cache.Add(@"M:ErrorOr.Error.Unauthorized(System.String,System.String,System.Collections.Generic.Dictionary{System.String,System.Object})", new XmlComment(@"Creates an Error of type ErrorType.Unauthorized from a code and description.", null, null, null, null, false, null, [new XmlParameterComment(@"code", @"The unique error code.", null, false), new XmlParameterComment(@"description", @"The error description.", null, false), new XmlParameterComment(@"metadata", @"A dictionary which provides optional space for information.", null, false)], null));
            cache.Add(@"M:ErrorOr.Error.Forbidden(System.String,System.String,System.Collections.Generic.Dictionary{System.String,System.Object})", new XmlComment(@"Creates an Error of type ErrorType.Forbidden from a code and description.", null, null, null, null, false, null, [new XmlParameterComment(@"code", @"The unique error code.", null, false), new XmlParameterComment(@"description", @"The error description.", null, false), new XmlParameterComment(@"metadata", @"A dictionary which provides optional space for information.", null, false)], null));
            cache.Add(@"M:ErrorOr.Error.Custom(System.Int32,System.String,System.String,System.Collections.Generic.Dictionary{System.String,System.Object})", new XmlComment(@"Creates an Error with the given numeric type,
code, and description.", null, null, null, null, false, null, [new XmlParameterComment(@"type", @"An integer value which represents the type of error that occurred.", null, false), new XmlParameterComment(@"code", @"The unique error code.", null, false), new XmlParameterComment(@"description", @"The error description.", null, false), new XmlParameterComment(@"metadata", @"A dictionary which provides optional space for information.", null, false)], null));
            cache.Add(@"T:ErrorOr.ErrorType", new XmlComment(@"Error types.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:ErrorOr.TypedResults.Extensions", new XmlComment(@"Provides a container for external libraries to extend
the default `TypedResults` set with their own samples.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:ErrorOr.IResultExtensions", new XmlComment(@"Provides an interface to registering external methods that provide
custom IResult instances.", null, null, null, null, false, null, null, null));


            return cache;
        }
    }

    [System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.AspNetCore.OpenApi.SourceGenerators, Version=10.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60", "10.0.0.0")]
    file static class DocumentationCommentIdHelper
    {
        /// <summary>
        /// Generates a documentation comment ID for a type.
        /// Example: T:Namespace.Outer+Inner`1 becomes T:Namespace.Outer.Inner`1
        /// </summary>
        public static string CreateDocumentationId(this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            return "T:" + GetTypeDocId(type, includeGenericArguments: false, omitGenericArity: false);
        }

        /// <summary>
        /// Generates a documentation comment ID for a property.
        /// Example: P:Namespace.ContainingType.PropertyName or for an indexer P:Namespace.ContainingType.Item(System.Int32)
        /// </summary>
        public static string CreateDocumentationId(this PropertyInfo property)
        {
            if (property == null)
            {
                throw new ArgumentNullException(nameof(property));
            }

            var sb = new StringBuilder();
            sb.Append("P:");

            if (property.DeclaringType != null)
            {
                sb.Append(GetTypeDocId(property.DeclaringType, includeGenericArguments: false, omitGenericArity: false));
            }

            sb.Append('.');
            sb.Append(property.Name);

            // For indexers, include the parameter list.
            var indexParams = property.GetIndexParameters();
            if (indexParams.Length > 0)
            {
                sb.Append('(');
                for (int i = 0; i < indexParams.Length; i++)
                {
                    if (i > 0)
                    {
                        sb.Append(',');
                    }

                    sb.Append(GetTypeDocId(indexParams[i].ParameterType, includeGenericArguments: true, omitGenericArity: false));
                }
                sb.Append(')');
            }

            return sb.ToString();
        }

        /// <summary>
        /// Generates a documentation comment ID for a property given its container type and property name.
        /// Example: P:Namespace.ContainingType.PropertyName
        /// </summary>
        public static string CreateDocumentationId(Type containerType, string propertyName)
        {
            if (containerType == null)
            {
                throw new ArgumentNullException(nameof(containerType));
            }
            if (string.IsNullOrEmpty(propertyName))
            {
                throw new ArgumentException("Property name cannot be null or empty.", nameof(propertyName));
            }

            var sb = new StringBuilder();
            sb.Append("P:");
            sb.Append(GetTypeDocId(containerType, includeGenericArguments: false, omitGenericArity: false));
            sb.Append('.');
            sb.Append(propertyName);

            return sb.ToString();
        }

        /// <summary>
        /// Generates a documentation comment ID for a method (or constructor).
        /// For example:
        ///   M:Namespace.ContainingType.MethodName(ParamType1,ParamType2)~ReturnType
        ///   M:Namespace.ContainingType.#ctor(ParamType)
        /// </summary>
        public static string CreateDocumentationId(this MethodInfo method)
        {
            if (method == null)
            {
                throw new ArgumentNullException(nameof(method));
            }

            var sb = new StringBuilder();
            sb.Append("M:");

            // Append the fully qualified name of the declaring type.
            if (method.DeclaringType != null)
            {
                sb.Append(GetTypeDocId(method.DeclaringType, includeGenericArguments: false, omitGenericArity: false));
            }

            sb.Append('.');

            // Append the method name, handling constructors specially.
            if (method.IsConstructor)
            {
                sb.Append(method.IsStatic ? "#cctor" : "#ctor");
            }
            else
            {
                sb.Append(method.Name);
                if (method.IsGenericMethod)
                {
                    sb.Append("``");
                    sb.AppendFormat(CultureInfo.InvariantCulture, "{0}", method.GetGenericArguments().Length);
                }
            }

            // Append the parameter list, if any.
            var parameters = method.GetParameters();
            if (parameters.Length > 0)
            {
                sb.Append('(');
                for (int i = 0; i < parameters.Length; i++)
                {
                    if (i > 0)
                    {
                        sb.Append(',');
                    }

                    // Omit the generic arity for the parameter type.
                    sb.Append(GetTypeDocId(parameters[i].ParameterType, includeGenericArguments: true, omitGenericArity: true));
                }
                sb.Append(')');
            }

            // Append the return type after a '~' (if the method returns a value).
            if (method.ReturnType != typeof(void))
            {
                sb.Append('~');
                // Omit the generic arity for the return type.
                sb.Append(GetTypeDocId(method.ReturnType, includeGenericArguments: true, omitGenericArity: true));
            }

            return sb.ToString();
        }

        /// <summary>
        /// Generates a documentation ID string for a type.
        /// This method handles nested types (replacing '+' with '.'),
        /// generic types, arrays, pointers, by-ref types, and generic parameters.
        /// The <paramref name="includeGenericArguments"/> flag controls whether
        /// constructed generic type arguments are emitted, while <paramref name="omitGenericArity"/>
        /// controls whether the generic arity marker (e.g. "`1") is appended.
        /// </summary>
        private static string GetTypeDocId(Type type, bool includeGenericArguments, bool omitGenericArity)
        {
            if (type.IsGenericParameter)
            {
                // Use `` for method-level generic parameters and ` for type-level.
                if (type.DeclaringMethod != null)
                {
                    return "``" + type.GenericParameterPosition;
                }
                else if (type.DeclaringType != null)
                {
                    return "`" + type.GenericParameterPosition;
                }
                else
                {
                    return type.Name;
                }
            }

            if (type.IsGenericType)
            {
                Type genericDef = type.GetGenericTypeDefinition();
                string fullName = genericDef.FullName ?? genericDef.Name;

                var sb = new StringBuilder(fullName.Length);

                // Replace '+' with '.' for nested types
                for (var i = 0; i < fullName.Length; i++)
                {
                    char c = fullName[i];
                    if (c == '+')
                    {
                        sb.Append('.');
                    }
                    else if (c == '`')
                    {
                        break;
                    }
                    else
                    {
                        sb.Append(c);
                    }
                }

                if (!omitGenericArity)
                {
                    int arity = genericDef.GetGenericArguments().Length;
                    sb.Append('`');
                    sb.AppendFormat(CultureInfo.InvariantCulture, "{0}", arity);
                }

                if (includeGenericArguments && !type.IsGenericTypeDefinition)
                {
                    var typeArgs = type.GetGenericArguments();
                    sb.Append('{');

                    for (int i = 0; i < typeArgs.Length; i++)
                    {
                        if (i > 0)
                        {
                            sb.Append(',');
                        }

                        sb.Append(GetTypeDocId(typeArgs[i], includeGenericArguments, omitGenericArity));
                    }

                    sb.Append('}');
                }

                return sb.ToString();
            }

            // For non-generic types, use FullName (if available) and replace nested type separators.
            return (type.FullName ?? type.Name).Replace('+', '.');
        }

        /// <summary>
        /// Normalizes a documentation comment ID to match the compiler-style format.
        /// Strips the return type suffix for ordinary methods but retains it for conversion operators.
        /// </summary>
        /// <param name="docId">The documentation comment ID to normalize.</param>
        /// <returns>The normalized documentation comment ID.</returns>
        public static string NormalizeDocId(string docId)
        {
            // Find the tilde character that indicates the return type suffix
            var tildeIndex = docId.IndexOf('~');
            if (tildeIndex == -1)
            {
                // No return type suffix, return as-is
                return docId;
            }

            // Check if this is a conversion operator (op_Implicit or op_Explicit)
            // For these operators, we need to keep the return type suffix
            if (docId.Contains("op_Implicit") || docId.Contains("op_Explicit"))
            {
                return docId;
            }

            // For ordinary methods, strip the return type suffix
            return docId.Substring(0, tildeIndex);
        }
    }

    [System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.AspNetCore.OpenApi.SourceGenerators, Version=10.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60", "10.0.0.0")]
    file class XmlCommentOperationTransformer : IOpenApiOperationTransformer
    {
        public Task TransformAsync(OpenApiOperation operation, OpenApiOperationTransformerContext context, CancellationToken cancellationToken)
        {
            var methodInfo = context.Description.ActionDescriptor is ControllerActionDescriptor controllerActionDescriptor
                ? controllerActionDescriptor.MethodInfo
                : context.Description.ActionDescriptor.EndpointMetadata.OfType<MethodInfo>().SingleOrDefault();

            if (methodInfo is null)
            {
                return Task.CompletedTask;
            }
            if (XmlCommentCache.Cache.TryGetValue(DocumentationCommentIdHelper.NormalizeDocId(methodInfo.CreateDocumentationId()), out var methodComment))
            {
                if (methodComment.Summary is { } summary)
                {
                    operation.Summary = summary;
                }
                if (methodComment.Description is { } description)
                {
                    operation.Description = description;
                }
                if (methodComment.Remarks is { } remarks)
                {
                    operation.Description = remarks;
                }
                if (methodComment.Parameters is { Count: > 0})
                {
                    foreach (var parameterComment in methodComment.Parameters)
                    {
                        var parameterInfo = methodInfo.GetParameters().SingleOrDefault(info => info.Name == parameterComment.Name);
                        var operationParameter = operation.Parameters?.SingleOrDefault(parameter => parameter.Name == parameterComment.Name);
                        if (operationParameter is not null)
                        {
                            var targetOperationParameter = UnwrapOpenApiParameter(operationParameter);
                            targetOperationParameter.Description = parameterComment.Description;
                            if (parameterComment.Example is { } jsonString)
                            {
                                targetOperationParameter.Example = jsonString.Parse();
                            }
                            targetOperationParameter.Deprecated = parameterComment.Deprecated;
                        }
                        else
                        {
                            var requestBody = operation.RequestBody;
                            if (requestBody is not null)
                            {
                                requestBody.Description = parameterComment.Description;
                                if (parameterComment.Example is { } jsonString)
                                {
                                    var content = requestBody?.Content?.Values;
                                    if (content is null)
                                    {
                                        continue;
                                    }
                                    foreach (var mediaType in content)
                                    {
                                        mediaType.Example = jsonString.Parse();
                                    }
                                }
                            }
                        }
                    }
                }
                // Applies `<returns>` on XML comments for operation with single response value.
                if (methodComment.Returns is { } returns && operation.Responses is { Count: 1 })
                {
                    var response = operation.Responses.First();
                    response.Value.Description = returns;
                }
                // Applies `<response>` on XML comments for operation with multiple response values.
                if (methodComment.Responses is { Count: > 0} && operation.Responses is { Count: > 0 })
                {
                    foreach (var response in operation.Responses)
                    {
                        var responseComment = methodComment.Responses.SingleOrDefault(xmlResponse => xmlResponse.Code == response.Key);
                        if (responseComment is not null)
                        {
                            response.Value.Description = responseComment.Description;
                        }
                    }
                }
            }
            foreach (var parameterDescription in context.Description.ParameterDescriptions)
            {
                var metadata = parameterDescription.ModelMetadata;
                if (metadata.MetadataKind == ModelMetadataKind.Property
                    && metadata.ContainerType is { } containerType
                    && metadata.PropertyName is { } propertyName)
                {
                    var propertyDocId = DocumentationCommentIdHelper.CreateDocumentationId(containerType, propertyName);
                    if (XmlCommentCache.Cache.TryGetValue(DocumentationCommentIdHelper.NormalizeDocId(propertyDocId), out var propertyComment))
                    {
                        var parameter = operation.Parameters?.SingleOrDefault(p => p.Name == metadata.Name);
                        var description = propertyComment.Summary;
                        if (!string.IsNullOrEmpty(description) && !string.IsNullOrEmpty(propertyComment.Value))
                        {
                            description = $"{description}\n{propertyComment.Value}";
                        }
                        else if (string.IsNullOrEmpty(description))
                        {
                            description = propertyComment.Value;
                        }
                        if (parameter is null)
                        {
                            if (operation.RequestBody is not null)
                            {
                                operation.RequestBody.Description = description;
                                if (propertyComment.Examples?.FirstOrDefault() is { } jsonString)
                                {
                                    var content = operation.RequestBody.Content?.Values;
                                    if (content is null)
                                    {
                                        continue;
                                    }
                                    var parsedExample = jsonString.Parse();
                                    foreach (var mediaType in content)
                                    {
                                        mediaType.Example = parsedExample;
                                    }
                                }
                            }
                            continue;
                        }
                        var targetOperationParameter = UnwrapOpenApiParameter(parameter);
                        if (targetOperationParameter is not null)
                        {
                            targetOperationParameter.Description = description;
                            if (propertyComment.Examples?.FirstOrDefault() is { } jsonString)
                            {
                                targetOperationParameter.Example = jsonString.Parse();
                            }
                        }
                    }
                }
            }

            return Task.CompletedTask;
        }

        private static OpenApiParameter UnwrapOpenApiParameter(IOpenApiParameter sourceParameter)
        {
            if (sourceParameter is OpenApiParameterReference parameterReference)
            {
                if (parameterReference.Target is OpenApiParameter target)
                {
                    return target;
                }
                else
                {
                    throw new InvalidOperationException($"The input schema must be an {nameof(OpenApiParameter)} or {nameof(OpenApiParameterReference)}.");
                }
            }
            else if (sourceParameter is OpenApiParameter directParameter)
            {
                return directParameter;
            }
            else
            {
                throw new InvalidOperationException($"The input schema must be an {nameof(OpenApiParameter)} or {nameof(OpenApiParameterReference)}.");
            }
        }
    }

    [System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.AspNetCore.OpenApi.SourceGenerators, Version=10.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60", "10.0.0.0")]
    file class XmlCommentSchemaTransformer : IOpenApiSchemaTransformer
    {
        public Task TransformAsync(OpenApiSchema schema, OpenApiSchemaTransformerContext context, CancellationToken cancellationToken)
        {
            // Apply comments from the type
            if (XmlCommentCache.Cache.TryGetValue(DocumentationCommentIdHelper.NormalizeDocId(context.JsonTypeInfo.Type.CreateDocumentationId()), out var typeComment))
            {
                schema.Description = typeComment.Summary;
                if (typeComment.Examples?.FirstOrDefault() is { } jsonString)
                {
                    schema.Example = jsonString.Parse();
                }
            }

            if (context.JsonPropertyInfo is { AttributeProvider: PropertyInfo propertyInfo })
            {
                // Apply comments from the property
                if (XmlCommentCache.Cache.TryGetValue(DocumentationCommentIdHelper.NormalizeDocId(propertyInfo.CreateDocumentationId()), out var propertyComment))
                {
                    var description = propertyComment.Summary;
                    if (!string.IsNullOrEmpty(description) && !string.IsNullOrEmpty(propertyComment.Value))
                    {
                        description = $"{description}\n{propertyComment.Value}";
                    }
                    else if (string.IsNullOrEmpty(description))
                    {
                        description = propertyComment.Value;
                    }
                    if (schema.Metadata is null
                        || !schema.Metadata.TryGetValue("x-schema-id", out var schemaId)
                        || string.IsNullOrEmpty(schemaId as string))
                    {
                        // Inlined schema
                        schema.Description = description;
                        if (propertyComment.Examples?.FirstOrDefault() is { } jsonString)
                        {
                            schema.Example = jsonString.Parse();
                        }
                    }
                    else
                    {
                        // Schema Reference
                        if (!string.IsNullOrEmpty(description))
                        {
                            schema.Metadata["x-ref-description"] = description;
                        }
                        if (propertyComment.Examples?.FirstOrDefault() is { } jsonString)
                        {
                            schema.Metadata["x-ref-example"] = jsonString.Parse()!;
                        }
                    }
                }
            }
            return Task.CompletedTask;
        }
    }

    [System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.AspNetCore.OpenApi.SourceGenerators, Version=10.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60", "10.0.0.0")]
    file static class JsonNodeExtensions
    {
        public static JsonNode? Parse(this string? json)
        {
            if (json is null)
            {
                return null;
            }

            try
            {
                return JsonNode.Parse(json);
            }
            catch (JsonException)
            {
                try
                {
                    // If parsing fails, try wrapping in quotes to make it a valid JSON string
                    return JsonNode.Parse($"\"{json.Replace("\"", "\\\"")}\"");
                }
                catch (JsonException)
                {
                    return null;
                }
            }
        }
    }

    [System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.AspNetCore.OpenApi.SourceGenerators, Version=10.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60", "10.0.0.0")]
    file static class GeneratedServiceCollectionExtensions
    {
        [global::System.Runtime.CompilerServices.InterceptsLocationAttribute(1, "9BqYXYiySR58xL56e3iH/4IBAABQcm9ncmFtLmNz")]
        public static IServiceCollection AddOpenApi(this IServiceCollection services)
        {
            return services.AddOpenApi("v1", options =>
            {
                options.AddSchemaTransformer(new XmlCommentSchemaTransformer());
                options.AddOperationTransformer(new XmlCommentOperationTransformer());
            });
        }

    }
}
