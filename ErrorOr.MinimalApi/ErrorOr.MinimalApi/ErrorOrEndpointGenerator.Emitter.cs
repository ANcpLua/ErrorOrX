using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace ErrorOr.MinimalApi;

/// <summary>
///     Code emission logic for endpoint mappings.
/// </summary>
public sealed partial class ErrorOrEndpointGenerator
{
    internal static void EmitEndpoints(SourceProductionContext spc, ImmutableArray<EndpointDescriptor> endpoints,
        int maxArity = 6)
    {
        var sorted = SortEndpoints(endpoints);
        var jsonTypes = CollectJsonTypes(sorted);

        EmitMappings(spc, sorted, jsonTypes.Count > 0, maxArity);

        if (jsonTypes.Count > 0)
            EmitJsonContextSuggestion(spc, jsonTypes);
    }

    private static void EmitMappings(SourceProductionContext spc, ImmutableArray<EndpointDescriptor> endpoints,
        bool hasJsonTypes, int maxArity)
    {
        var code = new StringBuilder();
        code.AppendLine("// <auto-generated>");
        code.AppendLine("// This file was generated by ErrorOr.Http.Bcl source generator.");
        code.AppendLine("// Any modifications will be overwritten on next build.");
        code.AppendLine("// </auto-generated>");
        code.AppendLine();
        code.AppendLine("#nullable enable");
        code.AppendLine("using System;");
        code.AppendLine("using System.Linq;");
        code.AppendLine("using System.Threading.Tasks;");
        code.AppendLine("using Microsoft.AspNetCore.Builder;");
        code.AppendLine("using Microsoft.AspNetCore.Http;");
        code.AppendLine("using Microsoft.AspNetCore.Routing;");
        code.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        code.AppendLine();
        code.AppendLine("namespace ErrorOr.Http.Generated");
        code.AppendLine("{");
        code.AppendLine("    /// <summary>");
        code.AppendLine("    /// Generated endpoint mappings for all [ErrorOrEndpoint] handlers in this assembly.");
        code.AppendLine("    /// </summary>");
        code.AppendLine("    public static class ErrorOrEndpointMappings");
        code.AppendLine("    {");
        code.AppendLine("        /// <summary>");
        code.AppendLine("        /// Maps all ErrorOr endpoints to the application's routing table.");
        code.AppendLine("        /// </summary>");
        code.AppendLine("        /// <param name=\"app\">The endpoint route builder to add mappings to.</param>");
        code.AppendLine("        public static void MapErrorOrEndpoints(this IEndpointRouteBuilder app)");
        code.AppendLine("        {");

        for (var i = 0; i < endpoints.Length; i++)
            EmitMapCall(code, endpoints[i], i, maxArity);

        code.AppendLine("        }");
        code.AppendLine();

        if (hasJsonTypes)
            EmitJsonConfigExtension(code);

        for (var i = 0; i < endpoints.Length; i++)
            EmitInvoker(code, endpoints[i], i, maxArity);

        EmitSupportMethods(code);
        code.AppendLine("    }");
        code.AppendLine("}");

        spc.AddSource("ErrorOrEndpointMappings.cs", SourceText.From(code.ToString(), Encoding.UTF8));
    }

    private static void EmitMapCall(StringBuilder code, in EndpointDescriptor ep, int index, int maxArity)
    {
        var isNoContent = IsNoContentType(ep.SuccessTypeFqn);

        // Compute the return type to determine if we use union (metadata inferred) or IResult (explicit metadata)
        var unionResult = ResultsUnionTypeBuilder.ComputeReturnType(
            ep.SuccessTypeFqn,
            ep.HttpMethod,
            isNoContent,
            ep.InferredErrorTypes,
            ep.DeclaredProducesErrors,
            maxArity,
            ep.IsAcceptedResponse);

        // Emit comment describing the endpoint
        code.AppendLine(
            $"            // {ep.HttpMethod} {ep.Pattern} -> {ep.HandlerContainingTypeFqn}.{ep.HandlerMethodName}");

        // Use (Delegate) cast to preserve metadata instead of (RequestDelegate) which strips it
        code.AppendLine(
            $"            app.MapMethods(@\"{ep.Pattern}\", new[] {{ \"{ep.HttpMethod}\" }}, (Delegate)Invoke_Ep{index})");

        var className = ExtractTypeName(ep.HandlerContainingTypeFqn);
        var tagName = className.EndsWith("Endpoints") ? className[..^"Endpoints".Length] : className;
        var operationId = $"{tagName}_{ep.HandlerMethodName}";

        // Endpoint name and tags
        code.AppendLine($"            .WithName(\"{operationId}\")");
        code.AppendLine($"            .WithTags(\"{tagName}\")");

        // Add accepts metadata for body parameters using BCL fluent methods
        var bodyParam = ep.HandlerParameters.AsImmutableArray()
            .FirstOrDefault(static p => p.Source == EndpointParameterSource.Body);
        if (bodyParam.Name is not null)
            code.AppendLine($"            .Accepts<{bodyParam.TypeFqn}>(\"application/json\")");
        else if (HasFormParams(ep))
            code.AppendLine("            .Accepts(typeof(object), \"multipart/form-data\")");

        // Response metadata strategy:
        // - Union mode: NO explicit Produces* metadata (BCL's IEndpointMetadataProvider.PopulateMetadata() infers from Results<...>)
        // - Fallback mode: Explicit Produces* for all response types
        // - SSE: Special content type handling
        if (ep.IsSse)
        {
            code.AppendLine(
                "            .WithMetadata(new global::Microsoft.AspNetCore.Mvc.ProducesResponseTypeAttribute(200) { ContentTypes = new[] { \"text/event-stream\" } })");
        }
        else if (!unionResult.CanUseUnion)
        {
            // IResult fallback: emit all explicit metadata using BCL fluent methods
            var successStatus = isNoContent ? 204 :
                ep.IsAcceptedResponse ? 202 :
                ep.HttpMethod == WellKnownTypes.HttpMethod.Post ? 201 : 200;

            if (isNoContent)
                code.AppendLine($"            .Produces({successStatus})");
            else
                code.AppendLine($"            .Produces<{ep.SuccessTypeFqn}>({successStatus})");

            // Emit explicit metadata for all error responses
            foreach (var statusCode in unionResult.ExplicitProduceCodes.AsImmutableArray().Distinct().OrderBy(static x => x))
            {
                if (statusCode == 400)
                    code.AppendLine("            .ProducesValidationProblem()"); // Correct content-type for 400
                else
                    code.AppendLine($"            .ProducesProblem({statusCode})");
            }
        }
        // Union mode: NO metadata emission - BCL infers from Results<...> type via IEndpointMetadataProvider

        code.AppendLine("            ;");
        code.AppendLine();
    }

    private static void EmitInvoker(StringBuilder code, in EndpointDescriptor ep, int index, int maxArity)
    {
        var isNoContent = IsNoContentType(ep.SuccessTypeFqn);

        // Compute the optimal return type (union vs IResult fallback)
        var unionResult = ResultsUnionTypeBuilder.ComputeReturnType(
            ep.SuccessTypeFqn,
            ep.HttpMethod,
            isNoContent,
            ep.InferredErrorTypes,
            ep.DeclaredProducesErrors,
            maxArity,
            ep.IsAcceptedResponse);

        // Emit method signature with computed return type
        code.AppendLine(
            $"        private static async Task<{unionResult.ReturnTypeFqn}> Invoke_Ep{index}(HttpContext ctx)");
        code.AppendLine("        {");

        // Only emit BindFail helper if we have parameters that need binding validation
        if (NeedsBindingValidation(ep))
            EmitBindFailHelper(code, unionResult.ReturnTypeFqn, unionResult.CanUseUnion);

        if (HasFormParams(ep))
            EmitFormContentTypeGuard(code);

        var args = new StringBuilder();
        for (var i = 0; i < ep.HandlerParameters.Length; i++)
        {
            var param = ep.HandlerParameters[i];
            // Pass "BindFail" as the failure helper name - threaded through all nested bindings
            EmitParameterBinding(code, in param, $"p{i}", "BindFail");
            if (i > 0) args.Append(", ");
            args.Append(BuildArgumentExpression(in param, $"p{i}"));
        }

        var awaitKeyword = ep.IsAsync ? "await " : "";
        code.AppendLine(
            $"            var result = {awaitKeyword}{ep.HandlerContainingTypeFqn}.{ep.HandlerMethodName}({args});");

        if (ep.IsSse)
        {
            // SSE endpoints use IResult fallback path
            code.AppendLine("            if (result.IsError) return ToProblem(result.Errors);");
            code.AppendLine("            return TypedResults.ServerSentEvents(result.Value);");
        }
        else if (unionResult.CanUseUnion)
        {
            // Union path: explicit switch with typed results
            EmitUnionTypeErrorHandling(code, ep, unionResult.ReturnTypeFqn, isNoContent, ep.IsAcceptedResponse);
        }
        else
        {
            // Fallback path: IResult + ToProblem helper
            var successResult = isNoContent
                ? "_ => TypedResults.NoContent()"
                : ep.IsAcceptedResponse
                    ? "value => TypedResults.Accepted(string.Empty, value)"
                    : ep.HttpMethod == WellKnownTypes.HttpMethod.Post
                        ? "value => TypedResults.Created(string.Empty, value)"
                        : "value => TypedResults.Ok(value)";

            code.AppendLine("            return result.Match<global::Microsoft.AspNetCore.Http.IResult>(");
            code.AppendLine($"                {successResult},");
            code.AppendLine("                errors => ToProblem(errors));");
        }

        code.AppendLine("        }");
        code.AppendLine();
    }

    /// <summary>
    ///     Emits a local BindFail helper function typed to the invoker's return type.
    ///     This helper is threaded through all parameter binding emissions for consistent failure handling.
    /// </summary>
    private static void EmitBindFailHelper(StringBuilder code, string returnTypeFqn, bool canUseUnion)
    {
        // Emit ProblemDetails builder
        code.AppendLine(
            "            static global::Microsoft.AspNetCore.Mvc.ProblemDetails CreateBindProblem(string param, string reason) => new()");
        code.AppendLine("            {");
        code.AppendLine("                Title = \"Bad Request\",");
        code.AppendLine("                Detail = $\"Parameter '{param}' {reason}.\",");
        code.AppendLine("                Status = 400,");
        code.AppendLine("                Type = \"https://httpstatuses.io/400\",");
        code.AppendLine("            };");
        code.AppendLine();

        // Emit BindFail helper typed to the return type
        // BOTH paths use TypedResults.BadRequest<ProblemDetails> - this is a typed result, not dynamic
        // Union mode: BadRequest<ProblemDetails> is in the union, cast to union type
        // IResult mode: BadRequest is IResult, no cast needed
        if (canUseUnion)
        {
            // Union path: BadRequest<ProblemDetails> is in union, cast to union type
            code.AppendLine($"            static {returnTypeFqn} BindFail(string param, string reason)");
            code.AppendLine("                => TypedResults.BadRequest(CreateBindProblem(param, reason));");
        }
        else
        {
            // IResult path: return BadRequest with ProblemDetails (IResult-compatible)
            code.AppendLine($"            static {returnTypeFqn} BindFail(string param, string reason)");
            code.AppendLine("                => TypedResults.BadRequest(CreateBindProblem(param, reason));");
        }

        code.AppendLine();
    }

    /// <summary>
    ///     Emits error handling for union type return path with explicit switch.
    ///     Uses ONLY typed results (no dynamic Problem() bucket) - all outcomes are statically known.
    /// </summary>
    private static void EmitUnionTypeErrorHandling(
        StringBuilder code,
        in EndpointDescriptor ep,
        string returnType,
        bool isNoContent,
        bool isAcceptedResponse = false)
    {
        code.AppendLine("            if (result.IsError)");
        code.AppendLine("            {");
        code.AppendLine("                var first = result.FirstError;");

        // Check if we have validation errors (need special dictionary handling)
        // STRICT: ValidationProblem returns HttpValidationProblemDetails (not ProblemDetails)
        var hasValidation = !ep.InferredErrorTypes.IsDefaultOrEmpty &&
                            ep.InferredErrorTypes.AsImmutableArray().Contains(2);

        if (hasValidation)
        {
            // STRICT MODE: Use TypedResults.ValidationProblem() which returns ValidationProblem type
            // This produces HttpValidationProblemDetails schema in OpenAPI (RFC 7807 validation format)
            code.AppendLine("                if (first.Type == global::ErrorOr.ErrorType.Validation)");
            code.AppendLine("                {");
            code.AppendLine(
                "                    var validationDict = new global::System.Collections.Generic.Dictionary<string, string[]>();");
            code.AppendLine("                    foreach (var e in result.Errors)");
            code.AppendLine("                    {");
            code.AppendLine("                        if (e.Type != global::ErrorOr.ErrorType.Validation) continue;");
            code.AppendLine("                        if (!validationDict.TryGetValue(e.Code, out var existing))");
            code.AppendLine("                            validationDict[e.Code] = new[] { e.Description };");
            code.AppendLine("                        else");
            code.AppendLine("                        {");
            code.AppendLine("                            var arr = new string[existing.Length + 1];");
            code.AppendLine("                            existing.CopyTo(arr, 0);");
            code.AppendLine("                            arr[existing.Length] = e.Description;");
            code.AppendLine("                            validationDict[e.Code] = arr;");
            code.AppendLine("                        }");
            code.AppendLine("                    }");
            code.AppendLine("                    return TypedResults.ValidationProblem(validationDict);");
            code.AppendLine("                }");
        }

        // Build ProblemDetails for non-validation errors
        code.AppendLine("                var problem = new global::Microsoft.AspNetCore.Mvc.ProblemDetails");
        code.AppendLine("                {");
        code.AppendLine("                    Title = first.Code,");
        code.AppendLine("                    Detail = first.Description,");
        code.AppendLine("                    Status = first.Type switch");
        code.AppendLine("                    {");
        code.AppendLine("                        global::ErrorOr.ErrorType.Failure => 422,");
        code.AppendLine("                        global::ErrorOr.ErrorType.Unexpected => 500,");
        code.AppendLine("                        global::ErrorOr.ErrorType.Conflict => 409,");
        code.AppendLine("                        global::ErrorOr.ErrorType.NotFound => 404,");
        code.AppendLine("                        global::ErrorOr.ErrorType.Unauthorized => 401,");
        code.AppendLine("                        global::ErrorOr.ErrorType.Forbidden => 403,");
        code.AppendLine(
            "                        _ => 500"); // Fallback for unknown types (should not happen in union mode)
        code.AppendLine("                    }");
        code.AppendLine("                };");
        code.AppendLine();

        // Emit switch on error type - ONLY typed results, no Problem() dynamic bucket
        code.AppendLine("                return first.Type switch");
        code.AppendLine("                {");

        // Emit cases for each inferred error type (except Validation, handled above)
        if (!ep.InferredErrorTypes.IsDefaultOrEmpty)
        {
            foreach (var errorType in ep.InferredErrorTypes.AsImmutableArray().Distinct().OrderBy(static x => x))
            {
                if (errorType == 2) continue; // Validation handled specially above

                var enumName = ResultsUnionTypeBuilder.GetErrorTypeName(errorType);

                // Use ONLY typed results - these are in the union
                var factory = errorType switch
                {
                    5 => "TypedResults.Unauthorized()",
                    6 => "TypedResults.Forbid()",
                    0 => "TypedResults.UnprocessableEntity(problem)",
                    1 => "TypedResults.InternalServerError(problem)",
                    3 => "TypedResults.Conflict(problem)",
                    4 => "TypedResults.NotFound(problem)",
                    _ => "TypedResults.InternalServerError(problem)" // Unknown -> 500
                };

                code.AppendLine($"                    global::ErrorOr.ErrorType.{enumName} => {factory},");
            }
        }

        // Default case: map to BadRequest (binding failure type, always in union)
        // This handles any unexpected error types that slip through
        code.AppendLine("                    _ => TypedResults.BadRequest(problem)");
        code.AppendLine("                };");
        code.AppendLine("            }");
        code.AppendLine();

        // Success path
        var successFactory = ResultsUnionTypeBuilder.GetSuccessFactory(ep.HttpMethod, isNoContent, isAcceptedResponse);
        code.AppendLine($"            return {successFactory};");
    }

    private static void EmitParameterBinding(StringBuilder code, in EndpointParameter param, string paramName,
        string bindFailFn)
    {
        switch (param.Source)
        {
            case EndpointParameterSource.Route:
                EmitRouteBinding(code, in param, paramName, bindFailFn);
                break;
            case EndpointParameterSource.Query:
                EmitQueryBinding(code, in param, paramName, bindFailFn);
                break;
            case EndpointParameterSource.Header:
                EmitHeaderBinding(code, in param, paramName, bindFailFn);
                break;
            case EndpointParameterSource.Body:
                EmitBodyBinding(code, in param, paramName, bindFailFn);
                break;
            case EndpointParameterSource.Service:
                code.AppendLine(
                    $"            var {paramName} = ctx.RequestServices.GetRequiredService<{param.TypeFqn}>();");
                break;
            case EndpointParameterSource.KeyedService:
                code.AppendLine(
                    $"            var {paramName} = ctx.RequestServices.GetRequiredKeyedService<{param.TypeFqn}>({param.KeyName});");
                break;
            case EndpointParameterSource.HttpContext:
                code.AppendLine($"            var {paramName} = ctx;");
                break;
            case EndpointParameterSource.CancellationToken:
                code.AppendLine($"            var {paramName} = ctx.RequestAborted;");
                break;
            case EndpointParameterSource.Stream:
                code.AppendLine($"            var {paramName} = ctx.Request.Body;");
                break;
            case EndpointParameterSource.PipeReader:
                code.AppendLine($"            var {paramName} = ctx.Request.BodyReader;");
                break;
            case EndpointParameterSource.FormFile:
                code.AppendLine(
                    $"            var {paramName} = form.Files.GetFile(\"{param.KeyName ?? param.Name}\");");
                if (!param.IsNullable)
                {
                    code.AppendLine(
                        $"            if ({paramName} is null) return {bindFailFn}(\"{param.Name}\", \"is required\");");
                }

                break;
            case EndpointParameterSource.FormFiles:
                code.AppendLine($"            var {paramName} = form.Files;");
                break;
            case EndpointParameterSource.FormCollection:
                code.AppendLine($"            var {paramName} = form;");
                break;
            case EndpointParameterSource.Form:
                EmitFormBinding(code, in param, paramName, bindFailFn);
                break;
            case EndpointParameterSource.AsParameters:
                EmitAsParametersBinding(code, in param, paramName, bindFailFn);
                break;
        }
    }

    private static void EmitRouteBinding(StringBuilder code, in EndpointParameter param, string paramName,
        string bindFailFn)
    {
        var routeName = param.KeyName ?? param.Name;
        if (IsStringType(param.TypeFqn))
        {
            code.AppendLine(
                $"            if (!TryGetRouteValue(ctx, \"{routeName}\", out var {paramName})) return {bindFailFn}(\"{param.Name}\", \"is missing from route\");");
        }
        else
        {
            code.AppendLine(
                $"            if (!TryGetRouteValue(ctx, \"{routeName}\", out var {paramName}Raw) || !{GetTryParseExpression(param.TypeFqn, paramName + "Raw", paramName, param.CustomBinding)}) return {bindFailFn}(\"{param.Name}\", \"has invalid format\");");
        }
    }

    private static void EmitQueryBinding(StringBuilder code, in EndpointParameter param, string paramName,
        string bindFailFn)
    {
        // Handle BindAsync custom binding
        if (param.CustomBinding is CustomBindingMethod.BindAsync or CustomBindingMethod.BindAsyncWithParam)
        {
            var baseType = param.TypeFqn.TrimEnd('?');
            code.AppendLine($"            var {paramName} = await {baseType}.BindAsync(ctx);");
            if (!param.IsNullable)
            {
                code.AppendLine(
                    $"            if ({paramName} is null) return {bindFailFn}(\"{param.Name}\", \"binding failed\");");
            }

            return;
        }

        var queryKey = param.KeyName ?? param.Name;
        if (param.IsCollection && param.CollectionItemTypeFqn is { } itemType)
        {
            code.AppendLine($"            var {paramName}Raw = ctx.Request.Query[\"{queryKey}\"];");
            code.AppendLine(
                $"            var {paramName}List = new global::System.Collections.Generic.List<{itemType}>();");
            code.AppendLine($"            foreach (var item in {paramName}Raw)");
            code.AppendLine("            {");
            if (IsStringType(itemType))
                // Pattern match ensures non-null for compiler
            {
                code.AppendLine(
                    $"                if (item is {{ Length: > 0 }} validItem) {paramName}List.Add(validItem);");
            }
            else
            {
                code.AppendLine(
                    $"                if ({GetTryParseExpression(itemType, "item", "parsedItem")}) {paramName}List.Add(parsedItem);");
                code.AppendLine(
                    $"                else if (!string.IsNullOrEmpty(item)) return {bindFailFn}(\"{param.Name}\", \"has invalid item format\");");
            }

            code.AppendLine("            }");
            code.AppendLine($"            var {paramName} = {paramName}List;");
        }
        else
        {
            code.AppendLine($"            {param.TypeFqn}? {paramName};");
            code.AppendLine($"            if (!TryGetQueryValue(ctx, \"{queryKey}\", out var {paramName}Raw))");
            code.AppendLine("            {");
            code.AppendLine(param.IsNullable
                ? $"                {paramName} = default;"
                : $"                return {bindFailFn}(\"{param.Name}\", \"is required\");");
            code.AppendLine("            }");
            code.AppendLine("            else");
            code.AppendLine("            {");
            if (IsStringType(param.TypeFqn))
                code.AppendLine($"                {paramName} = {paramName}Raw;");
            else
            {
                code.AppendLine(
                    $"                if (!{GetTryParseExpression(param.TypeFqn, paramName + "Raw", paramName + "Temp", param.CustomBinding)}) return {bindFailFn}(\"{param.Name}\", \"has invalid format\");");
                code.AppendLine($"                {paramName} = {paramName}Temp;");
            }

            code.AppendLine("            }");
        }
    }

    private static void EmitHeaderBinding(StringBuilder code, in EndpointParameter param, string paramName,
        string bindFailFn)
    {
        var key = param.KeyName ?? param.Name;
        code.AppendLine($"            {param.TypeFqn}? {paramName};");
        code.AppendLine(
            $"            if (!ctx.Request.Headers.TryGetValue(\"{key}\", out var {paramName}Raw) || {paramName}Raw.Count == 0)");
        code.AppendLine("            {");
        code.AppendLine(param.IsNullable
            ? $"                {paramName} = default;"
            : $"                return {bindFailFn}(\"{param.Name}\", \"is required\");");
        code.AppendLine("            }");
        code.AppendLine("            else");
        code.AppendLine("            {");
        code.AppendLine(IsStringType(param.TypeFqn)
            ? $"                {paramName} = {paramName}Raw.ToString();"
            : $"                if (!{GetTryParseExpression(param.TypeFqn, paramName + "Raw.ToString()", paramName + "Temp")}) return {bindFailFn}(\"{param.Name}\", \"has invalid format\"); {paramName} = {paramName}Temp;");
        code.AppendLine("            }");
    }

    private static void EmitBodyBinding(StringBuilder code, in EndpointParameter param, string paramName,
        string bindFailFn)
    {
        code.AppendLine($"            {param.TypeFqn}? {paramName};");
        code.AppendLine("            try");
        code.AppendLine("            {");
        code.AppendLine(
            $"                {paramName} = await ctx.Request.ReadFromJsonAsync<{param.TypeFqn}>(cancellationToken: ctx.RequestAborted);");
        code.AppendLine("            }");
        code.AppendLine("            catch (global::System.Text.Json.JsonException)");
        code.AppendLine("            {");
        code.AppendLine($"                return {bindFailFn}(\"{param.Name}\", \"has invalid JSON format\");");
        code.AppendLine("            }");
        code.AppendLine(
            $"            if ({paramName} is null) return {bindFailFn}(\"{param.Name}\", \"is required\");");
    }

    private static void EmitFormBinding(StringBuilder code, in EndpointParameter param, string paramName,
        string bindFailFn)
    {
        if (!param.Children.IsDefaultOrEmpty)
        {
            for (var i = 0; i < param.Children.Length; i++)
            {
                var child = param.Children[i];
                // Thread bindFailFn through nested form bindings
                EmitParameterBinding(code, in child, $"{paramName}_f{i}", bindFailFn);
            }

            var args = string.Join(", ", param.Children.AsImmutableArray().Select((_, i) => $"{paramName}_f{i}"));
            code.AppendLine($"            var {paramName} = new {param.TypeFqn}({args});");
        }
        else
        {
            var fieldName = param.KeyName ?? param.Name;
            code.AppendLine($"            {param.TypeFqn} {paramName};");
            code.AppendLine(
                $"            if (!form.TryGetValue(\"{fieldName}\", out var {paramName}Raw) || {paramName}Raw.Count == 0)");
            code.AppendLine("            {");
            code.AppendLine(param.IsNullable
                ? $"                {paramName} = default;"
                : $"                return {bindFailFn}(\"{param.Name}\", \"is required\");");
            code.AppendLine("            }");
            code.AppendLine("            else");
            code.AppendLine("            {");
            if (IsStringType(param.TypeFqn))
                code.AppendLine($"                {paramName} = {paramName}Raw.ToString();");
            else
            {
                code.AppendLine(
                    $"                if (!{GetTryParseExpression(param.TypeFqn, paramName + "Raw.ToString()", paramName + "Temp")}) return {bindFailFn}(\"{param.Name}\", \"has invalid format\");");
                code.AppendLine($"                {paramName} = {paramName}Temp;");
            }

            code.AppendLine("            }");
        }
    }

    private static void EmitAsParametersBinding(StringBuilder code, in EndpointParameter param, string paramName,
        string bindFailFn)
    {
        var childVars = new List<string>();
        for (var i = 0; i < param.Children.Length; i++)
        {
            var child = param.Children[i];
            var childVarName = $"{paramName}_c{i}";
            // Thread bindFailFn through nested AsParameters bindings
            EmitParameterBinding(code, in child, childVarName, bindFailFn);
            childVars.Add(BuildArgumentExpression(in child, childVarName));
        }

        code.AppendLine($"            var {paramName} = new {param.TypeFqn}({string.Join(", ", childVars)});");
    }

    private static void EmitFormContentTypeGuard(StringBuilder code)
    {
        // BindFail is already emitted per-invoker, use it for consistency
        code.AppendLine(
            "            if (!ctx.Request.HasFormContentType) return BindFail(\"form\", \"content-type must be multipart/form-data\");");
        code.AppendLine("            var form = await ctx.Request.ReadFormAsync(ctx.RequestAborted);");
        code.AppendLine();
    }

    private static void EmitJsonConfigExtension(StringBuilder code)
    {
        code.AppendLine(
            "        public static IServiceCollection AddErrorOrEndpointJson<TContext>(this IServiceCollection services)");
        code.AppendLine("            where TContext : System.Text.Json.Serialization.JsonSerializerContext, new()");
        code.AppendLine("        {");
        code.AppendLine("            var context = new TContext();");
        code.AppendLine(
            "            services.ConfigureHttpJsonOptions(options => options.SerializerOptions.TypeInfoResolverChain.Insert(0, context));");
        code.AppendLine("            return services;");
        code.AppendLine("        }");
        code.AppendLine();
    }

    private static void EmitJsonContextSuggestion(SourceProductionContext spc, List<string> jsonTypes)
    {
        var code = new StringBuilder();
        code.AppendLine("// SUGGESTED JSON CONTEXT FOR NATIVE AOT");
        code.AppendLine("#if ERROROR_JSON");
        code.AppendLine(
            "[System.Text.Json.Serialization.JsonSourceGenerationOptions(DefaultIgnoreCondition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull)]");
        foreach (var type in jsonTypes)
            code.AppendLine($"[System.Text.Json.Serialization.JsonSerializable(typeof({type}))]");
        code.AppendLine(
            "[System.Text.Json.Serialization.JsonSerializable(typeof(global::Microsoft.AspNetCore.Mvc.ProblemDetails))]");
        code.AppendLine(
            "[System.Text.Json.Serialization.JsonSerializable(typeof(global::Microsoft.AspNetCore.Http.HttpValidationProblemDetails))]");
        code.AppendLine(
            "internal partial class ErrorOrJsonContext : System.Text.Json.Serialization.JsonSerializerContext { }");
        code.AppendLine("#endif");
        spc.AddSource("ErrorOrJsonContext.suggested.cs", SourceText.From(code.ToString(), Encoding.UTF8));
    }

    private static void EmitSupportMethods(StringBuilder code)
    {
        code.AppendLine(
            "        private static bool TryGetRouteValue(HttpContext ctx, string name, out string? value)");
        code.AppendLine("        {");
        code.AppendLine(
            "            if (!ctx.Request.RouteValues.TryGetValue(name, out var raw) || raw is null) { value = null; return false; }");
        code.AppendLine("            value = raw.ToString(); return value is not null;");
        code.AppendLine("        }");
        code.AppendLine();
        code.AppendLine(
            "        private static bool TryGetQueryValue(HttpContext ctx, string name, out string? value)");
        code.AppendLine("        {");
        code.AppendLine(
            "            if (!ctx.Request.Query.TryGetValue(name, out var raw) || raw.Count == 0) { value = null; return false; }");
        code.AppendLine("            value = raw.ToString(); return value is not null;");
        code.AppendLine("        }");
        code.AppendLine();
        code.AppendLine(
            "        private static global::Microsoft.AspNetCore.Http.IResult ToProblem(System.Collections.Generic.IReadOnlyList<global::ErrorOr.Error> errors)");
        code.AppendLine("        {");
        code.AppendLine("            if (errors.Count == 0) return TypedResults.Problem();");
        code.AppendLine("            var hasValidation = false;");
        code.AppendLine(
            "            for (var i = 0; i < errors.Count; i++) if (errors[i].Type == global::ErrorOr.ErrorType.Validation) { hasValidation = true; break; }");
        code.AppendLine("            if (hasValidation)");
        code.AppendLine("            {");
        code.AppendLine(
            "                var dict = new global::System.Collections.Generic.Dictionary<string, string[]>();");
        code.AppendLine("                for (var i = 0; i < errors.Count; i++)");
        code.AppendLine("                {");
        code.AppendLine(
            "                    var e = errors[i]; if (e.Type != global::ErrorOr.ErrorType.Validation) continue;");
        code.AppendLine(
            "                    if (!dict.TryGetValue(e.Code, out var existing)) dict[e.Code] = new[] { e.Description };");
        code.AppendLine(
            "                    else { var n = new string[existing.Length + 1]; existing.CopyTo(n, 0); n[existing.Length] = e.Description; dict[e.Code] = n; }");
        code.AppendLine("                }");
        code.AppendLine("                return TypedResults.ValidationProblem(dict);");
        code.AppendLine("            }");
        code.AppendLine("            var first = errors[0];");
        code.AppendLine(
            "            var status = first.Type switch { global::ErrorOr.ErrorType.Validation => 400, global::ErrorOr.ErrorType.Unauthorized => 401, global::ErrorOr.ErrorType.Forbidden => 403, global::ErrorOr.ErrorType.NotFound => 404, global::ErrorOr.ErrorType.Conflict => 409, global::ErrorOr.ErrorType.Failure => 422, _ => 500 };");
        code.AppendLine(
            "            return TypedResults.Problem(detail: first.Description, statusCode: status, title: first.Code);");
        code.AppendLine("        }");
    }

    private static string BuildArgumentExpression(in EndpointParameter param, string paramName)
    {
        return param.Source switch
        {
            EndpointParameterSource.Body when !param.IsNullable => paramName + "!",
            EndpointParameterSource.Route when !param.IsNullable && !param.IsNonNullableValueType => paramName + "!",
            EndpointParameterSource.Query when !param.IsNullable && !param.IsNonNullableValueType => paramName + "!",
            _ => paramName
        };
    }

    private static string GetTryParseExpression(string typeFqn, string rawName, string outputName,
        CustomBindingMethod customBinding = CustomBindingMethod.None)
    {
        // Handle custom TryParse types first
        if (customBinding is CustomBindingMethod.TryParse or CustomBindingMethod.TryParseWithFormat)
        {
            var baseType = typeFqn.TrimEnd('?');
            return $"{baseType}.TryParse({rawName}, out var {outputName})";
        }

        var normalized = typeFqn.Replace("global::", "").TrimEnd('?');
        return normalized switch
        {
            "System.Int32" or "int" => $"int.TryParse({rawName}, out var {outputName})",
            "System.Int64" or "long" => $"long.TryParse({rawName}, out var {outputName})",
            "System.Boolean" or "bool" => $"bool.TryParse({rawName}, out var {outputName})",
            "System.Guid" => $"global::System.Guid.TryParse({rawName}, out var {outputName})",
            "System.DateTime" => $"global::System.DateTime.TryParse({rawName}, out var {outputName})",
            "System.DateOnly" => $"global::System.DateOnly.TryParse({rawName}, out var {outputName})",
            "System.TimeOnly" => $"global::System.TimeOnly.TryParse({rawName}, out var {outputName})",
            "System.Double" or "double" => $"double.TryParse({rawName}, out var {outputName})",
            "System.Decimal" or "decimal" => $"decimal.TryParse({rawName}, out var {outputName})",
            _ => "false"
        };
    }

    private static bool IsStringType(string typeFqn)
    {
        return typeFqn is "global::System.String" or "System.String" or "string";
    }

    private static bool HasFormParams(in EndpointDescriptor ep)
    {
        return ep.HandlerParameters.AsImmutableArray().Any(static p =>
            p.Source is EndpointParameterSource.Form or EndpointParameterSource.FormFile
                or EndpointParameterSource.FormFiles or EndpointParameterSource.FormCollection);
    }

    private static bool NeedsBindingValidation(in EndpointDescriptor ep)
    {
        return ep.HandlerParameters.AsImmutableArray().Any(NeedsValidation);

        static bool NeedsValidation(EndpointParameter p)
        {
            // Check the parameter itself
            if (p.Source is EndpointParameterSource.Route
                or EndpointParameterSource.Query
                or EndpointParameterSource.Header
                or EndpointParameterSource.Body
                or EndpointParameterSource.Form
                or EndpointParameterSource.FormFile)
                return true;

            // Check children (e.g., AsParameters)
            if (!p.Children.IsDefaultOrEmpty)
                return p.Children.AsImmutableArray().Any(NeedsValidation);

            return false;
        }
    }

    private static string ExtractTypeName(string fqn)
    {
        var i = fqn.LastIndexOf('.');
        var n = i >= 0 ? fqn[(i + 1)..] : fqn;
        return n.StartsWith("::") ? n[2..] : n;
    }

    private static ImmutableArray<EndpointDescriptor> SortEndpoints(ImmutableArray<EndpointDescriptor> endpoints)
    {
        var list = new EndpointDescriptor[endpoints.Length];
        endpoints.CopyTo(list);
        Array.Sort(list, static (a, b) =>
        {
            var c = string.CompareOrdinal(a.HttpMethod, b.HttpMethod);
            if (c != 0) return c;
            c = string.CompareOrdinal(a.Pattern, b.Pattern);
            return c != 0 ? c : string.CompareOrdinal(a.HandlerMethodName, b.HandlerMethodName);
        });
        return [.. list];
    }

    private static List<string> CollectJsonTypes(ImmutableArray<EndpointDescriptor> endpoints)
    {
        var types = new HashSet<string>(StringComparer.Ordinal);
        foreach (var ep in endpoints)
        {
            foreach (var p in ep.HandlerParameters)
            {
                if (p.Source == EndpointParameterSource.Body)
                    types.Add(p.TypeFqn);
            }

            if (ep.IsSse && ep.SseItemTypeFqn is not null)
                types.Add(ep.SseItemTypeFqn);
            else if (!IsNoContentType(ep.SuccessTypeFqn))
                types.Add(ep.SuccessTypeFqn);
        }

        var sorted = types.ToList();
        sorted.Sort(StringComparer.Ordinal);
        return sorted;
    }
}
