{
  GeneratedSources: [
    {
      HintName: ErrorOrEndpointAttributes.Mappings.g.cs,
      Source:
// <auto-generated/>
#nullable enable

namespace ErrorOr
{
    /// <summary>
    /// Marks a static method as an ErrorOr endpoint with explicit HTTP method and route.
    /// Prefer using [Get], [Post], [Put], [Delete], or [Patch] for standard HTTP methods.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = false)]
    public sealed class ErrorOrEndpointAttribute : global::System.Attribute
    {
        public ErrorOrEndpointAttribute(string httpMethod, string route)
        {
            HttpMethod = httpMethod;
            Route = route;
        }
        public string HttpMethod { get; }
        public string Route { get; }
    }

    [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = false)]
    public sealed class GetAttribute : global::System.Attribute
    {
        public GetAttribute(string route) => Route = route;
        public string Route { get; }
    }

    [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = false)]
    public sealed class PostAttribute : global::System.Attribute
    {
        public PostAttribute(string route) => Route = route;
        public string Route { get; }
    }

    [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = false)]
    public sealed class PutAttribute : global::System.Attribute
    {
        public PutAttribute(string route) => Route = route;
        public string Route { get; }
    }

    [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = false)]
    public sealed class DeleteAttribute : global::System.Attribute
    {
        public DeleteAttribute(string route) => Route = route;
        public string Route { get; }
    }

    [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = false)]
    public sealed class PatchAttribute : global::System.Attribute
    {
        public PatchAttribute(string route) => Route = route;
        public string Route { get; }
    }

    [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = true)]
    public sealed class ProducesErrorAttribute : global::System.Attribute
    {
        public ProducesErrorAttribute(int statusCode, string errorType)
        {
            StatusCode = statusCode;
            ErrorType = errorType;
        }
        public int StatusCode { get; }
        public string ErrorType { get; }
    }

    [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = false)]
    public sealed class AcceptedResponseAttribute : global::System.Attribute { }

    [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = true)]
    public sealed class ReturnsErrorAttribute : global::System.Attribute
    {
        public ReturnsErrorAttribute(global::ErrorOr.ErrorType errorType, string errorCode)
        {
            ErrorType = errorType;
            ErrorCode = errorCode;
        }
        public ReturnsErrorAttribute(int statusCode, string errorCode)
        {
            StatusCode = statusCode;
            ErrorCode = errorCode;
            ErrorType = null;
        }
        public global::ErrorOr.ErrorType? ErrorType { get; }
        public int? StatusCode { get; }
        public string ErrorCode { get; }
    }

    /// <summary>
    /// Marks a class as a route group for versioned API endpoints.
    /// All endpoints in the class will be mapped under the specified path prefix
    /// using the eShop-style NewVersionedApi() pattern when combined with [ApiVersion].
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class, AllowMultiple = false)]
    public sealed class RouteGroupAttribute : global::System.Attribute
    {
        public RouteGroupAttribute(string path) => Path = path;
        public string Path { get; }
        public string? ApiName { get; set; }
    }
}
    },
    {
      HintName: ErrorOrEndpointMappings.cs,
      Source:
// <auto-generated/>
// This file was auto-generated by ErrorOr.Generators.
// Do not modify this file directly.

#nullable enable
using System;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Routing;
using Microsoft.Extensions.DependencyInjection;

namespace ErrorOr.Generated
{
    /// <summary>
    /// Generated endpoint mappings for all [ErrorOrEndpoint] handlers in this assembly.
    /// </summary>
    public static class ErrorOrEndpointMappings
    {
        /// <summary>
        /// Maps all ErrorOr endpoints to the application's routing table.
        /// </summary>
        /// <param name="app">The endpoint route builder to add mappings to.</param>
        public static void MapErrorOrEndpoints(this IEndpointRouteBuilder app)
        {
            // GET /users/{id:int} -> global::MyEndpoints.GetUser
            app.MapGet(@"/users/{id:int}", Invoke_Ep0)
                .WithName("MyEndpoints_GetUser")
                .WithTags("My")
                ;

        }

        /// <summary>
        /// Configures ErrorOr endpoints with fluent options.
        /// </summary>
        /// <param name="services">The service collection to configure.</param>
        /// <param name="configure">Optional configuration action.</param>
        /// <returns>The service collection for chaining.</returns>
        /// <example>
        /// <code>
        /// services.AddErrorOrEndpoints(options => options
        ///     .UseJsonContext&lt;AppJsonSerializerContext&gt;()
        ///     .WithCamelCase()
        ///     .WithIgnoreNulls());
        /// </code>
        /// </example>
        public static IServiceCollection AddErrorOrEndpoints(this IServiceCollection services, System.Action<ErrorOrEndpointOptions>? configure = null)
        {
            var options = new ErrorOrEndpointOptions();
            configure?.Invoke(options);
            options.Apply(services);
            return services;
        }

        private static async Task Invoke_Ep0(HttpContext ctx)
        {
            var __result = await Invoke_Ep0_Core(ctx);
            await __result.ExecuteAsync(ctx);
        }

        private static Task<global::Microsoft.AspNetCore.Http.HttpResults.Results<global::Microsoft.AspNetCore.Http.HttpResults.Ok<string>, global::Microsoft.AspNetCore.Http.HttpResults.BadRequest<global::Microsoft.AspNetCore.Mvc.ProblemDetails>, global::Microsoft.AspNetCore.Http.HttpResults.InternalServerError<global::Microsoft.AspNetCore.Mvc.ProblemDetails>>> Invoke_Ep0_Core(HttpContext ctx)
        {
            static global::Microsoft.AspNetCore.Mvc.ProblemDetails CreateBindProblem(string param, string reason) => new()
            {
                Title = "Bad Request",
                Detail = $"Parameter '{param}' {reason}.",
                Status = 400,
                Type = "https://httpstatuses.io/400",
            };

            static Task<global::Microsoft.AspNetCore.Http.HttpResults.Results<global::Microsoft.AspNetCore.Http.HttpResults.Ok<string>, global::Microsoft.AspNetCore.Http.HttpResults.BadRequest<global::Microsoft.AspNetCore.Mvc.ProblemDetails>, global::Microsoft.AspNetCore.Http.HttpResults.InternalServerError<global::Microsoft.AspNetCore.Mvc.ProblemDetails>>> BindFail(string param, string reason)
                => Task.FromResult<global::Microsoft.AspNetCore.Http.HttpResults.Results<global::Microsoft.AspNetCore.Http.HttpResults.Ok<string>, global::Microsoft.AspNetCore.Http.HttpResults.BadRequest<global::Microsoft.AspNetCore.Mvc.ProblemDetails>, global::Microsoft.AspNetCore.Http.HttpResults.InternalServerError<global::Microsoft.AspNetCore.Mvc.ProblemDetails>>>(global::Microsoft.AspNetCore.Http.TypedResults.BadRequest(CreateBindProblem(param, reason)));

            if (!TryGetRouteValue(ctx, "Id", out var p0_c0Raw) || !int.TryParse(p0_c0Raw, out var p0_c0)) return BindFail("Id", "has invalid format");
            var p0 = new global::SearchParams(p0_c0);
            var result = global::MyEndpoints.GetUser(p0);
            if (result.IsError)
            {
                var first = result.FirstError;
                var problem = new global::Microsoft.AspNetCore.Mvc.ProblemDetails
                {
                    Title = first.Code,
                    Detail = first.Description,
                    Status = first.Type switch { global::ErrorOr.ErrorType.Validation => 400, global::ErrorOr.ErrorType.Unauthorized => 401, global::ErrorOr.ErrorType.Forbidden => 403, global::ErrorOr.ErrorType.NotFound => 404, global::ErrorOr.ErrorType.Conflict => 409, global::ErrorOr.ErrorType.Failure => 500, global::ErrorOr.ErrorType.Unexpected => 500, _ => first.NumericType is >= 100 and <= 599 ? first.NumericType : 500 }
                };
                problem.Type = $"https://httpstatuses.io/{problem.Status}";

                switch (first.Type)
                {
                    default:
                        return Task.FromResult<global::Microsoft.AspNetCore.Http.HttpResults.Results<global::Microsoft.AspNetCore.Http.HttpResults.Ok<string>, global::Microsoft.AspNetCore.Http.HttpResults.BadRequest<global::Microsoft.AspNetCore.Mvc.ProblemDetails>, global::Microsoft.AspNetCore.Http.HttpResults.InternalServerError<global::Microsoft.AspNetCore.Mvc.ProblemDetails>>>(global::Microsoft.AspNetCore.Http.TypedResults.InternalServerError(problem));
                }
            }

            return Task.FromResult<global::Microsoft.AspNetCore.Http.HttpResults.Results<global::Microsoft.AspNetCore.Http.HttpResults.Ok<string>, global::Microsoft.AspNetCore.Http.HttpResults.BadRequest<global::Microsoft.AspNetCore.Mvc.ProblemDetails>, global::Microsoft.AspNetCore.Http.HttpResults.InternalServerError<global::Microsoft.AspNetCore.Mvc.ProblemDetails>>>(global::Microsoft.AspNetCore.Http.TypedResults.Ok(result.Value));
        }

        private static bool TryGetRouteValue(HttpContext ctx, string name, out string? value)
        {
            if (!ctx.Request.RouteValues.TryGetValue(name, out var raw) || raw is null) { value = null; return false; }
            value = raw.ToString(); return value is not null;
        }

        private static bool TryGetQueryValue(HttpContext ctx, string name, out string? value)
        {
            if (!ctx.Request.Query.TryGetValue(name, out var raw) || raw.Count is 0) { value = null; return false; }
            value = raw.ToString(); return value is not null;
        }

        private static global::Microsoft.AspNetCore.Http.IResult ToProblem(global::System.Collections.Generic.IReadOnlyList<global::ErrorOr.Error> errors)
        {
            if (errors.Count is 0) return global::Microsoft.AspNetCore.Http.TypedResults.Problem();
            var hasValidation = false;
            for (var i = 0; i < errors.Count; i++) if (errors[i].Type == global::ErrorOr.ErrorType.Validation) { hasValidation = true; break; }
            if (hasValidation)
            {
                var dict = new global::System.Collections.Generic.Dictionary<string, string[]>();
                foreach (var e in errors)
                {
                    if (e.Type != global::ErrorOr.ErrorType.Validation) continue;
                    if (!dict.TryGetValue(e.Code, out var existing))
                        dict[e.Code] = new[] { e.Description };
                    else
                    {
                        var arr = new string[existing.Length + 1];
                        existing.CopyTo(arr, 0);
                        arr[existing.Length] = e.Description;
                        dict[e.Code] = arr;
                    }
                }
                return global::Microsoft.AspNetCore.Http.TypedResults.ValidationProblem(dict);
            }
            var first = errors[0];
            var problem = new global::Microsoft.AspNetCore.Mvc.ProblemDetails
            {
                Title = first.Code,
                Detail = first.Description,
                Status = first.Type switch { global::ErrorOr.ErrorType.Validation => 400, global::ErrorOr.ErrorType.Unauthorized => 401, global::ErrorOr.ErrorType.Forbidden => 403, global::ErrorOr.ErrorType.NotFound => 404, global::ErrorOr.ErrorType.Conflict => 409, global::ErrorOr.ErrorType.Failure => 500, global::ErrorOr.ErrorType.Unexpected => 500, _ => first.NumericType is >= 100 and <= 599 ? first.NumericType : 500 }
            };
            problem.Type = $"https://httpstatuses.io/{problem.Status}";
            return problem.Status switch
            {
                400 => global::Microsoft.AspNetCore.Http.TypedResults.BadRequest(problem),
                401 => global::Microsoft.AspNetCore.Http.TypedResults.Unauthorized(),
                403 => global::Microsoft.AspNetCore.Http.TypedResults.Forbid(),
                404 => global::Microsoft.AspNetCore.Http.TypedResults.NotFound(problem),
                409 => global::Microsoft.AspNetCore.Http.TypedResults.Conflict(problem),
                422 => global::Microsoft.AspNetCore.Http.TypedResults.UnprocessableEntity(problem),
                500 => global::Microsoft.AspNetCore.Http.TypedResults.InternalServerError(problem),
                _ => global::Microsoft.AspNetCore.Http.TypedResults.Problem(detail: first.Description, statusCode: problem.Status ?? 500, title: first.Code, type: problem.Type)
            };
        }
    }
}

    },
    {
      HintName: ErrorOrEndpointOptions.g.cs,
      Source:
// <auto-generated>
// This file was generated by ErrorOr.Generators source generator.
// </auto-generated>

#nullable enable

namespace ErrorOr.Generated
{
    /// <summary>
    /// Options for configuring ErrorOr endpoints.
    /// </summary>
    public sealed class ErrorOrEndpointOptions
    {
        private global::System.Func<global::System.Text.Json.Serialization.JsonSerializerContext>? _jsonContextFactory;
        private bool _useCamelCase = true;
        private bool _ignoreNullValues = true;

        /// <summary>
        /// Registers a JsonSerializerContext for AOT-compatible JSON serialization.
        /// </summary>
        /// <typeparam name="TContext">The JsonSerializerContext type.</typeparam>
        /// <returns>The options instance for chaining.</returns>
        public ErrorOrEndpointOptions UseJsonContext<TContext>()
            where TContext : global::System.Text.Json.Serialization.JsonSerializerContext, new()
        {
            _jsonContextFactory = static () => new TContext();
            return this;
        }

        /// <summary>
        /// Uses camelCase for JSON property names.
        /// </summary>
        /// <param name="enabled">Whether to enable camelCase (default: true).</param>
        /// <returns>The options instance for chaining.</returns>
        public ErrorOrEndpointOptions WithCamelCase(bool enabled = true)
        {
            _useCamelCase = enabled;
            return this;
        }

        /// <summary>
        /// Ignores null values when serializing JSON.
        /// </summary>
        /// <param name="enabled">Whether to ignore nulls (default: true).</param>
        /// <returns>The options instance for chaining.</returns>
        public ErrorOrEndpointOptions WithIgnoreNulls(bool enabled = true)
        {
            _ignoreNullValues = enabled;
            return this;
        }

        /// <summary>
        /// Applies the configured options to the service collection.
        /// </summary>
        internal void Apply(global::Microsoft.Extensions.DependencyInjection.IServiceCollection services)
        {
            services.ConfigureHttpJsonOptions(options =>
            {
                if (_jsonContextFactory is not null)
                    options.SerializerOptions.TypeInfoResolverChain.Insert(0, _jsonContextFactory());

                if (_useCamelCase)
                    options.SerializerOptions.PropertyNamingPolicy = global::System.Text.Json.JsonNamingPolicy.CamelCase;

                if (_ignoreNullValues)
                    options.SerializerOptions.DefaultIgnoreCondition = global::System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull;
            });
        }
    }
}
    },
    {
      HintName: ErrorOrEndpoints.GlobalUsings.g.cs,
      Source:
// <auto-generated/>
global using ErrorOr.Generated;
    },
    {
      HintName: ErrorOrJsonContext.g.cs,
      Source:
// <auto-generated/>
// This file was auto-generated by ErrorOr.Generators.
// Do not modify this file directly.

// JSON serialization context for Native AOT support.
#nullable enable

[System.Text.Json.Serialization.JsonSourceGenerationOptions(DefaultIgnoreCondition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull)]
[System.Text.Json.Serialization.JsonSerializable(typeof(string))]
[System.Text.Json.Serialization.JsonSerializable(typeof(global::Microsoft.AspNetCore.Mvc.ProblemDetails))]
[System.Text.Json.Serialization.JsonSerializable(typeof(global::Microsoft.AspNetCore.Http.HttpValidationProblemDetails))]
internal partial class ErrorOrJsonContext : System.Text.Json.Serialization.JsonSerializerContext { }

    }
  ],
  Diagnostics: []
}