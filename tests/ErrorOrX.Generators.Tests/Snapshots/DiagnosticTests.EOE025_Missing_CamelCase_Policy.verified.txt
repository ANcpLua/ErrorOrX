{
  GeneratedSources: [
    {
      HintName: ErrorOrEndpointMappings.cs,
      Source:
// <auto-generated/>
// This file was auto-generated by ErrorOr.Generators.
// Do not modify this file directly.

#nullable enable
using System;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Routing;
using Microsoft.Extensions.DependencyInjection;

namespace ErrorOr.Generated
{
    /// <summary>
    /// Generated endpoint mappings for all [ErrorOrEndpoint] handlers in this assembly.
    /// </summary>
    public static class ErrorOrEndpointMappings
    {
        /// <summary>
        /// Maps all ErrorOr endpoints to the application's routing table.
        /// </summary>
        /// <param name="app">The endpoint route builder to add mappings to.</param>
        /// <returns>A convention builder for applying global conventions to all endpoints.</returns>
        /// <exception cref="InvalidOperationException">
        /// Thrown when AddErrorOrEndpoints() was not called during service registration.
        /// </exception>
        /// <remarks>
        /// This follows ASP.NET Core's convention builder pattern, enabling global
        /// endpoint configuration like RequireAuthorization() or RequireRateLimiting().
        /// </remarks>
        /// <example>
        /// <code>
        /// app.MapErrorOrEndpoints()
        ///    .RequireAuthorization()
        ///    .RequireRateLimiting("api");
        /// </code>
        /// </example>
        public static IEndpointConventionBuilder MapErrorOrEndpoints(this IEndpointRouteBuilder app)
        {
            // Validate that AddErrorOrEndpoints() was called
            var marker = app.ServiceProvider.GetService<ErrorOrEndpointsMarkerService>();
            if (marker is null)
            {
                throw new InvalidOperationException(
                    "Unable to find the required services. " +
                    "Please add all the required services by calling 'IServiceCollection.AddErrorOrEndpoints()' " +
                    "in the application startup code.");
            }

            var __endpointBuilders = new System.Collections.Generic.List<IEndpointConventionBuilder>();

            // GET /todos/{id} -> global::DiagnosticTest.TodoApi.GetById
            var __ep0 = app.MapGet(@"/todos/{id}", Invoke_Ep0)
                .WithName("DiagnosticTest_TodoApi_GetById")
                .WithTags("TodoApi")
                ;
            __endpointBuilders.Add(__ep0);


            return new CompositeEndpointConventionBuilder(__endpointBuilders);
        }

        /// <summary>
        /// Registers ErrorOr endpoint services and returns a builder for configuration.
        /// </summary>
        /// <param name="services">The service collection to configure.</param>
        /// <returns>A builder for further configuration.</returns>
        /// <remarks>
        /// This follows ASP.NET Core's builder pattern (like AddRazorComponents())
        /// enabling fluent extension method chaining without callback nesting.
        /// </remarks>
        /// <example>
        /// <code>
        /// builder.Services.AddErrorOrEndpoints()
        ///     .UseJsonContext&lt;AppJsonSerializerContext&gt;()
        ///     .WithCamelCase()
        ///     .WithIgnoreNulls();
        /// </code>
        /// </example>
        public static IErrorOrEndpointsBuilder AddErrorOrEndpoints(this IServiceCollection services)
        {
            // Register marker service for validation in MapErrorOrEndpoints()
            services.AddSingleton<ErrorOrEndpointsMarkerService>();
            return new ErrorOrEndpointsBuilder(services);
        }

        private static async Task Invoke_Ep0(HttpContext ctx)
        {
            var __result = await Invoke_Ep0_Core(ctx);
            await __result.ExecuteAsync(ctx);
        }

        private static Task<global::Microsoft.AspNetCore.Http.HttpResults.Results<global::Microsoft.AspNetCore.Http.HttpResults.Ok<global::DiagnosticTest.Todo>, global::Microsoft.AspNetCore.Http.HttpResults.BadRequest<global::Microsoft.AspNetCore.Mvc.ProblemDetails>, global::Microsoft.AspNetCore.Http.HttpResults.InternalServerError<global::Microsoft.AspNetCore.Mvc.ProblemDetails>>> Invoke_Ep0_Core(HttpContext ctx)
        {
            static global::Microsoft.AspNetCore.Mvc.ProblemDetails CreateBindProblem(string param, string reason) => new()
            {
                Title = "Bad Request",
                Detail = $"Parameter '{param}' {reason}.",
                Status = 400,
                Type = "https://httpstatuses.io/400",
            };

            static Task<global::Microsoft.AspNetCore.Http.HttpResults.Results<global::Microsoft.AspNetCore.Http.HttpResults.Ok<global::DiagnosticTest.Todo>, global::Microsoft.AspNetCore.Http.HttpResults.BadRequest<global::Microsoft.AspNetCore.Mvc.ProblemDetails>, global::Microsoft.AspNetCore.Http.HttpResults.InternalServerError<global::Microsoft.AspNetCore.Mvc.ProblemDetails>>> BindFail(string param, string reason)
                => Task.FromResult<global::Microsoft.AspNetCore.Http.HttpResults.Results<global::Microsoft.AspNetCore.Http.HttpResults.Ok<global::DiagnosticTest.Todo>, global::Microsoft.AspNetCore.Http.HttpResults.BadRequest<global::Microsoft.AspNetCore.Mvc.ProblemDetails>, global::Microsoft.AspNetCore.Http.HttpResults.InternalServerError<global::Microsoft.AspNetCore.Mvc.ProblemDetails>>>(global::Microsoft.AspNetCore.Http.TypedResults.BadRequest(CreateBindProblem(param, reason)));

            if (!TryGetRouteValue(ctx, "id", out var p0Raw) || !int.TryParse(p0Raw, out var p0)) return BindFail("id", "has invalid format");
            var result = global::DiagnosticTest.TodoApi.GetById(p0);
            if (result.IsError)
            {
                if (result.Errors.Count is 0) return Task.FromResult<global::Microsoft.AspNetCore.Http.HttpResults.Results<global::Microsoft.AspNetCore.Http.HttpResults.Ok<global::DiagnosticTest.Todo>, global::Microsoft.AspNetCore.Http.HttpResults.BadRequest<global::Microsoft.AspNetCore.Mvc.ProblemDetails>, global::Microsoft.AspNetCore.Http.HttpResults.InternalServerError<global::Microsoft.AspNetCore.Mvc.ProblemDetails>>>(global::Microsoft.AspNetCore.Http.TypedResults.InternalServerError(new global::Microsoft.AspNetCore.Mvc.ProblemDetails { Title = "Error", Detail = "An error occurred but no details were provided.", Status = 500 }));
                var first = result.Errors[0];
                var problem = new global::Microsoft.AspNetCore.Mvc.ProblemDetails
                {
                    Title = first.Code,
                    Detail = first.Description,
                    Status = first.Type switch { global::ErrorOr.ErrorType.Validation => 400, global::ErrorOr.ErrorType.Unauthorized => 401, global::ErrorOr.ErrorType.Forbidden => 403, global::ErrorOr.ErrorType.NotFound => 404, global::ErrorOr.ErrorType.Conflict => 409, global::ErrorOr.ErrorType.Failure => 500, global::ErrorOr.ErrorType.Unexpected => 500, _ => (int)first.Type is >= 100 and <= 599 ? (int)first.Type : 500 }
                };
                problem.Type = $"https://httpstatuses.io/{problem.Status}";

                switch (first.Type)
                {
                    default:
                        return Task.FromResult<global::Microsoft.AspNetCore.Http.HttpResults.Results<global::Microsoft.AspNetCore.Http.HttpResults.Ok<global::DiagnosticTest.Todo>, global::Microsoft.AspNetCore.Http.HttpResults.BadRequest<global::Microsoft.AspNetCore.Mvc.ProblemDetails>, global::Microsoft.AspNetCore.Http.HttpResults.InternalServerError<global::Microsoft.AspNetCore.Mvc.ProblemDetails>>>(global::Microsoft.AspNetCore.Http.TypedResults.InternalServerError(problem));
                }
            }

            return Task.FromResult<global::Microsoft.AspNetCore.Http.HttpResults.Results<global::Microsoft.AspNetCore.Http.HttpResults.Ok<global::DiagnosticTest.Todo>, global::Microsoft.AspNetCore.Http.HttpResults.BadRequest<global::Microsoft.AspNetCore.Mvc.ProblemDetails>, global::Microsoft.AspNetCore.Http.HttpResults.InternalServerError<global::Microsoft.AspNetCore.Mvc.ProblemDetails>>>(global::Microsoft.AspNetCore.Http.TypedResults.Ok(result.Value));
        }

        private static bool TryGetRouteValue(HttpContext ctx, string name, out string? value)
        {
            if (!ctx.Request.RouteValues.TryGetValue(name, out var raw) || raw is null) { value = null; return false; }
            value = raw.ToString(); return value is not null;
        }

        private static bool TryGetQueryValue(HttpContext ctx, string name, out string? value)
        {
            if (!ctx.Request.Query.TryGetValue(name, out var raw) || raw.Count is 0) { value = null; return false; }
            value = raw.ToString(); return value is not null;
        }

        private static global::Microsoft.AspNetCore.Http.IResult ToProblem(global::System.Collections.Generic.IReadOnlyList<global::ErrorOr.Error> errors)
        {
            if (errors.Count is 0) return global::Microsoft.AspNetCore.Http.TypedResults.Problem();
            var hasValidation = false;
            for (var i = 0; i < errors.Count; i++) if (errors[i].Type == global::ErrorOr.ErrorType.Validation) { hasValidation = true; break; }
            if (hasValidation)
            {
                var dict = new global::System.Collections.Generic.Dictionary<string, string[]>();
                foreach (var e in errors)
                {
                    if (e.Type != global::ErrorOr.ErrorType.Validation) continue;
                    if (!dict.TryGetValue(e.Code, out var existing))
                        dict[e.Code] = new[] { e.Description };
                    else
                    {
                        var arr = new string[existing.Length + 1];
                        existing.CopyTo(arr, 0);
                        arr[existing.Length] = e.Description;
                        dict[e.Code] = arr;
                    }
                }
                return global::Microsoft.AspNetCore.Http.TypedResults.ValidationProblem(dict);
            }
            var first = errors[0];
            var problem = new global::Microsoft.AspNetCore.Mvc.ProblemDetails
            {
                Title = first.Code,
                Detail = first.Description,
                Status = first.Type switch { global::ErrorOr.ErrorType.Validation => 400, global::ErrorOr.ErrorType.Unauthorized => 401, global::ErrorOr.ErrorType.Forbidden => 403, global::ErrorOr.ErrorType.NotFound => 404, global::ErrorOr.ErrorType.Conflict => 409, global::ErrorOr.ErrorType.Failure => 500, global::ErrorOr.ErrorType.Unexpected => 500, _ => (int)first.Type is >= 100 and <= 599 ? (int)first.Type : 500 }
            };
            problem.Type = $"https://httpstatuses.io/{problem.Status}";
            return problem.Status switch
            {
                400 => global::Microsoft.AspNetCore.Http.TypedResults.BadRequest(problem),
                401 => global::Microsoft.AspNetCore.Http.TypedResults.Unauthorized(),
                403 => global::Microsoft.AspNetCore.Http.TypedResults.Forbid(),
                404 => global::Microsoft.AspNetCore.Http.TypedResults.NotFound(problem),
                409 => global::Microsoft.AspNetCore.Http.TypedResults.Conflict(problem),
                422 => global::Microsoft.AspNetCore.Http.TypedResults.UnprocessableEntity(problem),
                500 => global::Microsoft.AspNetCore.Http.TypedResults.InternalServerError(problem),
                _ => global::Microsoft.AspNetCore.Http.TypedResults.Problem(detail: first.Description, statusCode: problem.Status ?? 500, title: first.Code, type: problem.Type)
            };
        }
    }
}

    },
    {
      HintName: ErrorOrEndpointOptions.g.cs,
      Source:
// <auto-generated>
// This file was generated by ErrorOr.Generators source generator.
// </auto-generated>

#nullable enable

namespace ErrorOr.Generated
{
    /// <summary>
    /// Marker service to verify that AddErrorOrEndpoints() was called.
    /// </summary>
    /// <remarks>
    /// This follows the ASP.NET Core pattern used by RazorComponentsMarkerService
    /// to provide clear error messages when the service registration is missing.
    /// </remarks>
    internal sealed class ErrorOrEndpointsMarkerService { }

    /// <summary>
    /// Builder interface for configuring ErrorOr endpoints.
    /// </summary>
    /// <remarks>
    /// This pattern follows ASP.NET Core's IRazorComponentsBuilder design,
    /// enabling fluent extension method chaining without callback nesting.
    /// </remarks>
    public interface IErrorOrEndpointsBuilder
    {
        /// <summary>
        /// Gets the service collection being configured.
        /// </summary>
        global::Microsoft.Extensions.DependencyInjection.IServiceCollection Services { get; }
    }

    /// <summary>
    /// Default implementation of <see cref="IErrorOrEndpointsBuilder"/>.
    /// </summary>
    internal sealed class ErrorOrEndpointsBuilder : IErrorOrEndpointsBuilder
    {
        public ErrorOrEndpointsBuilder(global::Microsoft.Extensions.DependencyInjection.IServiceCollection services)
        {
            Services = services;
        }

        public global::Microsoft.Extensions.DependencyInjection.IServiceCollection Services { get; }
    }

    /// <summary>
    /// Extension methods for <see cref="IErrorOrEndpointsBuilder"/>.
    /// </summary>
    public static class ErrorOrEndpointsBuilderExtensions
    {
        /// <summary>
        /// Registers a JsonSerializerContext for AOT-compatible JSON serialization.
        /// </summary>
        /// <typeparam name="TContext">The JsonSerializerContext type.</typeparam>
        /// <param name="builder">The builder instance.</param>
        /// <returns>The builder instance for chaining.</returns>
        public static IErrorOrEndpointsBuilder UseJsonContext<TContext>(this IErrorOrEndpointsBuilder builder)
            where TContext : global::System.Text.Json.Serialization.JsonSerializerContext, new()
        {
            builder.Services.ConfigureHttpJsonOptions(options =>
            {
                options.SerializerOptions.TypeInfoResolverChain.Insert(0, new TContext());
            });
            return builder;
        }

        /// <summary>
        /// Uses camelCase for JSON property names.
        /// </summary>
        /// <param name="builder">The builder instance.</param>
        /// <param name="enabled">Whether to enable camelCase (default: true).</param>
        /// <returns>The builder instance for chaining.</returns>
        public static IErrorOrEndpointsBuilder WithCamelCase(this IErrorOrEndpointsBuilder builder, bool enabled = true)
        {
            if (enabled)
            {
                builder.Services.ConfigureHttpJsonOptions(options =>
                {
                    options.SerializerOptions.PropertyNamingPolicy = global::System.Text.Json.JsonNamingPolicy.CamelCase;
                });
            }
            return builder;
        }

        /// <summary>
        /// Ignores null values when serializing JSON.
        /// </summary>
        /// <param name="builder">The builder instance.</param>
        /// <param name="enabled">Whether to ignore nulls (default: true).</param>
        /// <returns>The builder instance for chaining.</returns>
        public static IErrorOrEndpointsBuilder WithIgnoreNulls(this IErrorOrEndpointsBuilder builder, bool enabled = true)
        {
            if (enabled)
            {
                builder.Services.ConfigureHttpJsonOptions(options =>
                {
                    options.SerializerOptions.DefaultIgnoreCondition = global::System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull;
                });
            }
            return builder;
        }
    }

    /// <summary>
    /// Composite convention builder that applies conventions to multiple endpoints.
    /// </summary>
    /// <remarks>
    /// This follows the ASP.NET Core pattern for applying global conventions
    /// to all endpoints registered by MapErrorOrEndpoints().
    /// </remarks>
    internal sealed class CompositeEndpointConventionBuilder : global::Microsoft.AspNetCore.Builder.IEndpointConventionBuilder
    {
        private readonly global::System.Collections.Generic.List<global::Microsoft.AspNetCore.Builder.IEndpointConventionBuilder> _builders;

        public CompositeEndpointConventionBuilder(global::System.Collections.Generic.List<global::Microsoft.AspNetCore.Builder.IEndpointConventionBuilder> builders)
        {
            _builders = builders;
        }

        public void Add(global::System.Action<global::Microsoft.AspNetCore.Builder.EndpointBuilder> convention)
        {
            foreach (var builder in _builders)
            {
                builder.Add(convention);
            }
        }

        public void Finally(global::System.Action<global::Microsoft.AspNetCore.Builder.EndpointBuilder> finallyConvention)
        {
            foreach (var builder in _builders)
            {
                builder.Finally(finallyConvention);
            }
        }
    }
}
    },
    {
      HintName: ErrorOrEndpoints.GlobalUsings.g.cs,
      Source:
// <auto-generated/>
global using ErrorOr.Generated;
    },
    {
      HintName: ErrorOrJsonContext.g.cs,
      Source:
// <auto-generated/>
// This file was auto-generated by ErrorOr.Generators.
// Do not modify this file directly.

// ErrorOrX JSON Context Helper

// Detected user JsonSerializerContext: DiagnosticTest.AppJsonContext

// ============================================================================
// MISSING TYPES - Add these [JsonSerializable] attributes to your context:
// ============================================================================
//
// [JsonSerializable(typeof(Microsoft.AspNetCore.Mvc.ProblemDetails))]
// [JsonSerializable(typeof(Microsoft.AspNetCore.Http.HttpValidationProblemDetails))]
//

// ============================================================================
// RECOMMENDED - Add CamelCase policy for web API compatibility:
// ============================================================================
//
// [JsonSourceGenerationOptions(
//     PropertyNamingPolicy = JsonKnownNamingPolicy.CamelCase,
//     DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull)]
//

    }
  ],
  Diagnostics: [
    {
      Id: EOE007,
      Severity: Error,
      Message: Type 'Microsoft.AspNetCore.Mvc.ProblemDetails' used by 'ErrorOr endpoints' is not in any [JsonSerializable] context. Add [JsonSerializable(typeof(Microsoft.AspNetCore.Mvc.ProblemDetails))] to your JsonSerializerContext.
    },
    {
      Id: EOE007,
      Severity: Error,
      Message: Type 'Microsoft.AspNetCore.Http.HttpValidationProblemDetails' used by 'ErrorOr endpoints' is not in any [JsonSerializable] context. Add [JsonSerializable(typeof(Microsoft.AspNetCore.Http.HttpValidationProblemDetails))] to your JsonSerializerContext.
    },
    {
      Id: EOE025,
      Severity: Warning,
      Message: JsonSerializerContext 'DiagnosticTest.AppJsonContext' should use PropertyNamingPolicy = JsonKnownNamingPolicy.CamelCase for web API compatibility. Add [JsonSourceGenerationOptions(PropertyNamingPolicy = JsonKnownNamingPolicy.CamelCase)] to the class.
    },
    {
      Id: EOE041,
      Severity: Warning,
      Message: JsonSerializerContext 'DiagnosticTest.AppJsonContext' should include [JsonSerializable(typeof(ProblemDetails))] and [JsonSerializable(typeof(HttpValidationProblemDetails))] for error responses
    }
  ]
}